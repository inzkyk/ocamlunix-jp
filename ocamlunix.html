<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.32">
<style type="text/css">
.c000{border-spacing:6px;border-collapse:separate;}
.c001{color:#0000E5}
.c002{color:#CC7F4C}
.c003{font-family:monospace}
.c004{font-size:small}
.c005{font-size:xx-small}
.c006{font-style:italic}
.c007{font-variant:small-caps}
.c008{font-weight:bold;font-size:small}
.c009{text-align:center;border:solid 1px;white-space:nowrap}
.c010{text-align:center;white-space:nowrap}
.c011{text-align:left;white-space:nowrap}
.c012{text-align:right;white-space:nowrap}
.c013{vertical-align:top;text-align:left;}
.c014{vertical-align:top;text-align:left;white-space:nowrap}
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
*{padding: 0em; border: 0em; margin: 0em;
font-family: 'ヒラギノ角ゴシック','Hiragino Sans',sans-serif; font-weight: normal;
font-size: 100%;}
BODY{margin: 2em 10% 2em 10%;
font-size: 10pt; line-height: 140%; text-align: justify;
background: white; color: black;
max-width: 75ex; min-width: 40ex;}
TT{font-family:monospace;}
TT A{font-family:monospace;}
B{font-weight: bold }
A{color: blue; text-decoration : none }
.titlerest SUP{font-size: 70%; padding-right:0.5ex }
.title{margin:0em; border: 0em; padding: 0em; border-spacing:0px;}
.title *{margin-left:0em; padding-left: 0em; border-style:none}
.titlemain{font-size: 180%;}
.titlerest{text-align: left; margin-top: 1em}
.copyrightnotice{margin-top: 2em;
			 margin-bottom: 1em;
font-size: 80%;
text-align: left}
.ccimage{vertical-align: text-top;}
.abstract{margin-top: 1em }
UL{padding-top: 1ex; }
LI{padding-top: 1ex; }
.chapter{margin-top:2ex; font-size: 180%;
		 text-align:left; line-height:130%; }
.chapter A{color: black }
.section{font-size: 140%; margin-top: 1.5em; text-align:left}
.section A{color: black }
.subsection{font-weight: bold; margin-top: 1em; text-align:left}
.paragraph{font-weight: bold; display:inline-block;
		 padding-top: 1em; padding-right: 1em}
P{padding-top : 1em }
.paragraph + P{padding-top : 0em; display: inline; }
.li-toc A{color: black }
.li-toc A:hover{color: blue }
.toc .li-toc{padding-top: 1.5em}
.toc .li-toc A{font-weight: bold }
.toc .li-toc .toc .li-toc{padding-top: 0.5ex }
.toc .li-toc .toc .li-toc A {margin-left:1.5em;
	 font-weight: normal }
HR.footnoterule{border-width: 0pt }
HR{margin: 1em 0em 1em 0em;
	 border-width: thin;
		border-bottom-style: solid;}
.li-indexenv{list-style-type : none}
.li-indexenv B A{font-weight : bold}
DIV.fancybreak{text-align:center; padding-top:1em }
CODE{font-family:monospace; white-space:pre;}
DIV.mylisting{padding-top : 1em; font-family:monospace;
		 white-space:pre; margin-right:auto;
		 margin-left:0ex; text-align:left;}
.mylisting b{font-family:monospace; font-weight : bold }
.mylisting FONT{font-family:monospace;
		 font-size: 70% !important;
		 margin-left: -3.1em }
.mylisting A{font-family:monospace; color : #0000A0 }
.mltypecases TD:first-child{padding-left:0em }
.mltypecases TABLE{border-spacing:0px 6px !important;
		 margin-top: 0em; }
DIV.figure{margin-top:1em;
padding-bottom:1em;
	 border-width: thin;
		 border-bottom-style: solid;
border-top-style: solid;
text-align: center; }
DIV.table{text-align: center; margin-top: 1em; margin-bottom: 1em}
TABLE{empty-cells:show }
TR{margin-top: 4ex }
TD{padding-left: 2ex; padding-top:1ex }
.hbar{background-color:white;
border-width:thin;
		 border-top-style: solid;
		 padding-top: 0em;
		 height:0px;}
.caption{margin-top: 1.5em; }
.image{display: block; text-align: center; margin-top:1em; }
.thebibliography DL{margin-top : 1em;}
.thebibliography DT{margin-top : 1em;}
.thebibliography DD{display : inline; }
.thebibliography FONT{color: black; }
.thebibliography B{font-weight : bold}
.bibsection{font-weight : bold}
</style>
<title>OCaml による Unix システムプログラミング
</title>
</head>
<body>
<!--HEVEA command line is: hevea book.hva -I src -o src/ocamlunix.html -fix -O -exec xxdate.exe src/ocamlunix.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 0 --><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">OCaml による Unix システムプログラミング</h1><h3 class="titlerest">Xavier Leroy and Didier Rémy</h3><h3 class="titlerest">4<sup>th</sup>October, 2018</h3></td></tr>
</table><div class="copyrightnotice">
© 1991, 1992, 2003, 2004, 2005, 2006, 2008, 2009, 2010 <br>
Xavier Leroy and Didier Rémy, <span class="c007">inria</span> Rocquencourt.<br>
Rights reserved.
Consult the <a href="LICENSE">license.</a> <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img class="ccimage" src="https://i.creativecommons.org/l/by-nc-sa/2.0/fr/80x15.png" alt="CreativeCommons License"></a>
<p><em>Translation by</em>
Daniel C. Bünzli,
Eric Cooper,
Eliot Handelman,
Priya Hattiangdi,
Thad Meyer,
Prashanth Mundkur,
Richard Paradies,
Till Varoquaux,
Mark Wong-VanHaren</p><p><em>Proofread by</em>
David Allsopp,
Erik de Castro Lopo,
John Clements,
Anil Madhavapeddy,
Prashanth Mundkur</p><p><em>Translation coordination &amp; layout by</em> Daniel C. Bünzli.</p><p><em>英語版の日本語への翻訳: </em> Yuki (<a href="https://github.com/inzkyk">github</a>)</p><p>誤訳の指摘などは <a href="https://github.com/inzkyk/ocamlunix-jp/issues"><span class="c003">https://github.com/inzkyk/ocamlunix-jp/issues</span></a> まで。</p></div><p>
次のフォーマットが利用可能です: <a href="ocamlunix.html">一つのウェブページ</a>, <a href="index.html">章ごとのウェブページ</a>, <a href="ocamlunix.pdf">PDF</a> — <a href="https://github.com/inzkyk/ocamlunix-jp">git リポジトリ</a>
</p><div class="abstract">
この文書は Unix システムプログラミングの入門コースであり、特にプロセス間通信に重点を置いています。システムプログラミングで一般的な C 言語ではなく、ML 言語の方言である OCaml 言語を使っていることがこの文書の一番の特徴であり、これによってシステムプログラミングと ML 言語に対する普通とは異なる視点を持つことができます。
</div><!--TOC chapter id="sec1" 目次-->
<h1 class="chapter" id="sec1">目次</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#htocintro">イントロダクション</a>
</li><li class="li-toc"><a href="#sec3"> 1  基礎</a>
<ul class="toc"><li class="li-toc">
<a href="#sec4">1.1  <span class="c003">Sys</span> モジュールと <span class="c003">Unix</span> モジュール</a>
</li><li class="li-toc"><a href="#sec5">1.2  プログラムを呼ぶためのインターフェース</a>
</li><li class="li-toc"><a href="#sec7">1.3  エラー処理</a>
</li><li class="li-toc"><a href="#sec8">1.4  ライブラリ関数</a>
</li></ul>
</li><li class="li-toc"><a href="#sec%2Ffiles"> 2  ファイル</a>
<ul class="toc"><li class="li-toc">
<a href="#sec12">2.1  ファイルシステム</a>
</li><li class="li-toc"><a href="#sec13">2.2  ファイル名とファイルディスクリプタ</a>
</li><li class="li-toc"><a href="#sec14">2.3  ファイルのメタ属性、種類、権限</a>
</li><li class="li-toc"><a href="#sec18">2.4  ディレクトリに対する操作</a>
</li><li class="li-toc"><a href="#ex%2Ffind">2.5  完全な例: ファイル階層の検索</a>
</li><li class="li-toc"><a href="#sec25">2.6  ファイルのオープン</a>
</li><li class="li-toc"><a href="#sec28">2.7  読み込みと書き込み</a>
</li><li class="li-toc"><a href="#sec32">2.8  ディスクリプタのクローズ</a>
</li><li class="li-toc"><a href="#ex%2Ffilecopy">2.9  完全な例: ファイルのコピー</a>
</li><li class="li-toc"><a href="#sec36">2.10  システムコールのコストとバッファ</a>
</li><li class="li-toc"><a href="#sec37">2.11  完全な例: 簡単な入出力ライブラリ</a>
</li><li class="li-toc"><a href="#sec40">2.12  入出力の位置</a>
</li><li class="li-toc"><a href="#sec44">2.13  ファイルの種類に特有の操作</a>
</li><li class="li-toc"><a href="#sec50">2.14  ファイルのロック</a>
</li><li class="li-toc"><a href="#sec%2Fcopyrec">2.15  完全な例: 再帰的なファイルのコピー</a>
</li><li class="li-toc"><a href="#sec54">2.16  完全な例: TAR</a>
</li></ul>
</li><li class="li-toc"><a href="#sec%2Fprocesses"> 3  プロセス</a>
<ul class="toc"><li class="li-toc">
<a href="#sec67">3.1  プロセスの作成</a>
</li><li class="li-toc"><a href="#sec68">3.2  完全な例: <span class="c003">leave</span> コマンド</a>
</li><li class="li-toc"><a href="#sec69">3.3  プロセスの終了を待つ</a>
</li><li class="li-toc"><a href="#sec71">3.4  プログラムの起動</a>
</li><li class="li-toc"><a href="#sec75">3.5  完全な例: ミニシェル</a>
</li></ul>
</li><li class="li-toc"><a href="#sec%2Fsignals"> 4  シグナル</a>
<ul class="toc"><li class="li-toc">
<a href="#sec79">4.1  デフォルトの動作</a>
</li><li class="li-toc"><a href="#sec%2Fusingsignals">4.2  シグナルの利用</a>
</li><li class="li-toc"><a href="#sec81">4.3  シグナルに対する動作の変更</a>
</li><li class="li-toc"><a href="#sec87">4.4  シグナルのマスク</a>
</li><li class="li-toc"><a href="#sec%2Fsigsyscalls">4.5  シグナルとシステムコール</a>
</li><li class="li-toc"><a href="#sec91">4.6  時間の経過</a>
</li><li class="li-toc"><a href="#sec98">4.7  シグナルの問題点</a>
</li></ul>
</li><li class="li-toc"><a href="#sec%2Fpipes"> 5  古典的なプロセス間通信: パイプ</a>
<ul class="toc"><li class="li-toc">
<a href="#sec100">5.1  パイプ</a>
</li><li class="li-toc"><a href="#ex%2Fcrible">5.2  完全な例: 並列エラトステネスのふるい</a>
</li><li class="li-toc"><a href="#sec107">5.3  名前付きパイプ</a>
</li><li class="li-toc"><a href="#sec108">5.4  ディスクリプタのリダイレクト</a>
</li><li class="li-toc"><a href="#sec114">5.5  完全な例: <span class="c006">N</span> 個のコマンドの合成</a>
</li><li class="li-toc"><a href="#sec115">5.6  入出力の多重化</a>
</li><li class="li-toc"><a href="#single_write">5.7  その他: <span class="c003">write</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec%2Fsockets"> 6  モダンなプロセス間通信: ソケット</a>
<ul class="toc"><li class="li-toc">
<a href="#sec120">6.1  ソケット</a>
</li><li class="li-toc"><a href="#sec121">6.2  ソケットの作成</a>
</li><li class="li-toc"><a href="#sec122">6.3  アドレス</a>
</li><li class="li-toc"><a href="#sec124">6.4  サーバへの接続</a>
</li><li class="li-toc"><a href="#sec125">6.5  ソケットの切断</a>
</li><li class="li-toc"><a href="#sec%2Funivclient">6.6  完全な例: ユニバーサルクライアント</a>
</li><li class="li-toc"><a href="#sec%2Fservice">6.7  サービスの確立</a>
</li><li class="li-toc"><a href="#sec128">6.8  ソケットの設定</a>
</li><li class="li-toc"><a href="#sec130">6.9  完全な例: ユニバーサルなサーバ</a>
</li><li class="li-toc"><a href="#sec%2Fmode-deconnecte">6.10  コネクションレス型通信</a>
</li><li class="li-toc"><a href="#sec133">6.11  低レベル入出力</a>
</li><li class="li-toc"><a href="#sec134">6.12  高レベルプリミティブ</a>
</li><li class="li-toc"><a href="#sec135">6.13  プロトコルの例</a>
</li><li class="li-toc"><a href="#sec142">6.14  完全な例: <span class="c007">http</span> リクエスト</a>
</li></ul>
</li><li class="li-toc"><a href="#sec%2Fcoprocessus"> 7  スレッド</a>
<ul class="toc"><li class="li-toc">
<a href="#sec150">7.1  イントロダクション</a>
</li><li class="li-toc"><a href="#sec152">7.2  スレッドの作成と終了</a>
</li><li class="li-toc"><a href="#sec153">7.3  スレッドの終了待ち</a>
</li><li class="li-toc"><a href="#sec158">7.4  スレッドの同期: ロック</a>
</li><li class="li-toc"><a href="#ex%2Fth-relais">7.5  完全な例: <span class="c007">http</span> リレー</a>
</li><li class="li-toc"><a href="#sec164">7.6  条件変数</a>
</li><li class="li-toc"><a href="#sec167">7.7  イベントベースの同期通信</a>
</li><li class="li-toc"><a href="#sec170">7.8  実装の詳細</a>
</li></ul>
</li><li class="li-toc"><a href="#htocmore">さらに先へ</a>
</li><li class="li-toc"><a href="#htocrefs">References</a>
</li><li class="li-toc"><a href="#htocindex">索引</a>
</li></ul><!--NAME toc.html-->
<!--TOC chapter id="sec/intro" イントロダクション-->
<h1 class="chapter" id="sec/intro"><a id="htocintro">イントロダクション</a></h1><!--SEC END --><!--NAME intro.html-->
<p>この講義ノートは 1994 年に Xavier Leroy が高等師範学校で基礎・応用数学及び情報科学の修士課程 1 年生に対して行ったシステムプログラミングの講義が元になっています。初期の版では Caml-Light [<a href="#Caml-Light">1</a>] 言語が使われていました。</p><p>2003年から2006年にエコール・ポリテクニークで開かれた情報科学の修士課程学生向け講義のために、Didier Rémy はノートを改変し、 OCaml[<a href="#OCaml">2</a>] 言語が使われるようになりました。この期間に、Gilles Roussel, Fabrice Le Fessant と Maxence Guesdon は講義を助けるとともに、このノートにも貢献しました。この新しい版では要素の追加や更新が行われています。</p><p>最初の版からの約 10 年間のうちに、 扱われる数字の桁はコンマ 1 つ分大きくなりました。またweb は大きく発達し、1994 年当時には先駆的だった <span class="c007">http</span>リレーの例は現在では平凡なものです。そしてなんといってもこの間に OCaml言語は成熟し、Unison [<a href="#Unison">18</a>] のような実際のシステムアプリケーションに使われるようになりました。</p><p>伝統的に Unix システムプログラミングは C で行われなければならないという風潮があります。しかしこのコースで私達はより高レベルな言語 — 具体的には OCaml — のほうが Unix システムプログラミングの基礎を説明するのに適していることを発見しました。</p><p>OCamlの Unix システムコールに対するインターフェースはより抽象的です。C では全てが整数とビットフィールドに変換されますが、OCamlでは ML の型システムを使うことで、システムコールの引数と返り値が明確になります。そのため引数と返り値がどのようにデコード/エンコードされるかを説明する必要がなく、システムコールの意味を説明するのが簡単になります。 (例えば <a href="#wait">??</a> ページにある <code>wait</code> システムコールの説明を見てみてください。)</p><p>加えて OCamlは静的な型システムを持ち、基本型が明確なので、 C よりも安全にプログラムを書けます。熟練した C プログラマーはこの利点を必要のない贅沢であるとみなすかもしれませんが、このコースが対象とする熟練していないプログラマーにとっては重要なことです。</p><p>システムプログラミングに関するこのノートの二つ目の目標は、定理証明やコンパイラ、記号計算といったOCamlの一般的な応用とは異なる分野における OCamlの利用例を見せることです。OCamlの持つ強固な命令的カーネルに加えてパラメトリック多相や高階関数、例外といった C にない優れた機能のおかげで、このノートで行われた試みの結果は上々です。他にも関数型プログラミングと命令型プログラミングを互いに排他的にではなく組み合わせて使うことで、同じプログラムの中にオペレーティングシステムとの優れたインターフェースと複雑な記号計算を共存させることが可能なことをこのノートは示しています。</p><p>このノートは読者が OCamlと Unix のシェルコマンドを知っていることを仮定します。OCamlに関する疑問は OCaml System documentation [<a href="#OCaml">2</a>] を、 Unix についての疑問は Unix <span class="c003">man</span>ual のセクション 1 や [<a href="#KP">5</a>, <a href="#R1">6</a>] などの入門書を参考にしてください。</p><p>このノートは Unix システムのプログラミング上のインターフェースしか示すことしかせず、その実装や内部構造には触れません。<span class="c007">bsd</span> 4.3 の内部構造は [<a href="#BSD">8</a>] で、 System <span class="c007">v</span> の内部構造は [<a href="#Bach">9</a>] で説明されています。Tanenbaum の本 [<a href="#T1">13</a>, <a href="#T2">14</a>] はネットワークとオペレーティングシステムの構造に関する全体像が示されています。</p><p>このノートで説明される Unix インターフェースは <a href="http://caml.inria.fr/ocaml/"><span class="c003">http://caml.inria.fr/ocaml/</span></a> でフリーソフトウェアとして配布されている OCaml System の一部です。

</p>
<!--TOC chapter id="sec3" 基礎-->
<h1 class="chapter" id="sec3"> 1  基礎</h1><!--SEC END --><!--NAME generalities.html-->

<!--TOC section id="sec4" <span class="c003">Sys</span> モジュールと <span class="c003">Unix</span> モジュール-->
<h2 class="section" id="sec4">1.1  <span class="c003">Sys</span> モジュールと <span class="c003">Unix</span> モジュール</h2><!--SEC END --><p>OCamlからシステムにアクセスするときに使われる関数は <code>Sys</code> と <code>Unix</code> の二つのモジュールにまとめられています。一つ目の <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html"><span class="c003">Sys</span></a> モジュールは OCamlが実行される Unix およびその他のオペレーティングシステムで一般的な関数を含みます。二つ目の <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html"><span class="c003">Unix</span></a> モジュールは Unix に特有なものを全て含みます。</p><p>これ以降 <code>Sys</code> と <code>Unix</code> モジュールにある識別子はどちらのモジュールのものかを示すことなく使うことにします。つまり <code><span class="c001">open</span> Sys</code> および <code><span class="c001">open</span> Unix</code> を実行した状態であるということです。完全な例を示すときには、<code><span class="c001">open</span> Sys</code> と <code><span class="c001">open</span> Unix</code> を明示的に書くことにします。</p><p><code>Sys</code> および <code>Unix</code> モジュールは <code>Pervasives</code> モジュールに定義されている変数を上書きし、元の定義を隠してしまうことがあるので注意してください。例えば、 <code>Pervasives.stdin</code> と <code>Unix.stdin</code> は別物です。隠された定義にはプリフィックスをつけることでアクセスできます。</p><p>Unix ライブラリを使う OCamlのプログラムをコンパイルするには、次のようにします:
</p><div class="mylisting">ocamlc -o prog unix.cma mod1.ml mod2.ml mod3.ml</div><p>ここで <code>prog</code> というプログラムは <code>mod1</code>, <code>mod2</code> そして <code>mod3</code> という三つのモジュールから成ります。モジュールは別々にコンパイルすることもできます:
</p><div class="mylisting">ocamlc -c mod1.ml
ocamlc -c mod2.ml
ocamlc -c mod3.ml</div><p>この場合、次のようにしてリンクします:
</p><div class="mylisting">ocamlc -o prog unix.cma mod1.cmo mod2.cmo mod3.cmo</div><p>両方の例において、引数 <code>unix.cma</code> は OCamlで書かれた <code>Unix</code> ライブラリを表します。バイトコードコンパイラではなくネイティブコードコンパイラを使うには、 <code>ocamlc</code> を <code>ocamlopt</code> に、<code>unix.cma</code> を <code>unix.cmxa</code> に置き換えてください。</p><p>コンパイルツール <code>ocamlbuild</code> を使っている場合、次の内容を <code>_tags</code> ファイルに追加してください:
</p><div class="mylisting">&lt;prog.{native,byte}&gt; : use_unix</div><p>“toplevel” を言われる対話環境から Unix システムにアクセスすることもできます。実行している環境が C ライブラリの動的リンクに対応している場合、OCamlトップレベルを起動して次のディレクティブを入力します:
</p><div class="mylisting"><span class="c001">#</span>load <span class="c002">"unix.cma"</span>;;</div><p>動的リンクに対応していない場合、システム関数がプリロードされた対話環境を作る必要があります:
</p><div class="mylisting">ocamlmktop -o ocamlunix unix.cma</div><p>このトップレベルは次のコマンドで起動できます:
</p><div class="mylisting">./ocamlunix</div>
<!--TOC section id="sec5" プログラムを呼ぶためのインターフェース-->
<h2 class="section" id="sec5">1.2  プログラムを呼ぶためのインターフェース</h2><!--SEC END --><p>シェル (コマンドインタープリタ) からプログラムを実行する場合、シェルは <em>引数</em> と <em>環境</em> を実行するプログラムに渡します。引数とはコマンドライン上でプログラムの名前の後ろに続く語です。環境とは <span class="c003">variable=value</span> の形をした文字列の集まりであり、環境変数のバインディングを表します。このバインディングは csh では <span class="c003">setenv var=val</span> で、 <span class="c003">sh</span> では <span class="c003">var=val; export var</span>でセットされます。</p><p>プログラムに渡された引数は文字列の配列 <code>Sys.argv</code> に格納されます:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#VALargv">argv</a><a id="hevea_default0"></a> : string array</div><p>プログラムの環境は <code>Unix.environment</code> 関数で取得できます:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALenvironment">environment</a><a id="hevea_default1"></a> : unit -&gt; string array</div><p><code>Sys.getenv</code> 関数を使えば環境をより簡単に検索できます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#VALgetenv">getenv</a><a id="hevea_default2"></a> : string -&gt; string</div><p><code>Sys.getenv v</code> は <code>v</code> という環境変数に結び付けられた値を返します。環境変数が見つからなかった場合は <code>Not_found</code> 例外を出します。
</p><div class="example">
<!--TOC paragraph id="sec6" 例-->
<h5 class="paragraph" id="sec6">例</h5><!--SEC END --><p>
最初の例として、引数を出力する <code>echo</code> プログラムを示します。これは同じ名前の Unix コマンドと同じ動作です。
</p><div class="mylisting"><span class="c001">let</span> echo () =
  <span class="c001">let</span> len = Array.length Sys.argv <span class="c001">in
  if</span> len &gt; 1 <span class="c001">then
    begin</span>
      print_string Sys.argv.(1);
      <span class="c001">for</span> i = 2 <span class="c001">to</span> len - 1 <span class="c001">do</span>
        print_char ' ';
        print_string Sys.argv.(i);
      <span class="c001">done</span>;
      print_newline ();
    <span class="c001">end</span>;;
echo ();;</div><div class="fancybreak">* * *</div></div><p>プログラムは <code>exit</code> を呼ぶことで任意の場所で終了させることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALexit">exit</a><a id="hevea_default3"></a> : int -&gt; 'a</div><p>引数は呼び出し元のプログラムに送られる返り値です。問題のない場合には 0 を、エラーが起こった場合には0でない値を返すという慣習があります。プログラムの実行結果が条件として使われた場合、<code>sh</code> シェルは返り値 0 をブール値 “true” に、0 でない全ての返り値を “false” として解釈します。</p><p>プログラムが全ての式を実行し終わって終了する場合、そのプログラムは暗黙的に <code>exit 0</code> を呼びます。プログラムが補足されない例外によって途中で実行を終了する場合、そのプログラムは暗黙的に <code>exit 2</code> を呼びます。</p><p><code>exit</code> 関数は呼ばれたときに書き込み用にオープンされている全てのチャンネルのバッファをフラッシュします。<code>at_exit</code> 関数を使うと、プログラムが終了するときにこれ以外の動作をさせることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALat_exit">at_exit</a><a id="hevea_default4"></a> : (unit -&gt; unit) -&gt; unit</div><p>最後に登録された関数が最初に実行されます。<code>at_exit</code> 関数を使って登録された関数は登録を解除することができませんが、これが本質的な制限になることはありません。グローバル変数を使って実行を変えることができるからです。</p>
<!--TOC section id="sec7" エラー処理-->
<h2 class="section" id="sec7">1.3  エラー処理</h2><!--SEC END --><p>他に明示されていない限り、<code>Unix</code> モジュールの全ての関数はエラーが起きたときに <code>Unix_error</code> 例外を出します。

</p><div class="mylisting"><span class="c001">exception</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#EXCEPTIONUnix_error">Unix_error</a> <span class="c001">of</span> error * string * string</div><p><code>Unix_error</code> 例外の第二引数はエラーが起こったシステムコールの名前です。第三引数はエラーが起こったオブジェクトの名前を(可能な場合には)表します。例えば、ファイルの名前を引数として取るシステムコールの場合には、このファイルの名前が <code>Unix_error</code> の第三引数となります。最後に、第一引数はエラーの種類を表すエラーコードを表します。エラーコードは <code>error</code> というヴァリアント型に属しています。
</p><div class="mylisting"><span class="c001">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEerror">error</a> = E2BIG | EACCES | EAGAIN | ...  | EUNKNOWNERR <span class="c001">of</span> int</div><p>この型のコンストラクタには <span class="c007">posix</span> で定義されるエラーが同じ名前と意味ですべて含まれ、加えて <span class="c007">unix98</span>, <span class="c007">bsd</span> のエラーの一部が含まれます。その他の全てのエラーは <code>EUNKOWNERR</code> というコンストラクタになります。</p><p>例外が発生したとき、 <code><span class="c001">try</span></code> によって補足されないエラーはプログラムの一番上まで上がっていき、プログラムを実行の途中で終了させます。小さいアプリケーションでは予見できないエラーを致命的なものとみなすことは良い習慣です。しかしその場合、エラーを分かりやすく表示することが望ましいです。エラーを分かりやすく表示するために、 <code>Unix</code> モジュールには <code>handle_unix_error</code> 関数があります:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALhandle_unix_error">handle_unix_error</a><a id="hevea_default5"></a> : ('a -&gt; 'b) -&gt; 'a -&gt; 'b</div><p><code>handle_unix_error f x</code> はまず引数 <code>x</code> を関数 <code>f</code> に適用します。この適用が <code>Unix_error</code> を出した場合、エラーを説明するメッセージが表示され、<code>exit 2</code> によってプログラムは終了します。次のプログラムは典型的な使用例です:
</p><div class="mylisting">handle_unix_error prog ();;</div><p>ここで関数 <code>prog : unit -&gt; unit</code> がプログラム本体を実行します。参考のために、 <code>handle_unix_error</code> の実装を以下に示します。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Unix;;
<span class="c005">   2</span> <span class="c001">let</span> handle_unix_error f arg =
<span class="c005">   3</span>   <span class="c001">try</span>
<span class="c005">   4</span>     f arg
<span class="c005">   5</span>   <span class="c001">with</span> Unix_error(err, fun_name, arg) -&gt;
<span class="c005">   6</span>     prerr_string Sys.argv.(0); <a id="prog:argv"></a>
<span class="c005">   7</span>     prerr_string <span class="c002">": \""</span>;
<span class="c005">   8</span>     prerr_string fun_name;
<span class="c005">   9</span>     prerr_string <span class="c002">"\" failed"</span>;
<span class="c005">  10</span>     <span class="c001">if</span> String.length arg &gt; 0 <span class="c001">then begin</span>
<span class="c005">  11</span>       prerr_string <span class="c002">" on \""</span>;
<span class="c005">  12</span>       prerr_string arg;
<span class="c005">  13</span>       prerr_string <span class="c002">"\""</span>
<span class="c005">  14</span>     <span class="c001">end</span>;
<span class="c005">  15</span>     prerr_string <span class="c002">": "</span>;
<span class="c005">  16</span>     prerr_endline (error_message err); <a id="prog:errmsg"></a>
<span class="c005">  17</span>     exit 2;;</div><p><code>prerr_xxx</code> の形をした関数は基本的には <code>print_xxx</code> 関数と同じ動作をしますが、書き込み先は <code>stdout</code> ではなく <code>stderr</code> となります。</p><p><code>error -&gt; string</code> 型をもつ <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALerror_message"><span class="c003">error_message</span></a><a id="hevea_default6"></a> は引数の番号が表すエラーを説明するメッセージを返します (第 <a href="#prog%3Aerrmsg">16</a> 行)。プログラムに渡される第 0 引数 <code>Sys.argv.(0)</code> にはプログラムを起動するのに使われたコマンドが格納されます (第 <a href="#prog%3Aargv">6</a> 行)。</p><p><code>handle_unix_error</code> 関数がプログラムの実行を終了させるような致命的なエラーを処理します。OCamlを使うことの利点は全てのエラーを明示的に処理することが求められ、エラーが発生するとプログラムの実行が終了することになるトップレベルでさえこれが求められることです。実際システムコールによるどんなエラーも例外を発生させるので、プログラムの実行は中断され、例外は明示的に補足・処理されるまで上に登る事になります。これによってプログラムが不整合状態で実行が続くことを防ぐことができます。</p><p><code>Unix_error</code> 型のエラーにはもちろんパターンマッチを使うことができます。次の関数はこれからよく目にすることになります:
</p><div class="mylisting"><span class="c001">let rec</span> restart_on_EINTR f x =
  <span class="c001">try</span> f x <span class="c001">with</span> Unix_error (EINTR, _, _) -&gt; restart_on_EINTR f x</div><p>このコードは関数を実行してもし中断された場合にはもう一度繰り返すという処理を行います(<a href="#sec%2Fsigsyscalls">4.5</a> 節を参照)。</p>
<!--TOC section id="sec8" ライブラリ関数-->
<h2 class="section" id="sec8">1.4  ライブラリ関数</h2><!--SEC END --><p>これから例を通して見ていくことですが、システムプログラミングでは同じパターンの処理が繰り返し出てきます。アプリケーションのコードが本質的な部分だけを含むように、共通する処理をまとめたライブラリ関数を定義しておくことが望ましいです。</p><p>自分で書いて自分で実行するプログラムではどんなエラーが出て、そのうちどれが実行を終了させるような致命的なエラーかが分かるものですが、ライブラリ関数の場合には実行されるコンテキストが分からないのでどれが致命的なエラーなのかは通常分かりません。かといって全てのエラーが致命的であると仮定することもできません。そのためプログラムを止めるのか、それとも無視するのか呼び出し元に判断させるために、エラーを呼び出し元に伝えることが必要になります。</p><p>しかし、ライブラリ関数を普通に実装すると発生したエラーをそのまま呼び出し元に伝えることができません。システムを整合状態に置くことが求められるためです。例えばファイルを開いてそのファイルディスクリプタを使って操作を行うライブラリ関数は、ファイルへの操作でエラーが生じた場合を含めた全ての場合においてファイルディスクリプタを閉じる処理を行う必要があります。ファイルディスクリプタがリークしてファイルディスクリプタを使いきってしまうことを防ぐためです。</p><p>ファイルに対する操作を引数として受け取る場合もあります。この場合、いつどのように操作が失敗するかを知ることは (呼び出した側でなければ) できません。そのため操作の本体は “最終処理” コードで守ることが必要になります。このコードは関数が例外を出したかどうかにかかわらず、関数が帰る直前に実行されます。</p><p><code><span class="c001">try</span></code> …<code>finalize</code> 構文は OCamlにビルトインでは用意されていませんが、簡単に定義することができます <sup><a id="text1" href="#note1">1</a></sup>。
</p><div class="mylisting"><span class="c001">let</span> try_finalize f x finally y =
  <span class="c001">let</span> res = <span class="c001">try</span> f x <span class="c001">with</span> exn -&gt; finally y; raise exn <span class="c001">in</span>
  finally y;
  res</div><p>この関数はメインの処理 <code>f</code> と最終処理 <code>finally</code> およびそれらの引数 <code>x</code> と <code>y</code> を受け取ります。最初にプログラムの本体 <code>f x</code> が実行され、その結果は最終処理 <code>finally y</code> が実行されてから返されます。プログラムの実行で例外 <code>exn</code> が起こった場合、最終処理が実行されてからもう一度 <code>exn</code> を出します。メインの処理と最終処理の両方が失敗した場合、最終処理の例外が出されます(メインの処理の例外が出されるようにすることもできます)。</p>
<!--TOC paragraph id="sec9" ノート-->
<h5 class="paragraph" id="sec9">ノート</h5><!--SEC END --><p>これからこのコースでは例でよく使う <code>try_finalize</code> などの関数をまとめた補助ライブラリ <code>Misc</code> を使います。必要に応じてライブラリの関数を紹介するほか、インターフェースは付録にあります。このコースに出てくる例をコンパイルするには、 <code>Misc</code> モジュールの定義をまとめておく必要があります。</p><p><code>Misc</code> モジュールにはこのコースでは直接使用しない可視化のための関数も含まれています。これらの関数は <code>Unix</code> ライブラリを強化するためのもので、いくつかの関数の振る舞いを上書きします。そのため <code>Misc</code> ライブラリを使う場合は <code>Unix</code> の後に読み込まれる必要があります。</p>
<!--TOC paragraph id="sec10" 例-->
<h5 class="paragraph" id="sec10">例</h5><!--SEC END --><p>このコースにはたくさんの例が含まれています。これらはバージョン <span class="c003">4.05.0</span>の OCamlでコンパイルされることを確認しています。古いバージョンではプログラムを若干改変する必要があります。</p><p>例には二つの種類があります: とても一般的で再利用が可能な “ライブラリ関数” と小さなアプリケーションです。これら二つを区別することは重要です。ライブラリ関数の場合には実行時のコンテキストをできるだけ一般的なものと仮定して、インターフェースを熟慮し、全ての特殊ケースを扱うようにします。一方小さなアプリケーションの場合には、多くのエラーは致命的なものであり、プログラムの実行を停止させます。そのためエラーが起きた時にはその原因を伝えるだけで十分であり、システムを整合状態へと戻す処理は必要ありません。

</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">構文がビルトインで用意されれば関数を定義して使うよりも便利でしょう。</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec/files" ファイル-->
<h1 class="chapter" id="sec/files"> 2  ファイル</h1><!--SEC END --><!--NAME files.html-->
<p>Unix において “ファイル” という言葉はいくつかのものを表します:
</p><ul class="itemize"><li class="li-itemize">
通常のファイル: テキストまたはバイナリ情報を含んだ有限のバイト列。 “通常ファイル” とも呼ばれる。
</li><li class="li-itemize">ディレクトリ
</li><li class="li-itemize">シンボリックリンク
</li><li class="li-itemize">特殊ファイル (<em>デバイス</em>): 主にコンピュータの周辺機器にアクセスするために使われる。
</li><li class="li-itemize">名前付きパイプ
</li><li class="li-itemize">名前付き Unix ドメインソケット
</li></ul><p>
ファイルという表現にはファイルが保持するデータだけではなく、その種類やアクセス権限、最終更新日時といったファイルそのものに関するデータ (メタ属性と呼ばれます) も含まれます。</p>
<!--TOC section id="sec12" ファイルシステム-->
<h2 class="section" id="sec12">2.1  ファイルシステム</h2><!--SEC END --><p>大ざっぱにいって、ファイルシステムは木と考えることができます。根 (ルート)は <code>/</code> で表され、枝は <code>'\000'</code> と <code>/</code> を除く文字列からなるファイルの名前でラベル付けされます (ただし空白文字と印字できない文字は避けたほうが良いとされます) 。終端でないノードは <em>ディレクトリ</em> です: これらのノードは必ず二つの枝 <code>.</code> と <code>..</code> を含み、それぞれこのディレクトリそのものと親のディレクトリを表します。ディレクトリでないノードのことを <em>ファイル</em> と呼ぶことがありますが、木のどのノードもファイルであることを考えると、これは曖昧です。曖昧さを避けるために、このノートではこれらのことを <em>非ディレクトリファイル</em> と呼ぶことにします。</p><p>木のノードはパスを使って表すことができます。パスの始点がファイル階層の頂上である場合、そのパスは <em>絶対</em> です。一方始点がディレクトリである場合にはパスは <em>相対</em> です。より正確に言うと、 <em>相対パス</em> とはファイルの名前を <code>/</code> で区切った文字列であり、<em>絶対パス</em> とは先頭に <code>/</code> のついた相対パスです。ここでは同じ文字 <code>/</code> が区切り文字と根ノードという二つの意味で使われています。</p><p><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html"><span class="c003">Filename</span></a> モジュールを使うとパスをポータブルに扱うことができます。例えば <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALconcat"><span class="c003">concat</span></a> は <code>/</code> という文字を与えることなく二つのパスを結合するので、他のオペレーティングシステム (windows では区切り文字は <code>\</code> です) でも同じような動作をさせることができます。<code>Filename</code> モジュールには <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALcurrent_dir_name"><span class="c003">current_dir_name</span></a> と<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALparent_dir_name"><span class="c003">parent_dir_name</span></a> があり、それぞれ <code>.</code> と <code>..</code> という枝を表します。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALbasename"><span class="c003">basename</span></a> 関数と <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALdirname"><span class="c003">dirname</span></a> 関数はパス <code>p</code> を受け取ってそれぞれディレクトリ名 <code>d</code> と非ディレクトリファイル名 <code>b</code>を返します。このとき <code>p</code> と <code>d/p</code> が表すファイルは同じになります。<code>Filename</code> モジュールの関数はパスの操作だけを行うので、実際にそのパスが存在するかどうかは考慮しません。</p><p>ファイル階層は厳密には木ではありません。<code>.</code> と <code>..</code> というディレクトリが自分自身や上の階層のディレクトリを指しているからです。さらに、非ディレクトリファイルは複数の親を持つことができます (<em>ハードリンク</em> と言います)。また他のファイルへのパスを保持する非ディレクトリファイルとみなすことができる <em>シンボリックリンク</em> もあります。概念上は、シンボリックリンクの保持するパスは通常ファイルと同じようにその内容を読むことで取得できます。パスの途中でシンボリックリンクに当たった場合、そのたびにパスをたどります。<code>s</code> が <code>l</code> へのシンボリックリンクならば、 <code>p/s/q</code> というパスは <code>l</code> が絶対パスのときは <code>l/q</code> を、相対パスのときは <code>p/l/q</code> を表します。</p><p>図 <a href="#fig%2Fhierarchy">1</a> にファイル階層の例を示します。<code>/tmp/bar</code> というパスにあるシンボリックリンク <code>11</code> は <code>../gnu</code> という相対パスを指していますが、このファイルはこの段階では存在していません。</p><div class="figure">
<div class="image"><img src="ocamlunix-image1.png" width="100%"></div>



<a id="fig/hierarchy"></a>
<div class="caption">Figure 1 — ファイル階層の例</div></div><p>一般的に、次の規則に従えばファイル階層の再帰的な探索は終了します:
</p><ul class="itemize"><li class="li-itemize">
ディレクトリ <code>.</code> と <code>..</code> を無視する。
</li><li class="li-itemize">シンボリックリンクをたどらない。
</li></ul><p>
シンボリックリンクをたどる場合には木ではなく一般のグラフを走査することになるので、たどったノードを覚えておかないとループを避けることができません。</p><p>それぞれのプロセスはワーキングディレクトリを持ちます。ワーキングディレクトリは <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetcwd"><span class="c003">getcwd</span></a><a id="hevea_default7"></a> 関数で取得することができ、<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchdir"><span class="c003">chdir</span></a><a id="hevea_default8"></a> で変えることができます。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchroot"><span class="c003">chroot</span></a><a id="hevea_default9"></a> <code>p</code> を使えばファイル階層のビューを制限することができます。これによってディレクトリ <code>p</code> が制限されたビューのルートになります。それ以降は絶対パスが新しいルート <code>p</code> からのものとして解釈されます (新しいルートからの <code>..</code> は <code>p</code> 自身になります)。</p>
<!--TOC section id="sec13" ファイル名とファイルディスクリプタ-->
<h2 class="section" id="sec13">2.2  ファイル名とファイルディスクリプタ</h2><!--SEC END --><p>ファイルにアクセスする方法は二つあります。一つ目はファイルシステム階層の <em>ファイル名</em> (あるいは <em>パス名</em>) を利用する方法です。ハードリンクがあるので、全てのファイルは複数のファイル名を持つことができます。ファイル名は <code>string</code> 型の値です。例えばシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/unlink.html"><span class="c003">unlink</span></a><a id="hevea_default10"></a>, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/link.html"><span class="c003">link</span></a><a id="hevea_default11"></a>, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/symlink.html"><span class="c003">symlink</span></a><a id="hevea_default12"></a> そして <a href="http://www.opengroup.org/onlinepubs/009696799/functions/rename.html"><span class="c003">rename</span></a><a id="hevea_default13"></a> はどれもファイル名を使います。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALunlink">unlink</a> : string -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlink">link</a> : string -&gt; string -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsymlink">symlink</a> : string -&gt; string -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrename">rename</a> : string -&gt; string -&gt; unit</div><p>以下のような効果を持ちます:
</p><ul class="itemize"><li class="li-itemize">
<code>unlink f</code> はファイル <code>f</code> を削除する。 Unix コマンド <code>rm -f f</code> と同じ。
</li><li class="li-itemize"><code>link f1 f2</code> は <code>f2</code> という名前で <code>f1</code> というファイルを指すハードリンクを作成する。Unix コマンド <code>ln f1 f2</code> と同じ。
</li><li class="li-itemize"><code>symlink f1 f2</code> は <code>f2</code> という名前で <code>f1</code> というファイルを指すシンボリックリンクを作成する。Unix コマンド <code>ln -s f1 f2</code> と同じ。
</li><li class="li-itemize"><code>rename f1 f2</code> はファイル <code>f1</code> をファイル <code>f2</code> にリネームする。Unix コマンド <code>mv f1 f2</code> と同じ。
</li></ul><p>ファイルにアクセスする二つ目の方法はファイルディスクリプタを使うものです。ファイルディスクリプタはファイルへのポインタであり、ファイルの名前の他にも現在の読み込み/書き込み位置、アクセス権限 (読み込み/書き込みは可能か?)、入出力を管理するためのフラグ (ブロッキング/ノンブロッキングや上書き/追記など)といった情報を含みます。ファイルディスクリプタは抽象型 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_descr"><span class="c003">file_descr</span></a> の値です。</p><p>ファイルへの名前を使ったアクセスはファイルディスクリプタを使ったアクセスと独立しています。例えばあるファイルのファイルディスクリプタを取得したとき、そのファイルを消去したりリネームしたりすることは可能ですが、そうした場合でもファイルディスクリプタは元のファイルを指したままです。</p><p>プログラムが実行されると 3 つのディスクリプタが確保され、<code>Unix</code> モジュールの<code>stdin</code>, <code>stdout</code>, <code>stderr</code> という変数に割り当てられます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstdin">stdin</a><a id="hevea_default14"></a> : file_descr
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstdout">stdout</a><a id="hevea_default15"></a> : file_descr
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstderr">stderr</a><a id="hevea_default16"></a> : file_descr</div><p>これらのディスクリプタはそれぞれプロセスの標準入力、標準出力、標準エラー出力に対応します。</p><p>プログラムがコマンドラインから実行されリダイレクトされることがない場合、三つのディスクリプタは端末を表します。しかし例えば入力がシェルの <code>cmd &lt; f</code> を使ってリダイレクトされている場合、<code>cmd</code> を実行している間はディスクリプタ <code>stdin</code> は <code>f</code> というファイルを指します。同様に、 <code>cmd &gt; f</code> と <code>cmd 2&gt; f</code> はコマンドの実行中にそれぞれ <code>stdout</code> と <code>stderr</code> をファイル <code>f</code> に割り当てます。</p>
<!--TOC section id="sec14" ファイルのメタ属性、種類、権限-->
<h2 class="section" id="sec14">2.3  ファイルのメタ属性、種類、権限</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/stat.html"><span class="c003">stat</span></a><a id="hevea_default17"></a>, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/lstat.html"><span class="c003">lstat</span></a><a id="hevea_default18"></a> および <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fstat.html"><span class="c003">fstat</span></a><a id="hevea_default19"></a> はファイルについてのメタ属性、つまりそのファイルの内容についてではなくそのノード自身についての情報を返します。例えばファイルの識別子、ファイルの種類、アクセス権限、最終更新日時といった情報などが含まれます

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstat">stat</a>  : string -&gt; stats
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlstat">lstat</a> : string -&gt; stats
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfstat">fstat</a> : file_descr -&gt; stats</div><p>システムコール <code>stat</code> と <code>lstat</code> はファイル名を引数として受け取りますが、<code>fstat</code> はそれまでに開かれたディスクリプタを受け取りそのディスクリプタが指しているファイルの情報を返します。<code>stat</code> と <code>lstat</code> はシンボリックリンクに対して異なった動作をします。<code>lstat</code> はシンボリックリンクそのものの情報を返しますが、<code>stat</code> はシンボリックリンクが指すファイルに関する情報を返します。これら 3 つのシステムコールの返り値は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEstats"><span class="c003">stats</span></a> 型のレコードです。そのフィールドは図 <a href="#fig%2Fstats">1</a> に説明されています。
</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c014">フィールド名</td><td class="c013">説明 </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td class="c014"><code>st_dev : int</code></td><td class="c013">ファイルが保存されているデバイスの ID を表す。 </td></tr>
<tr><td class="c014"><code>st_ino : int</code></td><td class="c013">パーティションにおけるファイルの ID (inode 番号と呼ばれます) を表す。<code>(st_dev, st_ino)</code> の組でファイルシステム内のファイルを識別できる。 </td></tr>
<tr><td class="c014"><code>st_kind : file_kind</code></td><td class="c013">ファイルの種類を表す。 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_kind"><span class="c003">file_kind</span></a> 型は列挙型であり、以下のコンストラクタを持つ:
<div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>S_REG</code></td><td class="c011">通常ファイル </td></tr>
<tr><td class="c011"><code>S_DIR</code></td><td class="c011">ディレクトリ </td></tr>
<tr><td class="c011"><code>S_CHR</code></td><td class="c011">キャラクタデバイス </td></tr>
<tr><td class="c011"><code>S_BLK</code></td><td class="c011">ブロックデバイス </td></tr>
<tr><td class="c011"><code>S_LNK</code></td><td class="c011">シンボリックリンク </td></tr>
<tr><td class="c011"><code>S_FIFO</code></td><td class="c011">名前付きパイプ </td></tr>
<tr><td class="c011"><code>S_SOCK</code></td><td class="c011">ソケット
</td></tr>
</table>
</div>
</td></tr>
<tr><td class="c014"><code>st_perm : int</code></td><td class="c013">ファイルへのアクセス権限を表す。 </td></tr>
<tr><td class="c014"><code>st_nlink : int</code></td><td class="c013">ファイルがディレクトリの場合はディレクトリ内の要素の数を表す。
ファイルがディレクトリ出ない場合、このファイルに対するハードリンクの数を表す。 </td></tr>
<tr><td class="c014"><code>st_uid : int</code></td><td class="c013">ファイルの所有ユーザを表す。 </td></tr>
<tr><td class="c014"><code>st_gid : int</code></td><td class="c013">ファイルの所有グループを表す。 </td></tr>
<tr><td class="c014"><code>st_rdev : int</code></td><td class="c013">ファイルが特殊ファイルの場合、ファイルに関連付けられた周辺機器の ID を表す。 </td></tr>
<tr><td class="c014"><code>st_size : int</code></td><td class="c013">ファイルのサイズ (バイト) を表す。 </td></tr>
<tr><td class="c014"><code>st_atime : int</code></td><td class="c013">ファイルが最後にアクセスされた時間を、 1970年1月1日深夜0時 <span class="c007">gmt</span> からの経過秒数で表す。</td></tr>
<tr><td class="c014"><code>st_mtime : int</code></td><td class="c013">ファイルが最後に更新された日時を表す (単位は同上)。</td></tr>
<tr><td class="c014"><code>st_ctime : int</code></td><td class="c013">ファイルの状態が最後に更新された日時を表す。ファイルへの書き込み、アクセス権限の変更、所有ユーザ/グループの変更、リンク数の変更などがファイルの状態を変化させる。
<br>
</td></tr>
<tr><td class="hbar" colspan=2></td></tr>
</table>

<a id="fig/stats"></a>
<div class="caption">Table 1 — <code>stats</code> 構造体のフィールド</div></div><!--TOC subsection id="sec15" 識別子-->
<h3 class="subsection" id="sec15">識別子</h3><!--SEC END --><p>ファイルはデバイス番号 <code>st_dev</code> (大抵の場合はファイルのあるディスクパーティションの番号) とinode 番号 <code>st_ino</code> で一意に識別できます。</p><!--TOC subsection id="sec16" 所有者-->
<h3 class="subsection" id="sec16">所有者</h3><!--SEC END --><p>ファイルは所有者 <code>st_uid</code> と所有グループ <code>st_gid</code> を持ちます。マシン上の全てのユーザとグループは通常 <code>/etc/passwd</code> と <code>/etc/gourps</code> に保存されています。ユーザとグループを文字列からポータブルに検索するには <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getpwnam.html"><span class="c003">getpwnam</span></a><a id="hevea_default20"></a> 関数と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgrnam.html"><span class="c003">getgrnam</span></a><a id="hevea_default21"></a> 関数が使えるほか、<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getpwuid.html"><span class="c003">getpwuid</span></a><a id="hevea_default22"></a> 関数と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgrgid.html"><span class="c003">getgrgid</span></a><a id="hevea_default23"></a> 関数を使うと id から検索できます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetpwnam">getpwnam</a> : string -&gt; passwd_entry
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgrnam">getgrnam</a> : string -&gt; group_entry
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetpwuid">getpwuid</a> : int -&gt; passwd_entry
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgrgid">getgrgid</a> : int -&gt; group_entry</div><p>プロセスを実行しているユーザの名前とそのユーザが属している全てのグループ番号はそれぞれ <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getlogin.html"><span class="c003">getlogin</span></a><a id="hevea_default24"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgroups.html"><span class="c003">getgroups</span></a><a id="hevea_default25"></a> 関数で取得できます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetlogin">getlogin</a> : unit -&gt; string
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgroups">getgroups</a> : unit -&gt; int array</div><p><a href="http://www.opengroup.org/onlinepubs/009696799/functions/chown.html"><span class="c003">chown</span></a><a id="hevea_default26"></a> 関数はファイル (第一引数) の所有者 (第二引数) と所有グループ (第三引数) を変えます。ファイルディスクリプタを持っているならば、 代わりに <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fchown.html"><span class="c003">fchown</span></a><a id="hevea_default27"></a> 関数が使えます。任意のファイルの所有者と所有グループを変更できる権限を持つのはスーパーユーザだけです。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchown">chown</a> : string -&gt; int -&gt; int -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfchown">fchown</a> : file_descr -&gt; int -&gt; int -&gt; unit</div><p>プログラムの実効 <code>uid</code> がファイルと等しいとき、あるいは実効 <code>gid</code> または実効ユーザの属する補助グループの一つがファイルの所有グループと等しい場合は、特権無しで所有ユーザ/グループの変更が可能です。</p><!--TOC subsection id="sec17" アクセス権限-->
<h3 class="subsection" id="sec17">アクセス権限</h3><!--SEC END --><p>アクセス権限は整数の中にビット列として格納されており、<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_perm"><span class="c003">file_perm</span></a> は <code>int</code> の別名に過ぎません。そこには所有ユーザ、所有グループおよびその他のユーザの読み込み、書き込みおよび実行のための権限を表すビットとスペシャルビットが保存されています:
</p><div class="center">
<table class="cellpadding1" border=1 style="border-spacing:0;"><tr><td class="c009" colspan=3><span class="c003">S</span>pecial</td><td class="c009" colspan=3><span class="c003">U</span>ser</td><td class="c009" colspan=3><span class="c003">G</span>roup</td><td class="c009" colspan=3><span class="c003">O</span>ther </td></tr>
<tr><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td><td class="c009">–</td></tr>
<tr><td class="c009" colspan=12><code>OoSUGO</code>
</td></tr>
</table>
</div><p>

ここでユーザ (User) 、グループ (Group)、その他 (Other) というフィールドの中には、読み込み (<code>r</code>)、 書き込み (<code>w</code>) そして実行 (<code>x</code>) の権限がこの順番で保存されています。ファイルの権限はこれらの権限を合わせたものであり、例を表 <a href="#tab%2Fpermbits">2</a> に示します。
</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c011">ビット (8進表記)</td><td class="c010"><code>ls -l</code> の表記</td><td class="c011">アクセス権限 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"><code>0o100</code></td><td class="c010"><code>--x------</code></td><td class="c011">所有ユーザによって実行可能 </td></tr>
<tr><td class="c011"><code>0o200</code></td><td class="c010"><code>-w-------</code></td><td class="c011">所有ユーザによって書き込み可能 </td></tr>
<tr><td class="c011"><code>0o400</code></td><td class="c010"><code>r--------</code></td><td class="c011">所有ユーザによって読み込み可能 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"><code>0o10</code></td><td class="c010"><code>-----x---</code></td><td class="c011"> 所有グループのメンバーによって実行可能 </td></tr>
<tr><td class="c011"><code>0o20</code></td><td class="c010"><code>----w----</code></td><td class="c011"> 所有グループのメンバーによって書き込み可能 </td></tr>
<tr><td class="c011"><code>0o40</code></td><td class="c010"><code>---r----</code></td><td class="c011"> 所有グループのメンバーによって読み込み可能 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"><code>0o1</code></td><td class="c010"><code>--------x</code></td><td class="c011">その他のユーザによって実行可能 </td></tr>
<tr><td class="c011"><code>0o2</code></td><td class="c010"><code>-------w-</code></td><td class="c011">その他のユーザによって書き込み可能 </td></tr>
<tr><td class="c011"><code>0o4</code></td><td class="c010"><code>------r--</code></td><td class="c011">その他のユーザによって読み込み可能 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"><code>0o1000</code></td><td class="c010"><code>--------t</code></td><td class="c011">グループに対する <code>t</code> ビット (スティッキービット) </td></tr>
<tr><td class="c011"><code>0o2000</code></td><td class="c010"><code>-----s---</code></td><td class="c011">グループに対する <code>s</code> ビット (SGID) </td></tr>
<tr><td class="c011"><code>0o4000</code></td><td class="c010"><code>--s------</code></td><td class="c011">ユーザに対する <code>s</code> ビット (SUID) </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
<a id="tab/permbits"></a>
<div class="caption">Table 2 — 権限ビット</div></div><p>非ディレクトリファイルに対して、読み込み、書き込みおよび実行の権限が意味することは明らかです。ディレクトリに対する実行権限とはそのディレクトリに入る (<code>chdir</code> する) ための権限であり、読み込み権限とはディレクトリの内容を一覧で表示するための権限です。ただしディレクトリ内のファイルやサブディレクトリの名前を知っている場合、それらを読み込むためにはディレクトリの読み込み権限は必要ではありません。</p><p>スペシャルビットは <code>x</code> ビットが立っていない場合には意味を持ちません (<code>x</code> が 立っていないならば、追加の権限を与えません) 。スペシャルビットの場所が <code>x</code> と同じで、<code>x</code> が設定されていないときには <code>s</code>, <code>t</code> の代わりに <code>S</code>, <code>T</code> が使われるのはこのためです。</p><p><code>t</code> フラグはスティッキービットと呼ばれ、このフラグが付いたディレクトリでは全てのユーザがファイルとディレクトリの作成を行えますが、削除が行えるのは所有者とルートだけです。</p><p><code>s</code> ビットが立っている実行可能ファイルを実行すると、ファイルの所有者または所有グループとしてファイルが実行されます。さらにプログラムの実行時にシステムコール <code>setuid</code> と <code>setgid</code> を呼ぶことで、実効ユーザ識別子とグループを本来のユーザ/グループに切り変えることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetuid">setuid</a> : int -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetgid">setgid</a> : int -&gt; unit</div><p><code>setuid</code> と <code>setgid</code> が呼ばれたとき、プロセスは元のユーザ/グループ識別子を保存します。元の識別子が保存されるのは実効識別子を特別な権限なしに後で戻すことができるようにするためです。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getuid.html"><span class="c003">getuid</span></a><a id="hevea_default28"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgid.html"><span class="c003">getgid</span></a><a id="hevea_default29"></a> は元の識別子を返し、<a href="http://www.opengroup.org/onlinepubs/009696799/functions/geteuid.html"><span class="c003">geteuid</span></a><a id="hevea_default30"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getegid.html"><span class="c003">getegid</span></a><a id="hevea_default31"></a> は実効識別子を返します。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetuid">getuid</a> : unit -&gt; int
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgeteuid">geteuid</a> : unit -&gt; int
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgid">getgid</a> : unit -&gt; int
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetegid">getegid</a> : unit -&gt; int</div><p>ただしスーパーユーザが <code>setuid</code> と <code>setgid</code> を実行した場合は別で、この場合は実効ユーザ/グループ識別子と実ユーザ/グループ識別子の両方を変更します。</p><p>プロセスは他にもファイル作成マスクを持ちます。これはファイル権限と同じようにエンコードされ、名前が示すように、禁止する操作を表します。ファイルを作成するとき、ファイル作成マスクで1になっているビットは作成されるファイルの権限では 0 になります。ファイル作成マスクはシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/umask.html"><span class="c003">umask</span></a><a id="hevea_default32"></a> で取得および変更できます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALumask">umask</a> : int -&gt; int</div><p>システム変数を変更する多くのシステムコールと同じように、ファイル作成マスクを変更する <a href="http://www.opengroup.org/onlinepubs/009696799/functions/umask.html"><span class="c003">umask</span></a><a id="hevea_default33"></a> は古い値を返します。そのため、この関数を二回呼べば現在の値を確認できます。一回目は適当な値を入力して変数の現在の値を手に入れ、二回目でその値を入力して変数を元の値に戻します。例えば:

</p><div class="mylisting"><span class="c001">let</span> m = umask 0 <span class="c001">in</span> ignore (umask m); m</div><p>ファイルアクセス権限はシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/chmod.html"><span class="c003">chmod</span></a><a id="hevea_default34"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fchmod.html"><span class="c003">fchmod</span></a><a id="hevea_default35"></a> で変更できます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchmod">chmod</a> : string -&gt; file_perm -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfchmod">fchmod</a> : file_descr -&gt; file_perm -&gt; unit</div><p>これらの関数が動作していることはシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/access.html"><span class="c003">access</span></a><a id="hevea_default36"></a> によって “動的に” 確認できます。
</p><div class="mylisting"><span class="c001">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEaccess_permission">access_permission</a> = R_OK | W_OK | X_OK | F_OK
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALaccess">access</a> : string -&gt; access_permission list -&gt; unit</div><p>ここでアクセスされるファイルへの権限の問い合わせは <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEaccess_permission"><span class="c003">access_permission</span></a> 型の値のリストで表されます。 <code>F_OK</code> はファイルが存在しているかどうかを (他の権限を確認せずに) 確認します。他の値の意味は明らかです。</p><p><code>access</code> によって調べられる情報は <code>lstat</code> で得られる情報よりも制限的なことがあることに注意してください。これはファイルシステムが制限された権限 — 例えば、読み込み専用モード — のもとにマウントされる場合があるためです。<em>動的な</em> 情報 (プロセスが実際にできることへの制限) と <em>静的な</em> 情報 (ファイルシステムが指定する制限) を区別したのはこのためです。</p>
<!--TOC section id="sec18" ディレクトリに対する操作-->
<h2 class="section" id="sec18">2.4  ディレクトリに対する操作</h2><!--SEC END --><p>ディレクトリに書き込めるのカーネルだけ (そしてファイルを作成するときだけ) です。そのため、ディレクトリを書き込みモードで開くことは禁止されています。 Unix の特定のバージョンでは、読み込み専用モードでディレクトリを開いて <span class="c003">read</span><a id="hevea_default37"></a>で読むことが許されていますが、別のバージョンでは禁止されています。しかしディレクトリエントリのフォーマットは Unix のバージョンによって異なり、複雑なことが多いので、仮にディレクトリへの書き込みができたとしても行うべきではありません。次の関数を使うとポータブルにディレクトリを走査することができます:

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopendir">opendir</a>   : string -&gt; dir_handle
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALreaddir">readdir</a>   : dir_handle -&gt; string
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrewinddir">rewinddir</a> : dir_handle -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclosedir">closedir</a>  : dir_handle -&gt; unit</div><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/opendir.html"><span class="c003">opendir</span></a><a id="hevea_default38"></a> はディレクトリのディレクトリディスクリプタを返します。 <a href="http://www.opengroup.org/onlinepubs/009696799/functions/readdir.html"><span class="c003">readdir</span></a><a id="hevea_default39"></a> はディスクリプタの次のエントリを読んで同じディレクトリ内のファイルの名前を返すか、ディレクトリの終端に到達した場合には <code>End_of_file</code> 例外を出します。<a href="http://www.opengroup.org/onlinepubs/009696799/functions/rewinddir.html"><span class="c003">rewinddir</span></a><a id="hevea_default40"></a> はディスクリプタをディレクトリの最初に移動し、<a href="http://www.opengroup.org/onlinepubs/009696799/functions/closedir.html"><span class="c003">closedir</span></a><a id="hevea_default41"></a> はディレクトリディスクリプタを閉じます。
</p><div class="example">
<!--TOC paragraph id="sec19" 例-->
<h5 class="paragraph" id="sec19">例</h5><!--SEC END --><p>
<code>Misc</code> モジュールに含まれる次のライブラリ関数はディレクトリ <code>dirname</code> 内のエントリーについて、関数 <code>f</code> を繰り返し適用します。


</p><div class="mylisting"><span class="c001">let</span> iter_dir f dirname =
  <span class="c001">let</span> d = opendir dirname <span class="c001">in
  try while true do</span> f (readdir d) <span class="c001">done
  with</span> End_of_file -&gt; closedir d</div><div class="fancybreak">* * *</div></div><p>ディレクトリの作成と空ディレクトリの削除には <a href="http://www.opengroup.org/onlinepubs/009696799/functions/mkdir.html"><span class="c003">mkdir</span></a><a id="hevea_default42"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/rmdir.html"><span class="c003">rmdir</span></a><a id="hevea_default43"></a> を使います。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmkdir">mkdir</a> : string -&gt; file_perm -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrmdir">rmdir</a> : string -&gt; unit</div><p><code>mkdir</code> の第二引数には新しく作られるディレクトリのアクセス権限を指定します。すでに空であるディレクトリしか削除することはできません。そのためディレクトリとその要素を削除するにはまず再帰的にディレクリの要素を削除してからディレクトリを削除することが必要になります。</p>
<!--TOC section id="ex/find" 完全な例: ファイル階層の検索-->
<h2 class="section" id="ex/find">2.5  完全な例: ファイル階層の検索</h2><!--SEC END --><p>Unix コマンド <code>find</code> はファイル階層にあるファイルで一定の条件 (ファイル名、タイプ、権限など) に合致するものを一覧で表示します。このセクションではこの探索を実装したライブラリ関数 <code>Findlib.find</code> と、<code>-follow</code> そして <code>-maxdepth</code> オプションに対応した <code>find</code> コマンドを作成します。</p><p><code>Findlib.find</code> に対するインターフェースを以下のように定めます:
</p><div class="mylisting"><span class="c001">val</span> find :
  (Unix.error * string * string -&gt; unit) -&gt;
  (string -&gt; Unix.stats -&gt; bool) -&gt; bool -&gt; int -&gt; string list -&gt;
  unit</div><p>関数呼び出し
</p><div class="mylisting">find handler action follow depth roots</div><p>はリスト <code>roots</code> で指定されるファイル (絶対パスまたは関数が呼ばれたときのプロセスのカレントディレクトリからの相対パス) をルートとするファイル階層を最大 <code>depth</code> の深さまで、 フラグ <code>follow</code> がセットされているならばシンボリックリンクをたどって探索します。 探索を開始したパスを <code>r</code> とすると、探索結果のパスは <code>r</code> を先頭に持ちます。探索で見つかったパス <code>p</code> は <code>Unix.lstat p</code> (<code>follow</code> が <code><span class="c001">true</span></code> の場合は <code>Unix.stat p</code>) の結果とともに <code>action</code> 関数に渡されます。ディレクトリに対しては、<code>action</code> 関数は探索をそのディレクトリの探索を続けるべきか (<code><span class="c001">true</span></code>) かやめるべきか (<code><span class="c001">false</span></code>) を返します。</p><p><code>handler</code> 関数は探索中に起こった <code>Unix_error</code> 型のエラーを報告します。エラーが起こった場合は、例外の引数が <code>handler</code> 関数に渡され探索は続行されます。例外が <code>action</code> 関数または <code>handler</code> 関数の内部で起こった場合にはその時点で探索は終了し、例外は呼び出し側に伝わります。<code>action</code> と <code>handler</code> の中で出される <code>Unix_error</code> 例外を探索中に起こったエラーと区別するために、<code>Hidden</code> 例外でラップします (<code>hide_exn</code> と <code>reveal_exn</code> 参照)。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Unix;;
<span class="c005">   2</span> 
<span class="c005">   3</span> <span class="c001">exception</span> Hidden <span class="c001">of</span> exn
<span class="c005">   4</span> <span class="c001">let</span> hide_exn f x = <span class="c001">try</span> f x <span class="c001">with</span> exn -&gt; raise (Hidden exn);;
<span class="c005">   5</span> <span class="c001">let</span> reveal_exn f x = <span class="c001">try</span> f x <span class="c001">with</span> Hidden exn -&gt; raise exn;;
<span class="c005">   6</span> 
<span class="c005">   7</span> <span class="c001">let</span> find on_error on_path follow depth roots =
<span class="c005">   8</span>   <span class="c001">let rec</span> find_rec depth visiting filename =
<span class="c005">   9</span>     <span class="c001">try</span>
<span class="c005">  10</span>       <span class="c001">let</span> infos = (<span class="c001">if</span> follow <span class="c001">then</span> stat <span class="c001">else</span> lstat) filename <span class="c001">in</span>
<span class="c005">  11</span>       <span class="c001">let</span> continue = hide_exn (on_path filename) infos <span class="c001">in</span>
<span class="c005">  12</span>       <span class="c001">let</span> id = infos.st_dev, infos.st_ino <span class="c001">in</span> <a id="prog:did"></a>
<span class="c005">  13</span>       <span class="c001">if</span> infos.st_kind = S_DIR &amp;&amp; depth &gt; 0 &amp;&amp; continue &amp;&amp;
<span class="c005">  14</span>         (not follow || not (List.mem id visiting))
<span class="c005">  15</span>       <span class="c001">then</span>
<span class="c005">  16</span>         <span class="c001">let</span> process_child child =
<span class="c005">  17</span>           <span class="c001">if</span> (child &lt;&gt; Filename.current_dir_name &amp;&amp;
<span class="c005">  18</span>               child &lt;&gt; Filename.parent_dir_name) <span class="c001">then</span>
<span class="c005">  19</span>             <span class="c001">let</span> child_name = Filename.concat filename child <span class="c001">in</span>
<span class="c005">  20</span>             <span class="c001">let</span> visiting =
<span class="c005">  21</span>               <span class="c001">if</span> follow <span class="c001">then</span> id :: visiting <span class="c001">else</span> visiting <span class="c001">in</span> <a id="prog:follow"></a>
<span class="c005">  22</span>             find_rec (depth-1) visiting child_name <span class="c001">in</span>
<span class="c005">  23</span>         Misc.iter_dir process_child filename
<span class="c005">  24</span>     <span class="c001">with</span> Unix_error (e, b, c) -&gt; hide_exn on_error (e, b, c) <span class="c001">in</span>
<span class="c005">  25</span>   reveal_exn (List.iter (find_rec depth [])) roots;;</div><p>ディレクトリはデバイス番号と inode 番号の組 <code>id</code> によって識別されます ( <a href="#prog%3Adid">12</a> 行目)。リスト <code>visiting</code> がそれまでに訪問したディレクトリを記録します。この情報が必要になるのはシンボリックリンクをたどる時だけです ( <a href="#prog%3Afollow">21</a> 行目)。</p><p>ここまでくれば、 <code>find</code> コマンドを作るのは簡単です。このコードの主な処理は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html"><span class="c003">Arg</span></a> モジュールを使ってコマンドライン引数をパースすることです。
</p><div class="mylisting"><span class="c001">let</span> find () =
  <span class="c001">let</span> follow = <span class="c001">ref false in
  let</span> maxdepth = <span class="c001">ref</span> max_int <span class="c001">in
  let</span> roots = <span class="c001">ref</span> [] <span class="c001">in
  let</span> usage_string  =
    (<span class="c002">"Usage: "</span> ^ Sys.argv.(0) ^ <span class="c002">" [files...] [options...]"</span>) <span class="c001">in
  let</span> opt_list =  [
    <span class="c002">"-maxdepth"</span>, Arg.Int ((:=) maxdepth), <span class="c002">"max depth search"</span>;
    <span class="c002">"-follow"</span>, Arg.Set follow, <span class="c002">"follow symbolic links"</span>;
  ] <span class="c001">in</span>
  Arg.parse opt_list (<span class="c001">fun</span> f -&gt; roots := f :: !roots) usage_string;
  <span class="c001">let</span> action p infos = print_endline p; <span class="c001">true in
  let</span> errors = <span class="c001">ref false in
  let</span> on_error (e, b, c) =
    errors := <span class="c001">true</span>; prerr_endline (c ^ <span class="c002">": "</span> ^ Unix.error_message e) <span class="c001">in</span>
  Findlib.find on_error action !follow !maxdepth
    (<span class="c001">if</span> !roots = [] <span class="c001">then</span> [ Filename.current_dir_name ]
     <span class="c001">else</span> List.rev !roots);
  <span class="c001">if</span> !errors <span class="c001">then</span> exit 1;;

Unix.handle_unix_error find ();;</div><p>
この <code>find</code> の機能は少ないですが、これからの練習問題で示されるように、ライブラリ関数 <code>FindLib.find</code> ははるかに多機能です。</p><div class="exercise">
<!--TOC paragraph id="sec21" 練習問題 1-->
<h5 class="paragraph" id="sec21">練習問題 1</h5><!--SEC END --><p><a id="ex1"></a>
<code>Findlib.find</code> を使って、以下の Unix コマンドと同じコマンド <code>find_out_CVS</code> を書いてください。
</p><div class="mylisting">find . -<span class="c001">type</span> d -name CVS -prune -o -print</div><p>このコマンドはカレントディレクトリから始まりファイルの名前を再帰的に表示しますが、<code>CVS</code> という名前のディレクトリについては表示することもディレクトリに入ることもしません。
<a href="#exans1">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 1</arg>-->
<!--NAME exercise1.html-->
<div class="answer">
<!--TOC paragraph id="sec22" 練習問題 exercise 1 の解答-->
<h5 class="paragraph" id="sec22">練習問題 <a href="#ex1">exercise 1</a> の解答</h5><!--SEC END --><p>
<a id="exans1"></a>

</p><div class="mylisting"><span class="c001">let</span> main () =
  <span class="c001">let</span> action p infos =
    <span class="c001">let</span> b = not (infos.st_kind = S_DIR || Filename.basename p = <span class="c002">"CVS"</span>) <span class="c001">in
    if</span> b <span class="c001">then</span> print_endline p; b <span class="c001">in
  let</span> errors = <span class="c001">ref false in
  let</span> error (e,c,b) =
    errors:= <span class="c001">true</span>; prerr_endline (b ^ <span class="c002">": "</span> ^ error_message e) <span class="c001">in</span>
  Findlib.find error action <span class="c001">false</span> max_int [ <span class="c002">"."</span> ];;
handle_unix_error main ()</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id="sec23" 練習問題 2-->
<h5 class="paragraph" id="sec23">練習問題 2</h5><!--SEC END --><p><a id="ex2"></a>
<code>getcwd</code> 関数はシステムコールではありませんが、 <code>Unix</code> モジュールで定義されています。<code>getcwd</code> の “原始的な” 実装を与えてください。まずアルゴリズムの原理を言葉で説明してから実装するようにしてください (同じシステムコールを何度も呼ぶのは避けたほうが良いでしょう)。
<a href="#exans2">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 2</arg>-->
<!--NAME exercise2.html-->
<div class="answer">
<!--TOC paragraph id="sec24" 練習問題 exercise 2 の解答-->
<h5 class="paragraph" id="sec24">練習問題 <a href="#ex2">exercise 2</a> の解答</h5><!--SEC END --><p>
<a id="exans2"></a>
ヒントを示します。現在の場所からルートに向かって登って行くことで、答えとなるパスを作ることができます。ルートは親がそれ自身と等しい唯一のディレクトリノードとして検出できます(ルートからの相対パス <code>.</code> と <code>..</code> は等しいです)。ディレクトリ <code>r</code> の名前を見つけるには、親ディレクトリの要素を一覧で表示し <code>r</code> に対応するものを見つければよいです。
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec25" ファイルのオープン-->
<h2 class="section" id="sec25">2.6  ファイルのオープン</h2><!--SEC END --><p><code>openfile</code> 関数を使うと指定した名前のファイルに対するディスクリプタを得ることができます (対応するシステムコールは <code><span class="c001">open</span></code> ですが、これは <code>ocaml</code> の予約語なので使うことができません) 。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopenfile">openfile</a> :
 string -&gt; open_flag list -&gt; file_perm -&gt; file_descr</div><p>第一引数は開くファイルの名前です。第二引数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEopen_flag"><span class="c003">open_flag</span></a> 列挙型のフラグのリストであり、ファイルが開かれるモードおよびファイルが存在しなかったときの動作を指定します。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_perm"><span class="c003">file_perm</span></a> 型の第三引数はファイルが作られるときのファイルのアクセス権限を指定します。返り値はファイルへのディスクリプタであり、入出力位置は最初ファイルの先頭にあります。</p><p>第二引数のフラグのリストは以下のうちちょうど一つだけを含む必要があります。
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>O_RDONLY</code></td><td class="c011">読み込み専用モードで開く。 </td></tr>
<tr><td class="c011"><code>O_WRONLY</code></td><td class="c011">書き込み専用モードで開く。 </td></tr>
<tr><td class="c011"><code>O_RDWR</code></td><td class="c011">読み込み/書き込みモードで開く。
</td></tr>
</table>
</div><p>
これらのフラグは読み込みと書き込み命令がディスクリプタに対して行えるかどうかを指定します。読み込み/書き込み権限のないファイルを読み込み/書き込みモードで開こうとした場合、<code>openfile</code> は失敗します。このため、全てのファイルを <code>O_RDWR</code> を使って開こうとするのは避けるべきです。</p><p><code>openfile</code> の第二引数のフラグには以下の値を一つ以上含むことができます。
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>O_APPEND</code></td><td class="c011">追記モードで開く。 </td></tr>
<tr><td class="c011"><code>O_CREAT</code></td><td class="c011">ファイルが存在しない場合作成する。 </td></tr>
<tr><td class="c011"><code>O_TRUNC</code></td><td class="c011">ファイルが存在する場合、内容を切り捨てる。 </td></tr>
<tr><td class="c011"><code>O_EXCL</code></td><td class="c011">ファイルがすでに存在しているなら失敗する。
</td></tr>
</table>
</div><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>O_NONBLOCK</code></td><td class="c011">ノンブロッキングモードで開く。 </td></tr>
<tr><td class="c011"><code>O_NOCTTY</code></td><td class="c011">端末モードでは機能しない。
</td></tr>
</table>
</div><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>O_SYNC</code></td><td class="c011">ファイルに関する同期モードで書き込みを行う。 </td></tr>
<tr><td class="c011"><code>O_DSYNC</code></td><td class="c011">データに関する同期モードで書き込みを行う。 </td></tr>
<tr><td class="c011"><code>O_RSYN</code></td><td class="c011">同期モードで読み込みを行う。
</td></tr>
</table>
</div><p>
最初のグループはファイルが存在に関連した動作を決めます:
</p><ul class="itemize"><li class="li-itemize">
<code>O_APPEND</code> が指定された場合、全ての書き込み処理の前に入出力位置がファイルの末尾にセットされる。これによって書き込まれたデータはファイルの末尾に付け足されるようになる。<code>O_APPEND</code> が無い場合、書き込みは入出力位置 (初期位置はファイルの先頭) で行われる。</li><li class="li-itemize"><code>O_TRUNC</code> が指定された場合、ファイルは開かれたときに切り捨てられる。ファイルの内容は失われてファイルの長さは 0 になり、最初の書き込みは空ファイルに行われる。<code>O_TRUNC</code> が無い場合、書き込みはファイルの先頭からそこにあるデータを上書きしながら行われる。</li><li class="li-itemize"><code>O_CREAT</code> が指定された場合、ファイルが存在しなければ作成される。作成されるファイルは空で、その権限は <code>openfile</code> の第三引数とプロセスの作成マスクによって決まる (作成マスクは <code>umask</code> によって取得および確認できる) 。</li><li class="li-itemize"><code>O_EXCL</code> が指定された場合、ファイルがすでに存在しているなら <code>openfile</code> は失敗する。このフラグと <code>O_CREATE</code> を併せると、ファイルを <a id="page/lock"></a><em>ロック</em><sup><a id="text2" href="#note2">1</a></sup> として使うことができる。ロックを取得したいプロセスは <code>O_EXCL</code> と <code>O_CREAT</code> を指定して <code>openfile</code> を呼ぶ。ファイルが存在していた場合、これは他のプロセスがロックを取得済みであることを意味し、<code>openfile</code> はエラーを出す。ファイルが存在せず <code>openfile</code> がエラーを出さずに値を返しファイルが作られた場合、他のプロセスはロックを取得することができなくなる。ロックを開放するにはプロセスはロックファイルに <code>unlink</code> を行う。ファイルの作成はアトミックな演算である: もし二つのプロセスが <code>O_EXCL</code> と <code>O_CREAT</code> を指定して同時に同じファイルを作成しようとした場合、多くとも一つのプロセスしか成功しない。この手法の欠点はプロセスが現在使用中のロックを得るためにビジーウェイトする必要があることと、プロセスの異常終了がロックを開放しない場合があることである。
</li></ul><div class="example">
<!--TOC paragraph id="sec26" 例-->
<h5 class="paragraph" id="sec26">例</h5><!--SEC END --><p>
たいていのプログラムは <code>openfile</code> の第三引数として <code>0o666</code> を使います。これは文字列でいうと <code>rw-rw-rw-</code> を意味します。デフォルトファイル作成マスクが <code>0o022</code> の場合、ファイルは <code>rw-r--r--</code> の権限で作成されます。マスクがより寛大で <code>0o002</code> の場合には、ファイルは <code>rw-rw-r--</code> の権限で作成されます。
  </p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec27" 例-->
<h5 class="paragraph" id="sec27">例</h5><!--SEC END --><p>
ファイルから読み込むには以下のようにします:
</p><div class="mylisting">openfile filename [O_RDONLY] 0</div><p><code>O_CREAT</code> が指定されていないならば、第三引数は何でも構いません。 0 がよく使われます。</p><p>それまでの内容にかかわらず空ファイルに書き込むには以下のようにします:
</p><div class="mylisting">openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o666</div><p>ファイルが実行可能なコード (例えば <code>ld</code> によって作られるファイルやスクリプトなど) を含む場合、ファイルを実行権限付きで作成します:
</p><div class="mylisting">openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o777</div><p>ファイルが機密情報 (例えば <code>mail</code> が既読メールを保存する “メールボックス”) である場合、書き込み権限を所有ユーザのみとして作成します:
</p><div class="mylisting">openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o600</div><p>存在するファイルの末尾にデータを付け足すか、ファイルが存在しない場合には作成するには以下のようにします:
</p><div class="mylisting">openfile filename [O_WRONLY; O_APPEND; O_CREAT] 0o666</div><div class="fancybreak">* * *</div></div><p><code>O_NONBLOCK</code> フラグはファイルが名前付きパイプまたはスペシャルファイルの場合に、ファイルのオープンとその後の読み込みがノンブロッキングであることを保証します。</p><p><code>O_NOCTYY</code> フラグはファイルが制御端末 (キーボードやウィンドウなど) の場合に、そのファイルが呼び出しプロセスの制御端末にならないことを保証します。</p><p>フラグの最後のグループは読み込みと書き込み処理をどのように同期するかを指定します。デフォルトでは処理は同期しません。
</p><ul class="itemize"><li class="li-itemize">
<code>O_DSYNC</code> が指定された場合、データの書き込みは同期されプロセスは全ての書き込みが物理的にメディア (通常はディスク) に行われるまでブロックされる。
</li><li class="li-itemize"><code>O_SYNC</code> が指定された場合、ファイルのデータとメタ属性の書き込みが同期される。
</li><li class="li-itemize"><code>O_RSYNC</code> が <code>O_DSYNC</code> と共に指定された場合データの読み込みも同期される: 読み込みが起こる前にそれまでの全ての書き込み (要求されたが実行されていないものを含む) が本当にメディアに書き込まれることが保証される。<code>O_RSYNC</code> が <code>O_SYNC</code> と共に指定された場合上記のことがメタ情報にも適用される。
</li></ul>
<!--TOC section id="sec28" 読み込みと書き込み-->
<h2 class="section" id="sec28">2.7  読み込みと書き込み</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/read.html"><span class="c003">read</span></a><a id="hevea_default44"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/write.html"><span class="c003">write</span></a><a id="hevea_default45"></a> はバイト列をファイルに書き込みます。歴史的な理由から、システムコール <code>write</code> は OCamlでは <code>single_write</code> という名前です。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALread">read</a> : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsingle_write">single_write</a> : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int</div><p>二つの関数 <code>read</code> と <code>single_write</code> は同じインターフェースを持ちます。第一引数は操作を行うファイルディスクリプタです。第二引数<sup><a id="text3" href="#note3">2</a></sup>は <code>read</code> の場合は読み込んだバイト列を収める文字列で、<code>single_write</code> の場合は書き込むバイト列です。第三引数は文字列の中で入出力を行う最初のバイトの位置で、第四引数は入出力を行うバイト数です。第三、四引数は第二引数の部分文字列を定めています (この部分文字列はもちろん有効なものである必要がありますが、<code>read</code> と <code>single_write</code> はこのことをチェックしません) 。
</p><div class="image"><img src="ocamlunix-image2.png" width="85%"></div><p>


<code>read</code> と <code>single_write</code> は実際に読み込んだ/書き込んだバイト数を返します。</p><p>入出力の命令はファイルディスクリプタの現在の入出力位置から行われます (ファイルが <code>O_APPEND</code> モードで開かれた場合、この位置は書き込み命令の前にファイルの末尾にセットされます)。システムコールの後、現在位置は読み込み/書き込みを行ったバイト数だけ進みます。</p><p>書き込みでは実際に書き込むバイト数は要求されたバイト数と普通一致しますが、いくつか例外があります:
(i) バイト列を書き込めなかった場合 (例えばディスクが満杯なとき)
(ii) ディスクリプタがノンブロッキングモードで開かれたパイプまたはソケットな場合
(iii) 書き込む文字列が OCamlの持つバッファより大きい場合</p><p>(iii) の理由は OCamlが最大値の制限された補助バッファを使っているためです。バッファの最大値よりも書き込みが大きかった場合、書き込みは部分的になります。この問題を解決するために、 OCamlには エラーが出るか全てのデータが書き込まれるまで書き込みを繰り返す <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwrite"><span class="c003">write</span></a> があります。しかしこの関数を使うとエラーが起こった場合に書き込まれたバイト数を知ることができません。<code>single_write</code>を使うと書き込みの原始的になり(何が書き込まれたかが分かる)、オリジナルの Unix システムコールにより忠実になるので <code>single_write</code> を使うべきです。<code>single_write</code> の実装はセクション <a href="#single_write">5.7</a> で説明されています。</p><div class="example">
<!--TOC paragraph id="sec29" 例-->
<h5 class="paragraph" id="sec29">例</h5><!--SEC END --><p>
<code>fd</code> が書き込み専用モードで開かれたディスクリプタだとします。
</p><div class="mylisting">write fd <span class="c002">"Hello world!"</span> 3 7</div><p>は <span class="c002"><code>"lo worl"</code></span> という文字列を対応するファイルに書き込み、 7 を返します。
</p><div class="fancybreak">* * *</div></div><p>読み込みでは実際に読み込んだバイト数が読むように要求されたバイト数よりも小さいことがありえます。例えばファイルの終端が近いときは現在位置からファイルの終端までのバイト数が要求されたバイト数よりも小さくなります。特に現在位置がファイルの終端なとき <code>read</code> は 0 を返します。“ゼロはファイルの終端と等しい” という慣習はスペシャルファイルやパイプ、ソケットに対しても成り立ちます。例えば <code>ctrl-D</code> を端末に入力すると <code>read</code> は 0 を返します。</p><p><code>read</code> が要求した値よりも小さい値を返すもうひとつの例は端末から読み込む場合です。この場合 <code>read</code> はまず行の入力が利用可能になるまでブロックします。行が入力され、その長さが要求されたバイト数よりも短い場合、<code>read</code> は要求されたバイト数に達しようと次のデータを待つことをせずに行の入力が利用可能になった時点で値を返します(これは端末のデフォルトの動作ですが、文字ごとに読み込むように変えることもできます。セクション section <a href="#sec%2Fspeciaux">2.13</a> と <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEterminal_io"><span class="c003">terminal_io</span></a> 型を参考にしてください)。</p><div class="example">
<!--TOC paragraph id="sec30" 例-->
<h5 class="paragraph" id="sec30">例</h5><!--SEC END --><p>
次のプログラムは標準入力から最大 100 文字を読み込み、文字列として返します。
</p><div class="mylisting"><span class="c001">let</span> buffer = Bytes.create 100 <span class="c001">in
let</span> n = read stdin buffer 0 100 <span class="c001">in</span>
  Bytes.sub buffer 0 n</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec31" 例-->
<h5 class="paragraph" id="sec31">例</h5><!--SEC END --><p>
以下の関数 <code>really_read</code> は <code>read</code> と同じインターフェースを持ちますが、要求されたバイト数を取得するために追加の読み込みを行います。読み込み中にファイルの終端に達した場合には <code>End_of_file</code> 例外が出ます。
</p><div class="mylisting"><span class="c001">let rec</span> really_read fd buffer start length =
  <span class="c001">if</span> length &lt;= 0 <span class="c001">then</span> () <span class="c001">else
  match</span> read fd buffer start length <span class="c001">with</span>
  | 0 -&gt; raise End_of_file
  | r -&gt; really_read fd buffer (start + r) (length - r);;</div><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec32" ディスクリプタのクローズ-->
<h2 class="section" id="sec32">2.8  ディスクリプタのクローズ</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/close.html"><span class="c003">close</span></a><a id="hevea_default46"></a> はファイルディスクリプタを閉じます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclose">close</a> : file_descr -&gt; unit</div><p>ディスクリプタが閉じられると読み込みや書き込みなどのディスクリプタに関する操作は全て失敗します。ディスクリプタは必要なくなった時点で閉じられるべきですが、閉じることは必須ではありません。<code>write</code> 関数による書き込みの要求が即時にカーネルに伝わるために、<code>Pervasives</code> モジュールのチャンネルとは違って全ての書き込みが実行されたことを保証するためにチャンネルを閉じる必要はありません。一方プロセスが確保できるディスクリプタの数はカーネルによって (数百から数千に) 制限されていることから、使わないディスクリプタを <code>close</code> で開放しないとディスクリプタが枯渇します。</p>
<!--TOC section id="ex/filecopy" 完全な例: ファイルのコピー-->
<h2 class="section" id="ex/filecopy">2.9  完全な例: ファイルのコピー</h2><!--SEC END --><p>引数として与えられる <code>f1</code> と <code>f2</code> について、<code>f1</code> のバイト列を <code>f2</code> にコピーするコマンド <code>file_copy</code> を作ります。
</p><div class="mylisting"><span class="c001">open</span> Unix;;

<span class="c001">let</span> buffer_size = 8192;;
<span class="c001">let</span> buffer = Bytes.create buffer_size;;

<span class="c001">let</span> file_copy input_name output_name =
  <span class="c001">let</span> fd_in = openfile input_name [O_RDONLY] 0 <span class="c001">in
  let</span> fd_out = openfile output_name [O_WRONLY; O_CREAT; O_TRUNC] 0o666 <span class="c001">in
  let rec</span> copy_loop () = <span class="c001">match</span> read fd_in buffer 0 buffer_size <span class="c001">with</span>
    |  0 -&gt; ()
    | r -&gt; ignore (write fd_out buffer 0 r); copy_loop ()
  <span class="c001">in</span>
  copy_loop ();
  close fd_in;
  close fd_out;;</div><div class="mylisting"><span class="c001">let</span> copy () =
  <span class="c001">if</span> Array.length Sys.argv = 3 <span class="c001">then begin</span>
    file_copy Sys.argv.(1) Sys.argv.(2);
    exit 0
  <span class="c001">end else begin</span>
    prerr_endline
      (<span class="c002">"Usage: "</span> ^ Sys.argv.(0) ^ <span class="c002">" &lt;input_file&gt; &lt;output_file&gt;"</span>);
    exit 1
  <span class="c001">end</span>;;

handle_unix_error copy ();;</div><p>作業の多くは <code>file_copy</code> 関数によって実行されます。最初に入力ファイルのディスクリプタを読み込み専用で開き、次に出力ファイルのディスクリプタを書き込み専用モードで開きます。</p><p>出力ファイルがすでに存在している場合ファイルは切り捨てられ (<code>O_TRUNC</code> オプション)、存在しない場合には作成されます (<code>O_CREAT</code> オプション)。作成されるファイルの権限は <code>rw-rw-rw-</code> をファイル作成マスクで改変したものですが、これは十分ではありません。実行可能ファイルをコピーする場合は、コピー先も実行可能であるべきだからです。コピー先のファイルと元のファイルの権限を同じにする方法は後述します。</p><p><code>copy_loop</code> 関数の中で <code>buffer_size</code> バイトのコピーを行います。まず<code>buffer_size</code> の読み込みを行い、これが 0 を返した場合はファイルの終端に到達しているのでコピーを終了します。そうでなければ読み込んだ <code>r</code> バイトを出力ファイルに書き込んで同じことを繰り返します。</p><p>最後に二つのディスクリプタを閉めます。プログラム本体となる <code>copy</code> はコマンドが二つの引数を受け取ったことを確認し、その引数を <code>file_copy</code> 関数に渡します。</p><p>コピー中に起きた <code>Unix_error</code> は<code>handle_unix_error</code> によって補足され、エラーの内容が表示されます。ここで起こるエラーの例としては入力ファイルが存在しないために開くことができない、権限が足りなくてファイルを開くことができない、ディスクに容量がなくて書き込むことができない、などがあります。</p><div class="exercise">
<!--TOC paragraph id="sec34" 練習問題 3-->
<h5 class="paragraph" id="sec34">練習問題 3</h5><!--SEC END --><p><a id="ex3"></a>
<code>file_copy -a f1 f2</code> が <code>f1</code> の内容を <code>f2</code> の末尾に付け足すように、<code>-a</code> オプションを追加してください。
<a href="#exans3">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 3</arg>-->
<!--NAME exercise3.html-->
<div class="answer">
<!--TOC paragraph id="sec35" 練習問題 exercise 3 の解答-->
<h5 class="paragraph" id="sec35">練習問題 <a href="#ex3">exercise 3</a> の解答</h5><!--SEC END --><p>
<a id="exans3"></a>
<code>-a</code> オプションが与えられた場合、行うべき処理が
</p><div class="mylisting">openfile output_name [O_WRONLY; O_CREAT; O_APPEND] 0o666</div><p>ではなく
</p><div class="mylisting">openfile output_name [O_WRONLY; O_CREAT; O_TRUNC] 0o666</div><p>となります。 新しいオプションをコマンドラインからパースする部分は読者に残します。
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec36" システムコールのコストとバッファ-->
<h2 class="section" id="sec36">2.10  システムコールのコストとバッファ</h2><!--SEC END --><p><code>file_copy</code> の例では読み込みを 8192 バイトごとに行ないました。どうして 1 バイトごとや 1 メガバイトごとに読み込みをしないのでしょうか? 理由は効率です。
図 <a href="#fig%2Fcopy-speed">2</a> に <code>file_copy</code> の速度を示します。一秒間にコピーできるバイト数を縦軸に、ブロックサイズ (<code>buffer_size</code> の値) を横軸に示しています。
</p><div class="figure">
<div class="image"><img src="ocamlunix-image3.png" width="100%"></div>



<a id="fig/copy-speed"></a>
<div class="caption">Figure 2 — ブロックサイズの関数としてのコピー速度</div></div><p>
転送されるデータの総量はブロックサイズに関わらず一定です。ブロックサイズが小さい時は、コピー速度はブロックサイズにほぼ比例しています。実行時間の多くがはデータの転送ではなく、<code>copy_loop</code> のループと <code>read</code> と <code>write</code> の呼び出しに使われているということがわかります。更に詳細に実行時間を計測すると、ほとんどが <code>read</code> と <code>write</code> の呼び出しに使われていることがわかります。システムコールは処理が大きくない場合でも (テストに使われた PC — 2.8 GHz Pentium 4 —  では) 最低 4 マイクロ秒、一般的には 1 から 10 マイクロ秒程度かかります。そのため入出力のブロックサイズが小さい場合にはシステムコールの時間が支配的になります。</p><p>ブロックが大きくて 4KB から 1MB の場合、コピー速度は最大値で一定です。ここではシステムコールとループにかかる時間がデータ転送にかかる時間に比べて小さくなっているということです。加えてバッファのサイズがシステムのキャッシュよりも大きくなるためにデータの転送がシステムコールのコストを上回るようになります<sup><a id="text4" href="#note4">3</a></sup>。</p><p>最後に、ブロックがとても大きい (8 MB 以上) ときにはコピー速度は最大値よりも少しだけ小さくなります。ここで影響するのはブロックを確保してメモリのページを割り当てるのを書き込み中に行う時間です。</p><p>以上のことから学べることは、システムコールはほとんど何も処理をしていない場合でも大きな — 通常の関数呼び出しよりもはるかに大きな — コストがかかるということです。アーキテクチャによって違いますが、だいたい 2 から 20 マイクロ秒が呼び出しごとにかかります。そのためシステムコールの数を減らすことが重要になります。読み込みと書き込みに関して言えば、一文字ごとではなくある程度のサイズのブロックごとに行われるべきです。</p><p><code>file_copy</code> の例では大きなブロックで入出力を行うのは難しくありません。しかしある種のプログラムでは一文字ごとに入出力を行うことが自然なことがあります(例えばファイルから一行ずつ読む処理、字句解析、数字の印字など)。このようなプログラムのために、ほとんどのシステムにはアプリケーションとオペレーティングシステムの間にソフトウェアのレイヤーを追加する入出力ライブラリがあります。例えば OCamlには <code>Pervasives</code> モジュールにファイルディスクリプタと似た抽象型<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEin_channel"><span class="c003">in_channel</span></a> と <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEout_channel"><span class="c003">out_channel</span></a> が定義されていて、この型に関する関数 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_char"><span class="c003">input_char</span></a>,<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_line"><span class="c003">input_line</span></a>、<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_char"><span class="c003">output_char</span></a> あるいは <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_string"><span class="c003">output_string</span></a> があります。このレイヤーはバッファを使って複数回の一文字ごとの読み込みと書き込みを一回のシステムコールにまとめます。これによって一文字ごとに処理をするプログラムの効率が良くなります。さらにこのレイヤーによってプログラムがよりポータブルになります。<code>Pervasives</code> モジュールを使うプログラムを新しいオペレーティングシステムに移植するには、このライブラリをそのシステム上で使えるシステムコールを使って実装すれば良いからです。</p>
<!--TOC section id="sec37" 完全な例: 簡単な入出力ライブラリ-->
<h2 class="section" id="sec37">2.11  完全な例: 簡単な入出力ライブラリ</h2><!--SEC END --><p>バッファを使った入出力のテクニックの例として、OCamlの <code>Pervasives</code> ライブラリの一部を実装します。 次のようなインタフェースを持ちます:
</p><div class="mylisting"><span class="c001">exception</span> End_of_file

<span class="c001">type</span> in_channel
<span class="c001">val</span> open_in : string -&gt; in_channel
<span class="c001">val</span> input_char : in_channel -&gt; char
<span class="c001">val</span> close_in : in_channel -&gt; unit

<span class="c001">type</span> out_channel
<span class="c001">val</span> open_out : string -&gt; out_channel
<span class="c001">val</span> output_char : out_channel -&gt; char -&gt; unit
<span class="c001">val</span> close_out : out_channel -&gt; unit</div><p>“読み込み” の部分から始めます。
抽象型 <code>in_channel</code> は次のように定義します:
</p><div class="mylisting"><span class="c001">open</span> Unix;;

<span class="c001">type</span> in_channel =
  { in_buffer: bytes;
    in_fd: file_descr;
    <span class="c001">mutable</span> in_pos: int;
    <span class="c001">mutable</span> in_end: int };;
<span class="c001">exception</span> End_of_file</div><p>文字列 <code>in_buffer</code> は文字通りのバッファです。フィールド <code>in_fd</code> は読み込むファイルに開かれた (Unix の) ファイルディスクリプタです。フィールド <code>in_pos</code> は読み込みの現在位置を示します。フィールド <code>in_end</code> は事前にバッファへ読み込まれた文字列のうち有効な部分長さです。
</p><div class="image"><img src="ocamlunix-image4.png" width="85%"></div><p>


<code>in_pos</code> と <code>in_end</code> のフィールドは読み込み処理中に更新されるので <code><span class="c001">mutable</span></code> として宣言します。
</p><div class="mylisting"><span class="c001">let</span> buffer_size = 8192;;
<span class="c001">let</span> open_in filename =
  { in_buffer = Bytes.create buffer_size;
    in_fd = openfile filename [O_RDONLY] 0;
    in_pos = 0;
    in_end = 0 };;</div><p>読み込みのためにファイルを開いたとき、同時に合理的なサイズの (システムコールが多くなりすぎない程度に大きく、メモリを無駄遣いしない程度に小さい) バッファを作ります。その後 <code>in_fd</code> フィールドを読み込み専用で開いたファイルに対する Unix のファイルディスクリプタで初期化します。バッファは最初空です (ファイルからのどんな文字列も含んでいません) 。そのため <code>in_end</code> フィールドは 0 で初期化します。
</p><div class="mylisting"><span class="c001">let</span> input_char chan =
  <span class="c001">if</span> chan.in_pos &lt; chan.in_end <span class="c001">then begin
    let</span> c =  chan.in_buffer.[chan.in_pos] <span class="c001">in</span>
      chan.in_pos &lt;- chan.in_pos + 1;
      c
  <span class="c001">end else begin
    match</span> read chan.in_fd chan.in_buffer 0 buffer_size
    <span class="c001">with</span> 0 -&gt; raise End_of_file
       | r -&gt; chan.in_end &lt;- r;
              chan.in_pos &lt;- 1;
              chan.in_buffer.[0]
  <span class="c001">end</span>;;</div><p><code>in_channel</code> から文字を読むとき、次の二つのうち一つを行います。一つ目はバッファに一つ以上まだ読んでいない文字がある、つまり <code>in_pos</code> フィールドの値が <code>in_end</code> フィールドの値よりも小さい場合です。このときはバッファの <code>in_pos</code> にある文字を返し、 <code>in_pos</code> をインクリメントします。もう一つはバッファが空の場合で、このときは <code>read</code> を呼んでバッファにもう一度文字列を読み込みます。<code>read</code> が 0 を返したならファイルの終端に達したということなので <code>End_of_file</code> 例外を出します。そうでなければ <code>in_end</code> に呼んだ文字の数を代入します。
</p><div class="mylisting"><span class="c001">let</span> close_in chan =
  close chan.in_fd;;</div><p><code>in_channel</code> を閉じる処理は対応する Unix のファイルディスクリプタを閉じるだけです。</p><p>“書き込み” の部分は “読み込み” の部分にとても良く似ています。唯一異なるのはバッファがまだ読んでいない読み込み (バッファされたが読み込まれていない文字列) を保持するのではなくて、まだ完了していない書き込み (バッファされたがファイルディスクリプタに書き込まれていない文字列) を保持する点です。</p><div class="image"><img src="ocamlunix-image5.png" width="85%"></div><div class="mylisting"><span class="c001">type</span> out_channel =
  { out_buffer: bytes;
    out_fd: file_descr;
    <span class="c001">mutable</span> out_pos: int };;

<span class="c001">let</span> open_out filename =
  { out_buffer = Bytes.create 8192;
    out_fd = openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o666;
    out_pos = 0 };;

<span class="c001">let</span> output_char chan c =
  <span class="c001">if</span> chan.out_pos &lt; Bytes.length chan.out_buffer <span class="c001">then begin</span>
    chan.out_buffer.[chan.out_pos] &lt;- c;
    chan.out_pos &lt;- chan.out_pos + 1
  <span class="c001">end else begin</span>
    ignore (write chan.out_fd chan.out_buffer 0 chan.out_pos);
    chan.out_buffer.[0] &lt;- c;
    chan.out_pos &lt;- 1
  <span class="c001">end</span>;;

<span class="c001">let</span> close_out chan =
  ignore (write chan.out_fd chan.out_buffer 0 chan.out_pos);
  close chan.out_fd;;</div><p><code>out_channel</code> に文字を書き込むには次の二つのうち一つを行います。一つ目はバッファが満杯ではない場合で、このときは文字をバッファを <code>out_pos</code> の位置に保存して <code>out_pos</code> をインクリメントします。もう一つはバッファが満杯の場合で、このときは <code>write</code> を呼んでバッファを空にしてからバッファの先頭に文字を読み込みます。</p><p><code>out_channel</code> を閉めるときにはバッファの内容 (位置 0 から <code>out_pos - 1</code> までの文字列) を書き込むことを忘れないでください。これを忘れると最後にバッファが空になってからチャンネルに書き込まれた内容が失われます。</p><div class="exercise">
<!--TOC paragraph id="sec38" 練習問題 4-->
<h5 class="paragraph" id="sec38">練習問題 4</h5><!--SEC END --><p><a id="ex4"></a>
次の関数を実装してください:
</p><div class="mylisting"><span class="c001">val</span> output_string : out_channel -&gt; string -&gt; unit</div><p>この関数は <code>output_char</code> をそれぞれの文字に対して複数回呼んだときと同じ動作をしますが、より効率的です。
 <a href="#exans4">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 4</arg>-->
<!--NAME exercise4.html-->
<div class="answer">
<!--TOC paragraph id="sec39" 練習問題 exercise 4 の解答-->
<h5 class="paragraph" id="sec39">練習問題 <a href="#ex4">exercise 4</a> の解答</h5><!--SEC END --><p>
<a id="exans4"></a>
書き込む文字列をバッファにコピーするのが基本的なアイデアです。バッファに十分な空きが無く途中でバッファを空にする必要がある場合とそうでなく文字列全てをバッファに直接書き込める場合とを考える必要があります。解答例を以下に示します。
</p><div class="mylisting"><span class="c001">open</span> Unix;;</div><div class="mylisting"><span class="c001">let</span> output_string chan s =
  <span class="c001">let</span> avail = Bytes.length chan.out_buffer - chan.out_pos <span class="c001">in
  if</span> Bytes.length s &lt;= avail <span class="c001">then begin</span>
    Bytes.blit s 0 chan.out_buffer chan.out_pos (Bytes.length s);
    chan.out_pos &lt;- chan.out_pos + Bytes.length s
  <span class="c001">end
  else if</span> chan.out_pos = 0 <span class="c001">then begin</span>
    ignore (write chan.out_fd s 0 (Bytes.length s))
  <span class="c001">end
  else begin</span>
    Bytes.blit s 0 chan.out_buffer chan.out_pos avail;
    <span class="c001">let</span> out_buffer_size = Bytes.length chan.out_buffer <span class="c001">in</span>
    ignore (write chan.out_fd chan.out_buffer 0 out_buffer_size);
    <span class="c001">let</span> remaining = Bytes.length s - avail <span class="c001">in
    if</span> remaining &lt; out_buffer_size <span class="c001">then begin</span>
      Bytes.blit s avail chan.out_buffer 0 remaining;
      chan.out_pos &lt;- remaining
    <span class="c001">end else begin</span>
      ignore (write chan.out_fd s avail remaining);
      chan.out_pos &lt;- 0
    <span class="c001">end
  end</span>;;</div><div class="mylisting"><span class="c001">let</span> ex2 () =
  <span class="c001">if</span> Array.length Sys.argv &lt; 3 <span class="c001">then begin</span>
     prerr_string <span class="c002">"Usage: test &lt;sources&gt; &lt;dest&gt;"</span>;
     exit 2;
  <span class="c001">end</span>;
  <span class="c001">let</span> fdin = open_in Sys.argv.(1) <span class="c001">in
  let</span> fdout = open_out Sys.argv.(2) <span class="c001">in</span>
  prerr_endline <span class="c002">"copying"</span>;
  <span class="c001">try while true do</span> output_char fdout (input_char fdin) <span class="c001">done
  with</span> End_of_file -&gt;
   prerr_endline <span class="c002">"Done"</span>;
   output_string fdout <span class="c002">"The end.\n"</span>;
   prerr_endline <span class="c002">"Closing"</span>;
   close_out fdout;;

handle_unix_error ex2 ();;</div><div class="mylisting">./ex2.byte ex2.ml ex2.out
(cat ex2.ml; echo <span class="c002">"C'est la fin."</span>) | diff --brief - ex2.out
rm ex2.out</div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec40" 入出力の位置-->
<h2 class="section" id="sec40">2.12  入出力の位置</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/seek.html"><span class="c003">seek</span></a><a id="hevea_default47"></a> はファイルディスクリプタの現在の入出力位置を変更します。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlseek">lseek</a> : file_descr -&gt; int -&gt; seek_command -&gt; int</div><p>第一引数はファイルディスクリプタで第二引数は移動させる位置です。第二引数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEseek_command"><span class="c003">seek_command</span></a> 型の第三引数に基づいて解釈されます。この列挙型は位置の種類を指定します:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c014"><code>SEEK_SET</code></td><td class="c013">第二引数は関数を呼び出した後の入出力位置を表す。ファイルの最初の文字は位置 0 である。 </td></tr>
<tr><td class="c014"><code>SEEK_CUR</code></td><td class="c013">第二引数は現在の入出力位置からの相対的なオフセットを表す。正の値のとき前に、負の値のとき後ろに動く。 </td></tr>
<tr><td class="c014"><code>SEEK_END</code></td><td class="c013">第二引数はファイルの終端からの相対的なオフセットを表す。<code>SEEK_CUR</code> と同様にオフセットは正負どちらにもなれる。
</td></tr>
</table>
</div><p>
<code>lseek</code> の返り値は関数を実行した後の入出力位置 (絶対位置) です。</p><p>負の絶対位置が指定された場合はエラーとなります。ファイルの終端よりも後ろの位置を指定することは可能です。このとき <code>read</code> は (ファイルの末尾に達しているので) 0 を返し、<code>write</code> はまずファイルの終端から入出力位置まで 0 を書き込んでからデータを書き込みます。</p><div class="example">
<!--TOC paragraph id="sec41" 例-->
<h5 class="paragraph" id="sec41">例</h5><!--SEC END --><p>
カーソルを 1000 番目の文字に移動させるには以下のようにします:
</p><div class="mylisting">lseek fd 1000 SEEK_SET</div><p>一文字巻き戻すには以下のようにします:
</p><div class="mylisting">lseek fd (-1) SEEK_CUR</div><p>ファイルのサイズを求めるには以下のようにします:
</p><div class="mylisting"><span class="c001">let</span> file_size = lseek fd 0 SEEK_END <span class="c001">in</span> ...</div><div class="fancybreak">* * *</div></div><p>ファイルディスクリプタが <code>O_APPEND</code> モードで開かれている場合、入出力位置は毎回の書き込みの前にファイルの終端にセットされます。そのため書き込み位置を指定するために <code>lseek</code> を読んでも意味がありません。一方読み込みを指定することには使えます。</p><p>コミュニケーションデバイス (パイプ、ソケット) や端末を始めとする多くのスペシャルファイルなどの、入出力の絶対位置が意味を持たないタイプのファイルについては <code>lseek</code> の動作は未定義です。Unix のほとんどの実装ではこれらのファイルに対する <code>lseek</code> は無視されます (入出力位置はセットされますが、入出力処理は入出力位置を無視します)。いくつかの実装ではパイプとソケットに対する <code>lseek</code> はエラーを出します。</p><div class="exercise">
<!--TOC paragraph id="sec42" 練習問題 5-->
<h5 class="paragraph" id="sec42">練習問題 5</h5><!--SEC END --><p><a id="ex5"></a>
<code>tail</code> コマンドはファイルの末尾 <span class="c006">n</span> 行を表示します。<code>tail</code> を通常ファイルに対して効率よく実装するにはどうすればよいでしょうか ? <code>-f</code> オプションはどのすれば実装できるでしょうか (参考: <code>man tail</code>) ?
 <a href="#exans5">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 5</arg>-->
<!--NAME exercise5.html-->
<div class="answer">
<!--TOC paragraph id="sec43" 練習問題 exercise 5 の解答-->
<h5 class="paragraph" id="sec43">練習問題 <a href="#ex5">exercise 5</a> の解答</h5><!--SEC END --><p>
<a id="exans5"></a>
<code>tail</code> のナイーブな実装は最後に呼んだ <span class="c006">n</span> 行を巡回バッファに記録しながらファイルを最初から読み、ファイルの末尾に達したところでバッファを表示するというものです。<code>lseek</code> の実装されないパイプやスペシャルファイルからデータが来るならば、これが最善の方法になります。</p><p>もしデータが通常ファイルから来るならば、ファイルの末尾から読み込むほうが効率が良くなります。まず <code>lseek</code> を使って最後の 4096 文字を読み込み、その中に改行がないか調べます。<span class="c006">n</span> 個以上の改行があるなら対応する行を出力しそうでなければ次の 4096 バイトを読み、同じことをします。</p><p><code>-f</code> オプションを追加するにはまずオプション無しの場合の動作を行い、そのあとファイルの末尾に移動してから <code>read</code> します。<code>read</code> が返ったときはその内容をすぐに画面に表示しもう一度 <code>read</code> します。もし <code>read</code> が <code>0</code> を返したならプログラムは一定時間待ってから (<code>sleep 1</code>) もう一度試します。
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec44" ファイルの種類に特有の操作-->
<h2 class="section" id="sec44">2.13  ファイルの種類に特有の操作</h2><!--SEC END --><p>Unix ではデータのやり取りはディスクリプタを通して行われ、ディスクリプタは永続性のファイル (通常ファイル、周辺機器) または揮発性のファイル (パイプとソケット、  <a href="#sec%2Fpipes">5</a> 章と <a href="#sec%2Fsockets">6</a> 章参照) を表します。ファイルディスクリプタはデータのやり取りのための統一されたメディアによらないインタフェースを提供します。もちろんファイルディスクリプタに対する操作の実際の実装は背後にあるメディアによって異なります。</p><p>しかしあるメディアの全ての機能を使う必要がある場合は他のファイルと同じように扱うことはできません。ファイルのオープンや読み込み、書き込みなどの一般的な操作はほとんどのディスクリプタで同じ動作をします。しかしこのような一般的な操作であっても、周辺機器とパラメータで決まるアドホックな動作をするスペシャルファイルが存在します。またあるメディアに対してだけ可能な操作もあります。</p><!--TOC subsection id="sec45" 通常ファイル-->
<h3 class="subsection" id="sec45">通常ファイル</h3><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/truncate.html"><span class="c003">truncate</span></a><a id="hevea_default48"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/ftruncate.html"><span class="c003">ftruncate</span></a><a id="hevea_default49"></a> を使うと通常ファイルを短くすることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtruncate">truncate</a>  : string -&gt; int -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALftruncate">ftruncate</a> : file_descr -&gt; int -&gt; unit</div><p>第一引数は切り捨てるファイルで第二引数は切り捨てた後のサイズです。これより後ろの位置にある全てのデータは失われます。</p><!--TOC subsection id="sec46" シンボリックリンク-->
<h3 class="subsection" id="sec46">シンボリックリンク</h3><!--SEC END --><p>シンボリックリンクに対するほとんどの操作はリンクを “たどり” ます。つまり、操作はリンクそのものではなくリンクが指すファイルに適用されます (例えば <span class="c003">openfile</span><a id="hevea_default50"></a>, <span class="c003">stat</span><a id="hevea_default51"></a>, <span class="c003">truncate</span><a id="hevea_default52"></a>, <span class="c003">opendir</span><a id="hevea_default53"></a> などはこのような動作をします) 。</p><p>二つのシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/symlink.html"><span class="c003">symlink</span></a><a id="hevea_default54"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/readlink.html"><span class="c003">readlink</span></a><a id="hevea_default55"></a> はシンボリックリンクそのものを操作します。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsymlink">symlink</a>  : string -&gt; string -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALreadlink">readlink</a> : string -&gt; string</div><p><code>symlink f1 f2</code> は <code>f1</code> へのシンボリックリンク <code>f2</code> を作成します (Unix コマンド <code>ln -s f1 f2</code> と同様です) 。<code>readlink</code> はシンボリックリンクの内容、つまりリンクが指すファイルの名前を返します。</p><!--TOC subsection id="sec/speciaux" スペシャルファイル-->
<h3 class="subsection" id="sec/speciaux">スペシャルファイル</h3><!--SEC END --><p>スペシャルファイルは “キャラクタ” または “ブロック” に分類されます。前者は文字のストリームです。つまり文字の入出力は逐次的にしか行うことができません。例として端末やサウンドデバイス、プリンターなどがあります。後者は永続的な媒体を持つものであり、ディスクが典型です。文字はブロック単位で読み込むことができ、現在位置からの相対位置にシークすることができます。</p><p>スペシャルファイルは以下のように分類できます:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c014"><code>/dev/null</code></td><td class="c013">あらゆるものを飲み込み何も出てこないブラックホール。 プロセスの出力を <code>/dev/null</code> にリダイレクトすることでプロセスの出力を無視できる。 </td></tr>
<tr><td class="c014"><code>/dev/tty*</code></td><td class="c013">制御端末。 </td></tr>
<tr><td class="c014"><code>/dev/pty*</code></td><td class="c013">本物の端末ではないが端末をシミュレートし同じインターフェースを持つ擬似端末。 </td></tr>
<tr><td class="c014"><code>/dev/hd*</code></td><td class="c013">ディスク。 </td></tr>
<tr><td class="c014"><code>/proc</code></td><td class="c013">システム変数。 Linux ではシステム変数はファイルシステムで管理され、入出力が許されている。
</td></tr>
</table>
</div><p>多くのファイルに対するシステムコールはスペシャルファイルに対して違った動作をします。しかし <code>read</code> と <code>write</code> に関しては、ほとんどのスペシャルファイル (端末、テープドライバ、ディスクなど) が通常ファイルと同じ動作をします (読み書きするバイト数に制限があることがあります)。ただしそのようなスペシャルファイルの多くが <span class="c003">lseek</span><a id="hevea_default56"></a> を無視します。</p><p>通常のファイルシステムに加えて、周辺機器を表すスペシャルファイルは動的に制御また設定される必要があります。例えばテープドライブには巻き戻しや早送りが、端末には行の編集モードや特殊文字による制御、シリアル通信用変数 (スピード、パリティなど) があります。Unix ではこれらデバイスのパラメータの設定は全てシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/ioctl.html"><span class="c003">ioctl</span></a><a id="hevea_default57"></a> を通して行います。しかし OCamlにはこのシステムコールが提供されていません。<a href="http://www.opengroup.org/onlinepubs/009696799/functions/ioctl.html"><span class="c003">ioctl</span></a><a id="hevea_default58"></a> は引数の形が特殊なので統一的に扱うことができないためです。</p><!--TOC subsection id="sec/termio" 端末-->
<h3 class="subsection" id="sec/termio">端末</h3><!--SEC END --><p>端末と擬似端末はキャラクタタイプのスペシャルファイルで、 OCamlから設定を変更することができます。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcgetattr.html"><span class="c003">tcgetattr</span></a><a id="hevea_default59"></a> はオープンされたスペシャルファイルのファイルディスクリプタを受け取り <span class="c007">posix</span> 規格に基づいて端末の状態を表す <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEterminal_io"><span class="c003">terminal_io</span></a> 型の構造体を返します。

</p><div class="mylisting"><span class="c001">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEterminal_io">terminal_io</a> =
  { c_ignbrk : bool; c_brk_int : bool; ...;  c_vstop : char }</div><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcgetattr">tcgetattr</a> : file_descr -&gt; terminal_io</div><p>この構造体を変更してシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcsetattr.html"><span class="c003">tcsetattr</span></a><a id="hevea_default60"></a> を呼ぶことで周辺機器の設定を変更できます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcsetattr">tcsetattr</a> : file_descr -&gt; setattr_when -&gt; terminal_io -&gt; unit</div><p>第一引数は操作する周辺機器のファイルディスクリプタです。最後の引数は <code>terminal_io</code> 型の構造体で、周辺機器への引数となります。第二引数は変更がいつ起きるべきかを指定する <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsetattr_when"><span class="c003">setattr_when</span></a> 列挙型の値です。即時 (<code>TCSANOW</code>)、 データを全て送ってから (<code>TCSADRAIN</code>)、 データを全て受け取ってから (<code>TCAFLUSH</code>) の三つを指定できます。書き込みに関するパラメータを変更するときには <code>TCSADRAIN</code> が、読み込みに関するパラメータを変更するときには <code>TCSAFLUSH</code> が推奨されます。</p><div class="example">
<!--TOC paragraph id="sec49" 例-->
<h5 class="paragraph" id="sec49">例</h5><!--SEC END --><p>
標準入力が端末または擬似端末の場合、パスワードを読む処理を行っている間はユーザが打ち込んだ文字列を表示するべきではありません。この処理は以下のように実装できます:

</p><div class="mylisting"><span class="c001">let</span> read_passwd message =
  <span class="c001">match
    try
      let</span> default = tcgetattr stdin <span class="c001">in
      let</span> silent =
        { default <span class="c001">with</span>
          c_echo = <span class="c001">false</span>;
          c_echoe = <span class="c001">false</span>;
          c_echok = <span class="c001">false</span>;
          c_echonl = <span class="c001">false</span>;
        } <span class="c001">in</span>
      Some (default, silent)
    <span class="c001">with</span> _ -&gt; None
  <span class="c001">with</span>
  | None -&gt; input_line Pervasives.stdin
  | Some (default, silent) -&gt;
      print_string message;
      flush Pervasives.stdout;
      tcsetattr stdin TCSANOW silent;
      <span class="c001">try
        let</span> s = input_line Pervasives.stdin <span class="c001">in</span>
        tcsetattr stdin TCSANOW default; s
      <span class="c001">with</span> x -&gt;
        tcsetattr stdin TCSANOW default; raise x;;</div><p><code>read_passwd</code> 関数は <code>stdin</code> につながっている端末の現在の設定を取得するところから始まります。その後文字を表示しないように変更した設定を定義します。もしこの処理が失敗した場合標準入力は制御端末ではないので普通に一行の入力を受け取ります。そうでなければメッセージを表示し、端末の設定を変え、パスワードを読み込み、端末の設定を元に戻します。読み込みが失敗した後でも端末の設定が元に戻るように注意が必要です。
</p><div class="fancybreak">* * *</div></div><p>プログラムが別のプログラムを起動しその標準入力を端末 (もしくは擬似端末) につなげる必要がある場合があります。OCamlはこれをサポートしていません<sup><a id="text5" href="#note5">4</a></sup>。そのため擬似端末 (一般に <code>/dev/tty[a-z][a-f0-9]</code> という名前のついたファイル) の中からすでに開いているものを手動で探す必要があります。そしてその擬似端末のファイルをオープンすれば、新しいプログラムを標準入力がこのファイルになった状態で始めることができます。</p><p>端末のデータの流れを制御する関数が 4 つあります (割り込みを送る、送信の終了を待つ、待っているデータをフラッシュする、やり取りを再開する)。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcsendbreak">tcsendbreak</a> : file_descr -&gt; int -&gt; unit</div><p><a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcsendbreak.html"><span class="c003">tcsendbreak</span></a><a id="hevea_default61"></a> 関数は周辺機器に割り込みを送ります。第二引数は割り込みの長さです (0 は周辺機器のデフォルト値と解釈されます)。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcdrain">tcdrain</a> : file_descr -&gt; unit</div><p><a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcdrain.html"><span class="c003">tcdrain</span></a><a id="hevea_default62"></a> 関数は全ての書き込みデータが送信されるのを待ちます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcflush">tcflush</a> : file_descr -&gt; flush_queue -&gt; unit</div><p>第二引数の値にもとづいて、 <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcflush.html"><span class="c003">tcflush</span></a><a id="hevea_default63"></a> 関数は書き込まれたが送信されていないデータ (<code>TCIFLUSH</code>) か受け取ったが読み込まれていないデータ (<code>TCOFLUSH</code>) 、あるいはその両方 (<code>TCIOFLUSH</code>) を捨てます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcflow">tcflow</a> : file_descr -&gt; flow_action -&gt; unit</div><p>第二引数の値にもとづいて、 <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcflow.html"><span class="c003">tcflow</span></a><a id="hevea_default64"></a> 関数はデータの送信を止める (<code>TCOOFF</code>) か、データの送信を再開する (<code>TCOON</code>) か、制御文字 <span class="c007">stop</span> あるいは <span class="c007">start</span> を送って送信を止める (<code>TCIOFF</code>) かをします。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetsid">setsid</a> : unit -&gt; int</div><p><a href="http://www.opengroup.org/onlinepubs/009696799/functions/setsid.html"><span class="c003">setsid</span></a><a id="hevea_default65"></a> 関数はプロセスを新しいセッションに移し端末から切り離します。</p>
<!--TOC section id="sec50" ファイルのロック-->
<h2 class="section" id="sec50">2.14  ファイルのロック</h2><!--SEC END --><p>二つのプロセスは同じファイルに同時に書き込むことができますが、書き込みが衝突した場合データの一貫性が失われることがあります。<code>O_APPEND</code> を使って常にファイルの末尾に書き込むようにしてこれを回避できることがあります。<code>log</code> ファイルにはこの方法で良いですが、データベースのように任意の場所に書き込みが起こるときは上手くいきません。そのような場合にはファイルを使うプロセスは他人のつま先を踏まないように協調する必要があります。ファイル全体に対するロックは補助ファイルを使うことで実装できます (<a href="#page%2Flock">??</a> ページ参照) が、システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/lockf.html"><span class="c003">lockf</span></a><a id="hevea_default66"></a> を使うとファイルの一部分をロックするより良い同期パターンを利用できます。

</p><div class="mylisting"> <span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlockf">lockf</a> : file_descr -&gt; lock_command -&gt; int -&gt; unit</div>
<!--TOC section id="sec/copyrec" 完全な例: 再帰的なファイルのコピー-->
<h2 class="section" id="sec/copyrec">2.15  完全な例: 再帰的なファイルのコピー</h2><!--SEC END --><p><code>file_copy</code> (セクション <a href="#ex%2Ffilecopy">2.9</a>) を拡張して通常ファイルだけではなくシンボリックリンクとディレクトリにも対応させます。ディレクトリについてはその中身も再帰的にコピーすることにします。</p><p>通常ファイルのコピーにはすでに定義した <a href="#ex%2Ffilecopy">2.9</a> 関数を再利用します。
</p><div class="mylisting"><span class="c001">open</span> Unix
...
<span class="c001">let</span> file_copy input_name output_name =
...</div><p>次の <code>set_infos</code> 関数はファイルの所有者とアクセス権限、最終アクセス/変更日時を変更します。コピー先のファイルの情報をコピー元と同じにするためにこの関数を使います。

</p><div class="mylisting"><span class="c001">let</span> set_infos filename infos =
  utimes filename infos.st_atime infos.st_mtime;
  chmod filename infos.st_perm;
  <span class="c001">try</span>
    chown filename infos.st_uid infos.st_gid
  <span class="c001">with</span> Unix_error(EPERM,_,_) -&gt; ()</div><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/utime.html"><span class="c003">utime</span></a><a id="hevea_default67"></a> は最終アクセス/更新日時を、<code>chmod</code> と <code>chown</code>がアクセス権限と所有者を変更します。通常ユーザが <code>chown</code> を実行すると “permission denied” エラーが出て失敗することがありますが、このエラーは捕捉した上で無視します。</p><p>処理の本体である再帰関数は以下のようになります:
</p><div class="mylisting"><span class="c001">let rec</span> copy_rec source dest =
  <span class="c001">let</span> infos = lstat source <span class="c001">in
  match</span> infos.st_kind <span class="c001">with</span>
  | S_REG -&gt;
      file_copy source dest;
      set_infos dest infos
  | S_LNK -&gt;
      <span class="c001">let</span> link = readlink source <span class="c001">in</span>
      symlink link dest
  | S_DIR -&gt;
      mkdir dest 0o200;
      Misc.iter_dir
        (<span class="c001">fun</span> file -&gt;
          <span class="c001">if</span> file &lt;&gt; Filename.current_dir_name
              &amp;&amp; file &lt;&gt; Filename.parent_dir_name
          <span class="c001">then</span>
            copy_rec
              (Filename.concat source file)
              (Filename.concat dest file))
        source;
      set_infos dest infos
  | _ -&gt;
      prerr_endline (<span class="c002">"Can't cope with special file "</span> ^ source)</div><p><code>source</code> ファイルの情報を読むところから処理が始まります。ファイルが通常ファイルの場合、 <code>file_copy</code> によってデータを、 <code>set_infos</code> によって情報をコピーします。ファイルがシンボリックリンクの場合、リンクがどこを指しているを読み取りそのファイルを指すリンクを作成します。ファイルがディレクトリの場合、目的となるディレクトリを作成しディレクトリのエントリを読み、各エントリに対して再帰的に <code>copy\_rec</code> を呼び出します。このときディレクトリそのものと親ディレクトリのエントリは無視します。これ以外のファイルについては警告を出して無視します。</p><p>メインプログラムは単純です:

</p><div class="mylisting"><span class="c001">let</span> copyrec () =
  <span class="c001">if</span> Array.length Sys.argv &lt;&gt; 3 <span class="c001">then begin</span>
    prerr_endline (<span class="c002">"Usage: "</span> ^Sys.argv.(0)^ <span class="c002">" &lt;source&gt; &lt;destination&gt;"</span>);
    exit 2
  <span class="c001">end else begin</span>
    copy_rec Sys.argv.(1) Sys.argv.(2);
    exit 0
  <span class="c001">end</span>
;;
handle_unix_error copyrec ();;</div><div class="exercise">
<!--TOC paragraph id="sec52" 練習問題 6-->
<h5 class="paragraph" id="sec52">練習問題 6</h5><!--SEC END --><p><a id="ex6"></a>
<a id="ex/copyrec"></a>
ハードリンクを賢くコピーしてください。同じファイルが <span class="c006">n</span> 個の異なる場所に存在する場合、上記のプログラムでは<code>copy_rec</code> は同じファイルを <span class="c006">n</span> 個作成します。このような状況を検出し、コピーを一度だけして他の場所にはハードリンクを作るようにしてください。
<a href="#exans6">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 6</arg>-->
<!--NAME exercise6.html-->
<div class="answer">
<!--TOC paragraph id="sec53" 練習問題 exercise 6 の解答-->
<h5 class="paragraph" id="sec53">練習問題 <a href="#ex6">exercise 6</a> の解答</h5><!--SEC END --><p>
<a id="exans6"></a>
すでにコピーされたファイルについて、識別子 <code>(st_dev, st_ino)</code> からコピー先へのマップを記録するようにします。各コピーを実行する前にマップを探索し、同じ識別子を持ったファイルがすでにコピーされていないかをチェックします。もしすでにコピーされたファイルが見つかったらファイルをコピーする代わりにコピー元ファイルと同じ名前のハードリンクを作成します。マップの大きさを最小化するために一つ以上の名前を持つファイル、つまり <code>st_nlink &gt; 1</code> を満たすファイルのみについてマップを持つようにします。

</p><div class="mylisting"><span class="c001">let</span> copied_files = (Hashtbl.create 53 : ((int * int), string) Hashtbl.t)

<span class="c001">let rec</span> copy source dest =
  <span class="c001">let</span> infos = lstat source <span class="c001">in
  match</span> infos.st_kind <span class="c001">with</span>
    S_REG -&gt;
      <span class="c001">if</span> infos.st_nlink &gt; 1 <span class="c001">then begin
        try
          let</span> dest' =
            Hashtbl.find copied_files (infos.st_dev, infos.st_ino)
          <span class="c001">in</span> link dest' dest
        <span class="c001">with</span> Not_found -&gt;
          Hashtbl.add copied_files (infos.st_dev, infos.st_ino) dest;
          file_copy source dest;
          set_infos dest infos
      <span class="c001">end else begin</span>
        file_copy source dest;
        set_infos dest infos
      <span class="c001">end</span></div><div class="mylisting">  | S_LNK -&gt; ...</div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec54" 完全な例: TAR-->
<h2 class="section" id="sec54">2.16  完全な例: TAR</h2><!--SEC END --><p><code>tar</code> ファイルフォーマット (<code>t</code>ape <code>ar</code>chive の略です) はファイル階層を一つのファイルに保存します。<code>tar</code> ファイルは小さなファイルシステムと見ることができます。</p><p>このセクションでは <code>tar</code> ファイルを読み書きする関数を定義します。そのほかに <code>readtar</code> という、 <code>readtar a</code> でアーカイブ <code>a</code> に含まれるファイルを表示し、<code>readtar a f</code> でアーカイブ <code>a</code> に含まれるファイル <code>f</code> を取り出すコマンドも作ります。ファイル階層全体を取り出すこととファイル階層からアーカイブを作ることは練習問題として読者に残します。</p>
<!--TOC paragraph id="sec55" ファイルフォーマットの仕様-->
<h5 class="paragraph" id="sec55">ファイルフォーマットの仕様</h5><!--SEC END --><p><code>tar</code> アーカイブは複数のレコードから成ります。それぞれのレコードがファイルを表します。レコードはファイルについての情報 (名前、種類、サイズ、所有者など) をエンコードするヘッダから始まり、ファイルの内容がその後に続きます。ヘッダは 512 バイトのブロックで、表 <a href="#fig%2Ftar">3</a> のような構造をしています。</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c012">オフセット</td><td class="c012">長さ</td><td class="c011">コードの種類</td><td class="c011">名前</td><td class="c011">説明 </td></tr>
<tr><td class="hbar" colspan=5></td></tr>
<tr><td class="c012"> 0</td><td class="c012">100</td><td class="c011">文字列</td><td class="c011"><code>name</code></td><td class="c011">ファイルの名前 </td></tr>
<tr><td class="c012">100</td><td class="c012">8</td><td class="c011">8進</td><td class="c011"><code>perm</code></td><td class="c011">ファイルの権限 </td></tr>
<tr><td class="c012">108</td><td class="c012">8</td><td class="c011">8進</td><td class="c011"><code>uid</code></td><td class="c011">所有ユーザの ID </td></tr>
<tr><td class="c012">116</td><td class="c012">8</td><td class="c011">8進</td><td class="c011"><code>gid</code></td><td class="c011">所有グループの ID </td></tr>
<tr><td class="c012">124</td><td class="c012">12</td><td class="c011">8進</td><td class="c011"><code>size</code></td><td class="c011">ファイルのサイズ (単位はバイト) </td></tr>
<tr><td class="c012">136</td><td class="c012">12</td><td class="c011">8進</td><td class="c011"><code>mtime</code></td><td class="c011">最終更新日</td></tr>
<tr><td class="c012">148</td><td class="c012">8</td><td class="c011">8進</td><td class="c011"><code>checksum</code></td><td class="c011">ヘッダのチェックサム </td></tr>
<tr><td class="c012">156</td><td class="c012">1</td><td class="c011">文字</td><td class="c011"><code>kind</code></td><td class="c011">ファイルの種類 </td></tr>
<tr><td class="c012">157</td><td class="c012">100</td><td class="c011">8進</td><td class="c011"><code>link</code></td><td class="c011">リンク </td></tr>
<tr><td class="c012">257</td><td class="c012">8</td><td class="c011">文字列</td><td class="c011"><code>magic</code></td><td class="c011">シグネチャ (<span class="c002"><code>"ustar\032\032\0"</code></span>)</td></tr>
<tr><td class="c012">265</td><td class="c012">32</td><td class="c011">文字列</td><td class="c011"><code>user</code></td><td class="c011">所有ユーザの名前 </td></tr>
<tr><td class="c012">297</td><td class="c012">32</td><td class="c011">文字列</td><td class="c011"><code>group</code></td><td class="c011">所有グループの名前 </td></tr>
<tr><td class="c012">329</td><td class="c012">8</td><td class="c011">8進</td><td class="c011"><code>major</code></td><td class="c011">周辺機器のメジャー番号 </td></tr>
<tr><td class="c012">337</td><td class="c012">8</td><td class="c011">8進</td><td class="c011"><code>minor</code></td><td class="c011">周辺機器のマイナー番号</td></tr>
<tr><td class="c012">345</td><td class="c012">167</td><td class="c011">&nbsp;</td><td class="c011">&nbsp;</td><td class="c011">パディング <br>
</td></tr>
<tr><td class="hbar" colspan=5></td></tr>
</table>
<div class="flushleft">
<span class="c004"><span style="font-weight:bold">注意</span>  フィールドの長さの単位はバイト。全てのフィールドはヌル文字 <code>'\000'</code> で終わる文字列でエンコードされるが、フィールド <code>kind</code> と <code>size</code> については終端の <code>'\000'</code> は無くても良い。
</span></div>


<a id="fig/tar"></a>
<div class="caption">Table 3 — ヘッダの構造</div></div><p>
ファイルの内容はヘッダのすぐ後ろに保存され、サイズは 512 バイトの倍数まで 0 で拡張されます。レコードの後には別のレコードが続きます。ファイルは最低 20 ブロック (1 ブロックは 512 バイト) を持つように空のブロックでパディングされます。</p><p><code>tar</code> アーカイブは脆い媒体に保存されて何年もしてから読み込まれることを想定しているので、ヘッダが傷ついたことを検出するための <code>checksum</code> フィールドがあります。その値はヘッダ内の全てのバイトの和です (チェックサムを計算するときには <code>checksum</code> フィールド自身は 0 として計算します)。</p><p>ヘッダの <code>kind</code> フィールドはファイルの種類を以下のように 1 バイトにエンコードします<sup><a id="text6" href="#note6">5</a></sup>:
</p><div class="center">
<table class="c000 cellpading0"><tr><td class="c010"><code>'\0'</code> or <code>'0'</code></td><td class="c010"><code>'1'</code></td><td class="c010"><code>'2'</code></td><td class="c010"><code>'3'</code></td><td class="c010"><code>'4'</code></td><td class="c010"><code>'5'</code></td><td class="c010"><code>'6'</code></td><td class="c010"><code>'7'</code></td></tr>
<tr><td class="hbar" colspan=8></td></tr>
<tr><td class="c010"><code>REG</code></td><td class="c010"><code>LINK</code></td><td class="c010"><code>LNK</code></td><td class="c010"><code>CHR</code></td><td class="c010"><code>BLK</code></td><td class="c010"><code>DIR</code></td><td class="c010"><code>FIFO</code></td><td class="c010"><code>CONT</code>
</td></tr>
</table>
</div><p>
ほとんどの場合 <code>kind</code> フィールドの値は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEstats"><span class="c003">stats</span></a> 構造体の <code>st_kind</code> フィールドに保存されているUnix のファイルの種類 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_kind"><span class="c003">file_kind</span></a> に対応します。<code>LINK</code> はアーカイブに保存されたファイルに対するハードリンクを表します。<code>CONT</code> はメモリの連続した領域に保存された通常ファイルを表します (これはいくつかのファイルシステムが持つ機能であり、通常ファイルと同じように扱うことができます)。</p><p>ヘッダの <code>kind</code> フィールドが <code>LINK</code> または <code>LNK</code> のとき、 <code>link</code> フィールドにはリンクの指す先のファイル名が保存されます。<code>kind</code> フィールドが <code>CHR</code> または <code>BLK</code> のとき、<code>major</code> と <code>minor</code> フィールドには周辺機器のメジャー番号とマイナー番号が保存されます。これらのフィールドはそれ以外のとき使用されません。</p><p><code>kind</code> フィールドの値はヴァリアント型によって、 ヘッダはレコードによって自然に表現されます。

</p><div class="mylisting"><span class="c001">type</span> kind =
  | REG | LNK <span class="c001">of</span> string | LINK <span class="c001">of</span> string | CHR <span class="c001">of</span> int * int
  | BLK <span class="c001">of</span> int * int | DIR | FIFO | CONT

<span class="c001">type</span> header =
    { name : string; perm : int; uid : int; gid : int; size : int;
      mtime : int; kind : kind; user : string; group : string }</div>
<!--TOC paragraph id="sec56" ヘッダの読み込み-->
<h5 class="paragraph" id="sec56">ヘッダの読み込み</h5><!--SEC END --><p>
ヘッダの読み込みはあまり面白い処理ではありませんが、無視することもできません。
</p><div class="mylisting"><span class="c001">exception</span> Error <span class="c001">of</span> string * string
<span class="c001">let</span> error err mes = raise (Error (err, mes));;
<span class="c001">let</span> handle_error f s =
  <span class="c001">try</span> f s <span class="c001">with</span>
  | Error (err, mes) -&gt;
      Printf.eprintf <span class="c002">"Error: %s: %s"</span> err mes;
      exit 2

<span class="c001">let</span> substring s offset len =
  <span class="c001">let</span> max_length = min (offset + len + 1) (Bytes.length s) <span class="c001">in
  let rec</span> real_length j =
    <span class="c001">if</span> j &lt; max_length &amp;&amp; s.[j] &lt;&gt; '\000' <span class="c001">then</span> real_length (succ j)
    <span class="c001">else</span> j - offset <span class="c001">in</span>
  Bytes.sub s offset (real_length offset);;

<span class="c001">let</span> integer_of_octal nbytes s offset =
  <span class="c001">let</span> i = int_of_string (<span class="c002">"0o"</span> ^ substring s offset nbytes) <span class="c001">in
  if</span> i &lt; 0 <span class="c001">then</span> error <span class="c002">"Corrupted archive" "integer too large"</span> <span class="c001">else</span> i;;

<span class="c001">let</span> kind s i = <span class="c001">match</span> s.[i] <span class="c001">with</span>
  | '\000' | '0' -&gt; REG
  | '1' -&gt; LINK (substring s (succ i) 99)
  | '2' -&gt; LNK (substring s (succ i) 99)
  | '3' -&gt; CHR (integer_of_octal 8 s 329, integer_of_octal 8 s 329)
  | '4' -&gt; BLK (integer_of_octal 8 s 329, integer_of_octal 8 s 337)
  | '5' -&gt; DIR | '6' -&gt; FIFO | '7' -&gt; CONT
  | _ -&gt; error <span class="c002">"Corrupted archive" "kind"</span>

<span class="c001">let</span> header_of_string s =
  { name = substring s 0 99;
    perm = integer_of_octal 8 s 100;
    uid = integer_of_octal 8 s 108;
    gid = integer_of_octal 8 s 116;
    size = integer_of_octal 12 s 124;
    mtime = integer_of_octal 12 s 136;
    kind = kind s 156;
    user = substring s 265 32;
    group = substring s 297 32; }

<span class="c001">let</span> block_size = 512;;
<span class="c001">let</span> total_size size =
  block_size + ((block_size -1 + size) / block_size) * block_size;;</div><p>アーカイブの終端は本来なら新しいレコードが始まるべき場所にあるファイルの終端か、完全で空のブロックです。そのためヘッダを読み込むときに読むブロックは空なものか完全なものです。そこで <code>really_read</code> を再利用します。アーカイブが壊れていない限り、1 ブロックを読み込もうとしたときにファイルの終端を読むことはありません。

</p><div class="mylisting"><span class="c001">let</span> buffer_size = block_size;;
<span class="c001">let</span> buffer = Bytes.create buffer_size;;

<span class="c001">let</span> end_of_file_error () =
  error <span class="c002">"Corrupted archive" "unexpected end of file"</span>
<span class="c001">let</span> without_end_of_file f x =
  <span class="c001">try</span> f x <span class="c001">with</span> End_of_file -&gt; end_of_file_error ()

<span class="c001">let</span> read_header fd =
  <span class="c001">let</span> len = read fd buffer 0 buffer_size <span class="c001">in
  if</span> len = 0 ||  buffer.[0] = '\000' <span class="c001">then</span> None
  <span class="c001">else begin
    if</span> len &lt; buffer_size <span class="c001">then</span>
      without_end_of_file (really_read fd buffer len) (buffer_size - len);
    Some (header_of_string buffer)
  <span class="c001">end</span>;;</div>
<!--TOC paragraph id="sec57" アーカイブの読み込み-->
<h5 class="paragraph" id="sec57">アーカイブの読み込み</h5><!--SEC END --><p>
アーカイブに操作を行うには、操作の対象を見つけるまでレコードを順に読んでいく必要があります。通常はそれぞれのレコードのヘッダだけを読みこむだけですみますが、前に読み込んだアーカイブに戻ってその内容を読む必要があることもあります。そのような場合のためにそれぞれのレコードごとにそのヘッダとアーカイブ内の位置を記録しておきます。
</p><div class="mylisting"><span class="c001">type</span> record = { header : header; offset : int; descr : file_descr };;</div><p>アーカイブのレコード (ファイルの内容は除く) を読み込んで記録する一般的なイテレータを定義します。イテレータを一般的にするために、蓄積のための関数 <code>f</code> は抽象的なものにしておきます。こうすることでレコードの表示や破壊などの処理にも同じイテレータ関数を使うことができます。
</p><div class="mylisting"><span class="c001">let</span> fold f initial fd  =
  <span class="c001">let rec</span> fold_aux offset accu =
    ignore (without_end_of_file (lseek fd offset) SEEK_SET);
    <span class="c001">match</span> without_end_of_file read_header fd <span class="c001">with</span>
      Some h -&gt;
        <span class="c001">let</span> r =
          { header = h; offset = offset + block_size; descr = fd } <span class="c001">in</span>
        fold_aux (offset + total_size h.size) (f r accu)
    | None -&gt; accu <span class="c001">in</span>
  fold_aux 0 initial;;</div><p><code>fold_aux</code> 関数は処理を <code>offset</code> の位置から開始し、 <code>accu</code> の中に途中経過が含まれています。レコードが始まる位置 <code>offset</code> まで移動し、ヘッダを読み、レコード <code>r</code> を構築し、同じ処理を新しい (より処理の進んだ) 途中結果 <code>f r accu</code> とともにレコードの末尾から行います。この処理はヘッダが無くなるまで、つまりアーカイブの終端に達するまで繰り返されます。</p>
<!--TOC paragraph id="sec58" レコードの名前の表示-->
<h5 class="paragraph" id="sec58">レコードの名前の表示</h5><!--SEC END --><p>
<code>fold</code> 関数の使用例として、レコードの名前を保存すること無く表示する処理を示します:
</p><div class="mylisting"><span class="c001">let</span> list tarfile =
  <span class="c001">let</span> fd = openfile tarfile [ O_RDONLY ] 0o0 <span class="c001">in
  let</span> add r () = print_string r.header.name; print_newline () <span class="c001">in</span>
  fold add () fd;
  close fd</div>
<!--TOC paragraph id="sec59" レコードの内容を表示する-->
<h5 class="paragraph" id="sec59">レコードの内容を表示する</h5><!--SEC END --><p>
コマンド <code>readtar a f</code> はアーカイブの中のファイル <code>f</code> を探索し、もしそれが通常ファイルならばその内容を表示します。<code>f</code> がアーカイブ内のファイル <code>g</code> に対するハードリンクであれば、アーカイブの中では別になっていたとしても本当は二つのファイルは同一なので、そのリンクをたどって <code>g</code> の内容を表示します。<code>g</code> と <code>f</code> のどちらがリンクでどちらがリンク先であるかはアーカイブが作られるときにどちらが先に探索されたかのみに依存します。ここではシンボリックリンクを追うことはしません。</p><p>ハードリンクの解決は以下の相互再帰関数によって行われます:
</p><div class="mylisting"><span class="c001">let rec</span> find_regular r list = <span class="c001">match</span> r.header.kind <span class="c001">with</span>
  | REG | CONT -&gt; r
  | LINK name -&gt; find_file name list
  | _ -&gt; error r.header.name <span class="c002">"Not a regular file"</span>

<span class="c001">and</span> find_file name list = <span class="c001">match</span> list <span class="c001">with</span>
  | r :: rest -&gt;
      <span class="c001">if</span> r.header.name = name <span class="c001">then</span> find_regular r rest
      <span class="c001">else</span> find_file name rest
  | [] -&gt; error name <span class="c002">"Link not found (corrupted archive)"</span>;;</div><p><code>find_regular</code> 関数はレコード <code>r</code> に対応する通常ファイルを探します。<code>r</code> が通常ファイルならば <code>r</code> を返します。<code>r</code> がハードリンクならば <code>find_file</code> 関数を使ってリンクの指すファイルをアーカイブにすでに保存されているレコード <code>list</code> の中から探します。それ以外の場合は関数は失敗します。</p><p>レコードが見つかった場合はその内容を表示します。ディスクリプタをレコードの開始地点に移動させた後は <code>file_copy</code> とよく似た処理になります。
</p><div class="mylisting"><span class="c001">let</span> copy_file file output =
  ignore (lseek file.descr file.offset SEEK_SET);
  <span class="c001">let rec</span> copy_loop len =
    <span class="c001">if</span> len &gt; 0 <span class="c001">then
      match</span> read file.descr buffer 0 (min buffer_size len) <span class="c001">with</span>
      | 0 -&gt; end_of_file_error ()
      | r -&gt; ignore (write output buffer 0 r); copy_loop (len-r) <span class="c001">in</span>
  copy_loop file.header.size</div><p>これらの関数を組み合わせれば完成です:
</p><div class="mylisting"><span class="c001">exception</span> Done
<span class="c001">let</span> find_and_copy tarfile filename =
  <span class="c001">let</span> fd = openfile tarfile [ O_RDONLY ] 0o0 <span class="c001">in
  let</span> found_or_collect r accu =
    <span class="c001">if</span> r.header.name = filename <span class="c001">then begin</span>
      copy_file (find_regular r accu) stdout;
      raise Done
    <span class="c001">end else</span> r :: accu <span class="c001">in
  try</span>
     ignore (fold found_or_collect [] fd);
     error <span class="c002">"File not found"</span> filename
  <span class="c001">with</span>
  | Done -&gt; close fd</div><p>まずターゲットのファイル名が見つかるまでアーカイブのレコード (内容は除く) を読みます。その後 <code>find_regular</code> 関数で実際にそのファイルの内容を含んでいるレコードを探します。この二回目の逆順の探索はアーカイブが矛盾なく作られている限り成功します。しかし一回目の探索はファイルがアーカイブに存在しない場合に失敗するので、処理が失敗した場合でも二つのエラーを区別するようになっています。</p><p><code>readtar</code> コマンドを実装したメイン関数は以下のようになります:

</p><div class="mylisting"><span class="c001">let</span> readtar () =
  <span class="c001">let</span> nargs = Array.length Sys.argv <span class="c001">in
  if</span> nargs = 2 <span class="c001">then</span> list Sys.argv.(1)
  <span class="c001">else if</span> nargs = 3 <span class="c001">then</span> find_and_copy Sys.argv.(1) Sys.argv.(2)
  <span class="c001">else</span>
    prerr_endline (<span class="c002">"Usage: "</span> ^Sys.argv.(0)^ <span class="c002">" &lt;tarfile&gt; [ &lt;source&gt; ]"</span>);;

handle_unix_error (handle_error readtar) ();;</div><div class="exercise">
<!--TOC paragraph id="sec60" 練習問題 7-->
<h5 class="paragraph" id="sec60">練習問題 7</h5><!--SEC END --><p><a id="ex7"></a><a id="ex/readtar"></a>
<code>readtar</code> コマンドを拡張して、シンボリックリンクが指しているファイルがアーカイブ内に存在する場合はそのファイルの内容を表示するようにしてください。
<a href="#exans7">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 7</arg>-->
<!--NAME exercise7.html-->
<div class="answer">
<!--TOC paragraph id="sec61" 練習問題 exercise 7 の解答-->
<h5 class="paragraph" id="sec61">練習問題 <a href="#ex7">exercise 7</a> の解答</h5><!--SEC END --><p>
<a id="exans7"></a>
問題は一見単純なように見えますが、シンボリックリンクはハードリンクと違ってディレクトリを含んだ任意のパスを表すことができ、そのパスがアーカイブの中に存在するとは限らないことから、簡単ではありません。</p><p>シンプルな解決法はアーカイブに含まれるファイル階層をメモリ上に再構築することです。

</p><div class="mylisting"><span class="c001">type</span> info = File | Link <span class="c001">of</span> string list | Dir <span class="c001">of</span> (string * inode) list
<span class="c001">and</span> inode = { <span class="c001">mutable</span> record : record option; <span class="c001">mutable</span> info : info;}</div><p>メモリ上に構築されるファイルシステムのノードは <code>inode</code> 型で表されます。<code>info</code> フィールドが通常ファイルとシンボリックリンクとディレクトリに制限されたファイルの種類を表します。パスは文字列のリストとして、ディレクトリは含まれるファイルの名前とノードの組のリストとして表されます。<code>record</code> フィールドはノードに対応する <code>tar</code> レコードを保持します。中間のディレクトリはアーカイブ内にレコードを持たない場合があるので、このフィールドはオプショナルです。ファイルはアーカイブ内に複数回現れることがあり、最後に現れたものが優先されるので <code>info</code> フィールドは変更可能になっています。
</p><div class="mylisting"><span class="c001">let</span> root () =
  <span class="c001">let rec</span> i =
    { record = None; info = Dir [ Filename.current_dir_name, i ] }
  <span class="c001">in</span> i
<span class="c001">let</span> link inode name nod = <span class="c001">match</span> inode.info <span class="c001">with</span>
  | File | Link _ -&gt; error name <span class="c002">"Not a directory"</span>
  | Dir list -&gt;
      <span class="c001">try let</span> _ = List.assoc name list <span class="c001">in</span> error name <span class="c002">"Already exists"</span>
      <span class="c001">with</span> Not_found -&gt; inode.info &lt;- Dir ((name, nod) :: list)

<span class="c001">let</span> mkfile inode name r =
  <span class="c001">let</span> f =  { record = r; info = File } <span class="c001">in</span>
  link inode name f; f
<span class="c001">let</span> symlink inode name r path =
  <span class="c001">let</span> s =  { record = r; info = Link path } <span class="c001">in</span>
  link inode name s; s
<span class="c001">let</span> mkdir inode name r =
  <span class="c001">let</span> d = mkfile inode name r <span class="c001">in</span>
  d.info &lt;-
    Dir [ Filename.current_dir_name, d; Filename.parent_dir_name, inode ];
  d</div><p>Unix と同様に各ディレクトリは自分自身と親に対するリンクを持ちます。ただしルートディレクトリの親が自分自身となる Unix とは違い、いま考えているファイルシステムではルートディレクトリは親を持ちません。これによってアーカイブの外側のファイルに対するアクセスを検出しやめさせることができます。
</p><div class="mylisting"><span class="c001">let rec</span> find link inode path = <span class="c001">match</span> inode.info, path <span class="c001">with</span>
  | _, [] -&gt; inode
  | Dir list, name :: rest -&gt;
      <span class="c001">let</span> subnode = List.assoc name list <span class="c001">in
      let</span> subnode =
        <span class="c001">match</span> subnode.info <span class="c001">with</span>
          Link q -&gt;
            <span class="c001">if</span> link &amp;&amp; rest = [] <span class="c001">then</span> subnode <span class="c001">else</span> find <span class="c001">false</span> inode q
        | _ -&gt; subnode  <span class="c001">in</span>
      find link subnode rest
  | _, _ -&gt; raise Not_found;;</div><p><code>find</code> 関数はアーカイブから <code>path</code> に対応するノードを <code>inode</code> を始点として探索します。引数 <code>link</code> は探索がリンクを返した場合にリンクそのものを返すべきなのか (<code><span class="c001">true</span></code>) それともリンクが指すファイルを返すべきなのか (<code><span class="c001">false</span></code>) を決めます。
</p><div class="mylisting"><span class="c001">let rec</span> mkpath inode path =
  <span class="c001">match</span> inode.info, path <span class="c001">with</span>
  | _, [] -&gt; inode
  | Dir list, name :: rest -&gt;
      <span class="c001">let</span> subnode =
        <span class="c001">try</span> List.assoc name list
        <span class="c001">with</span> Not_found -&gt;  mkdir inode name None <span class="c001">in</span>
      mkpath subnode rest
  | _, _ -&gt; raise Not_found;;</div><p><code>mkpath</code> 関数はパス <code>path</code> をたどってパス上の存在しないノードを作成します。
</p><div class="mylisting"><span class="c001">let</span> explode f =
  <span class="c001">let rec</span> dec f p =
    <span class="c001">if</span> f = Filename.current_dir_name <span class="c001">then</span> p
    <span class="c001">else</span> dec (Filename.dirname f) (Filename.basename f :: p) <span class="c001">in</span>
  dec (<span class="c001">if</span> Filename.basename f = <span class="c002">""</span> <span class="c001">then</span> Filename.dirname f <span class="c001">else</span> f) [];;</div><p><code>ml</code> 関数は Unix のパスをパースして文字列のリストにします。このときアーカイブでは許されているディレクトリ末尾の “<code>/</code>” を削除します。

</p><div class="mylisting"><span class="c001">let</span> add archive r =
  <span class="c001">match</span> r.header.kind <span class="c001">with</span>
  | CHR (_,_) | BLK (_,_) | FIFO -&gt; ()
  | kind -&gt;
      <span class="c001">match</span> List.rev (explode r.header.name) <span class="c001">with</span>
      | []  -&gt; ()
      | name :: parent_rev -&gt;
          <span class="c001">let</span> inode = mkpath archive (List.rev parent_rev) <span class="c001">in
          match</span> kind <span class="c001">with</span>
          | DIR -&gt; ignore (mkdir inode name (Some r))
          | REG | CONT -&gt; ignore (mkfile inode name (Some r))
          | LNK f -&gt; ignore (symlink inode name (Some r) (explode f))
          | LINK f -&gt; link inode name (find <span class="c001">true</span> archive (explode f))
          | _ -&gt; <span class="c001">assert false</span>;;</div><p><code>add</code> 関数はレコード <code>r</code> をアーカイブに追加します。ルートノードで表されるアーカイブは副作用で変更されます。
</p><div class="mylisting"><span class="c001">let</span> find_and_copy tarfile filename =
  <span class="c001">let</span> fd = openfile tarfile [ O_RDONLY ] 0 <span class="c001">in
  let</span> records = List.rev (fold (<span class="c001">fun</span> x y -&gt; x :: y) [] fd) <span class="c001">in
  let</span> archive = root () <span class="c001">in</span>
  List.iter (add archive) records;
  <span class="c001">let</span> inode =
    <span class="c001">try</span> find <span class="c001">false</span> archive (explode filename)
    <span class="c001">with</span> Not_found -&gt; error filename <span class="c002">"File not found"</span> <span class="c001">in
  begin match</span> inode.record <span class="c001">with</span>
  | Some ({ header = { kind = (REG | CONT) }} <span class="c001">as</span> r) -&gt; copy_file r stdout
  | Some _ -&gt; error filename <span class="c002">"Not a regular file"</span>
  | None -&gt; error filename <span class="c002">"Not found"</span>
  <span class="c001">end</span>;
  close fd;;</div><p>最後はこれまでと同じです。
</p><div class="mylisting"><span class="c001">let</span> readtar () =
  <span class="c001">let</span> nargs = Array.length Sys.argv <span class="c001">in
  if</span> nargs = 2 <span class="c001">then</span> list Sys.argv.(1)
  <span class="c001">else if</span> nargs = 3 <span class="c001">then</span> find_and_copy Sys.argv.(1) Sys.argv.(2)
  <span class="c001">else</span> prerr_endline (<span class="c002">"Usage: "</span> ^Sys.argv.(0)^ <span class="c002">" &lt;tarfile&gt; [ &lt;source&gt; ]"</span>);;

Printexc.print (handle_unix_error (handle_error readtar)) ();;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id="sec62" 練習問題 8-->
<h5 class="paragraph" id="sec62">練習問題 8</h5><!--SEC END --><p><a id="ex8"></a><a id="ex/untar"></a>
<code>untar a</code> がアーカイブ <code>a</code> の全てのファイル (スペシャルファイルを除く) を抽出し新しいディレクトリとして作成するようなコマンド <code>untar</code> を作成してください。ファイルについての情報 (所有者、権限) は可能ならばアーカイブのものを復元してください。</p><p>ファイル階層は <code>untar</code> コマンドが実行されたディレクトリに再構築されるべきです。コマンドが現在のワーキングディレクトリのサブディレクトリではない場所に書き込むことは許されません。アーカイブにレコードが無いディレクトリはユーザのデフォルト権限で作られるようにしてください。
<a href="#exans8">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 8</arg>-->
<!--NAME exercise8.html-->
<div class="answer">
<!--TOC paragraph id="sec63" 練習問題 exercise 8 の解答-->
<h5 class="paragraph" id="sec63">練習問題 <a href="#ex8">exercise 8</a> の解答</h5><!--SEC END --><p>
<a id="exans8"></a>
この練習問題では一つ前の練習問題 <a href="#ex%2Freadtar">2.16</a>と再帰的なファイルのコピーについての練習問題 <a href="#ex%2Fcopyrec">2.15</a> を組み合わせます。</p><p>すこし難しい部分は権限の管理です。アーカイブのディレクトリを書き込み権限で作成して全てのファイルを抽出し終わってから本来の権限に設定しなければいけません。</p><p>最初に補助関数 <code>mkpath p m</code> を書きます。この関数はパス <code>p</code> に含まれるディレクトリでまだ作成されていないものを、 <code>m</code> の権限で作成します。<code>p</code> の最後には余分な “<code>/</code>” が含まれていても構いません。

</p><div class="mylisting"><span class="c001">let</span> warning mes = prerr_string mes;prerr_newline ();;
<span class="c001">open</span> Filename
<span class="c001">let</span> mkpath p perm =
  <span class="c001">let</span> normal_path =
    <span class="c001">if</span> basename p = <span class="c002">""</span> <span class="c001">then</span> dirname p <span class="c001">else</span> p <span class="c001">in
  let</span> path_to_dir = dirname normal_path <span class="c001">in
  let rec</span> make p =
    <span class="c001">try</span> ignore (stat p)
    <span class="c001">with</span> Unix_error (ENOENT, _, _) -&gt;
      <span class="c001">if</span> p = current_dir_name <span class="c001">then</span> ()
      <span class="c001">else if</span> p = parent_dir_name <span class="c001">then</span>
        warning <span class="c002">"Ill formed archive: path contains \"..\""</span>
      <span class="c001">else begin</span>
        make (dirname p);
        mkdir p perm
      <span class="c001">end in</span>
  make path_to_dir;;</div><p><a href="#sec%2Fcopyrec">2.15</a> 節でファイルをコピーするときに利用したものと似た<code>set_infos</code> を定義します。
</p><div class="mylisting"><span class="c001">let</span> set_infos header =
  chmod header.name header.perm;
  <span class="c001">let</span> mtime = float header.mtime <span class="c001">in</span>
  utimes header.name mtime mtime;
  <span class="c001">begin match</span> header.kind <span class="c001">with</span>
  | LNK f -&gt; ()
  | _ -&gt;  chmod header.name header.perm
  <span class="c001">end</span>;
  <span class="c001">try</span> chown header.name  header.uid header.gid
  <span class="c001">with</span> Unix_error(EPERM,_,_) -&gt; ();;</div><p><code>untar_file_collect_dirs</code> は作成されるディレクトリを記録しながら一つのレコードをコピーします。
</p><div class="mylisting"><span class="c001">let</span> verbose = <span class="c001">ref true</span>;;
<span class="c001">let</span> default_dir_perm = 0o777;;
<span class="c001">let</span> default_file_perm = 0o666;;

<span class="c001">let</span> protect f x g y = <span class="c001">try</span> f x; g y <span class="c001">with</span> z -&gt; g y; raise z
<span class="c001">let</span> file_exists f = <span class="c001">try</span> ignore (stat f); <span class="c001">true with</span> _ -&gt; <span class="c001">false</span>;;

<span class="c001">let</span> untar_file_collect_dirs file dirs =
  <span class="c001">let</span> fh = file.header <span class="c001">in
  if</span> !verbose <span class="c001">then begin</span> print_string fh.name; print_newline () <span class="c001">end</span>;
  <span class="c001">match</span> fh.kind <span class="c001">with</span>
  | CHR (_,_) | BLK(_,_) | FIFO -&gt;
      warning (fh.name ^ <span class="c002">"Ignoring special files"</span>);
      dirs
  | DIR -&gt;
      mkpath fh.name default_dir_perm;
      <span class="c001">if</span> file_exists fh.name <span class="c001">then</span> dirs
      <span class="c001">else begin</span> mkdir fh.name default_dir_perm; fh :: dirs <span class="c001">end</span>
  | x -&gt;
      mkpath fh.name default_dir_perm;
      <span class="c001">begin match</span> x <span class="c001">with</span>
      | REG | CONT -&gt;
          <span class="c001">let</span> flags = [ O_WRONLY; O_TRUNC; O_CREAT; ] <span class="c001">in
          let</span> out = openfile fh.name flags default_file_perm <span class="c001">in</span>
          protect (copy_file file) out close out
      | LNK f -&gt;
          symlink f fh.name
      | LINK f -&gt;
          <span class="c001">begin
            try if</span> (stat fh.name).st_kind = S_REG <span class="c001">then</span> unlink fh.name
            <span class="c001">with</span> Unix_error(_,_,_) -&gt; ();
          <span class="c001">end</span>;
          Unix.link f fh.name;
      | _ -&gt; <span class="c001">assert false
      end</span>;
      set_infos fh;
      dirs;;</div><p>メインプログラムは <code>untar_file_collect_dirs</code> を全てのレコードに適用し、最後にディレクトリのアクセス権限を修正するだけです。
</p><div class="mylisting"><span class="c001">let</span> extract tarfile =
  <span class="c001">let</span> fd = openfile tarfile [ O_RDONLY ] 0 <span class="c001">in
  let</span> new_directories =
    fold untar_file_collect_dirs [] fd <span class="c001">in</span>
  List.iter set_infos new_directories;
  close fd;;</div><div class="mylisting"><span class="c001">let</span> untar () =
  <span class="c001">let</span> nargs = Array.length Sys.argv <span class="c001">in
  if</span> nargs = 2 <span class="c001">then</span> extract Sys.argv.(1)
  <span class="c001">else</span> prerr_endline (<span class="c002">"Usage: "</span> ^ Sys.argv.(0) ^ <span class="c002">" &lt;tarfile&gt;"</span>);;
handle_unix_error untar ();;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id="sec64" 練習問題 9-->
<h5 class="paragraph" id="sec64">練習問題 9</h5><!--SEC END --><p><a id="ex9"></a>
<a id="ex/maketar"></a>
<code>tar -xvf a f1 f2 ...</code> が <code>f1</code>, <code>f2</code> ... とそのサブディレクトリを含むアーカイブ <code>a</code> を作成するようなコマンド <code>tar</code> を書いてください。
<a href="#exans9">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 9</arg>-->
<!--NAME exercise9.html-->
<div class="answer">
<!--TOC paragraph id="sec65" 練習問題 exercise 9 の解答-->
<h5 class="paragraph" id="sec65">練習問題 <a href="#ex9">exercise 9</a> の解答</h5><!--SEC END --><p>
<a id="exans9"></a>
一つ前の練習問題で定義したデータ構造を再利用するために <code>Tarlib</code> モジュールに集めておきます。プログラムを停止したりプログラムの返り値を変更したりせずに警告を表示する関数を定義します。
</p><div class="mylisting"><span class="c001">open</span> Sys
<span class="c001">open</span> Unix
<span class="c001">open</span> Tarlib

<span class="c001">let</span> warning path message =  prerr_endline (path ^ <span class="c002">": "</span> ^ message)</div><p>レコードのヘッダをバッファに書き込む関数から始めます。処理は退屈ですが、ヘッダがおかしいとアーカイブ全体が読み込めなくなるので慎重になる必要があります。特にファイルのフォーマットによる制限には注意が必要です。例えばパスの長さは 99 バイトに制限されています(これより長いパスを扱えるようにするフォーマットの拡張もありますが、この練習問題では取り扱いません)。
</p><div class="mylisting"><span class="c001">let</span> write_header_to_buffer source infos kind =
  <span class="c001">let</span> size = <span class="c001">if</span> kind = REG <span class="c001">then</span> infos.st_size <span class="c001">else</span> 0 <span class="c001">in</span>
  Bytes.fill buffer 0 block_size '\000';
  <span class="c001">let</span> put len string offset =
    Bytes.blit string 0 buffer offset (min (Bytes.length string) len) <span class="c001">in
  let</span> put_int8 x = put 7 (Printf.sprintf <span class="c002">"%07o"</span> x) <span class="c001">in
  let</span> put_int12 x = put 11 (Printf.sprintf <span class="c002">"%011o"</span> x) <span class="c001">in
  let</span> put_char c offset = buffer.[offset] &lt;- c <span class="c001">in
  let</span> put_path s offset =
    <span class="c001">if</span> Bytes.length s &lt;= 99 <span class="c001">then</span> put 99 s offset
    <span class="c001">else</span> raise (Error (<span class="c002">"path too long"</span>, s)) <span class="c001">in</span>
  put_path (<span class="c001">if</span> kind = DIR <span class="c001">then</span> source ^ <span class="c002">"/"</span> <span class="c001">else</span> source) 0;
  put_int8 infos.st_perm 100;
  put_int8 infos.st_uid 108;
  put_int8 infos.st_gid 116;
  put_int12 size 124;
  put_int12 (int_of_float infos.st_mtime) 136;
  put 7 <span class="c002">"ustar  "</span> 257;
  put 31 (getpwuid infos.st_uid).pw_name 265;
  put 31 (getgrgid infos.st_gid).gr_name 297;
  <em>(* Fields dev and rdev are only used for special files, which we omit *)</em>
  put_char
    <span class="c001">begin match</span> kind <span class="c001">with</span>
    | REG -&gt; '0'
    | LINK s -&gt; put_path s 157; '1'
    | LNK s -&gt;  put_path s 157; '2'
    | DIR -&gt; '5'
    | _ -&gt; failwith <span class="c002">"Special files not implemented"</span>
    <span class="c001">end</span> 156;
  <span class="c001">let rec</span> sum s i =
    <span class="c001">if</span> i &lt; 0 <span class="c001">then</span> s <span class="c001">else</span> sum (s + Char.code buffer.[i]) (pred i) <span class="c001">in
  let</span> checksum = sum (Char.code ' ' * 8) (block_size - 1)  <span class="c001">in</span>
  put 8 (Printf.sprintf <span class="c002">"%06o\000 "</span> checksum) 148;;</div><p>次の関数はファイルに対するレコードのバッファを作成します。<code>source</code> はファイルの名前、 <code>infos</code> は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEstats"><span class="c003">stats</span></a> で取得できるファイルの情報、 <code>kind</code> はファイルの種類です。
</p><div class="mylisting"><span class="c001">let</span> header source infos kind = {
  name = source;
  size = <span class="c001">if</span> kind = REG <span class="c001">then</span> infos.st_size <span class="c001">else</span> 0;
  perm = infos.st_perm;
  mtime = int_of_float infos.st_mtime;
  uid = infos.st_uid;
  gid = infos.st_gid;
  user = (getpwuid infos.st_uid).pw_name;
  group = (getgrgid infos.st_gid).gr_name;
  kind = kind }</div><p>アーカイブにファイルの内容を書き込むために、 <code>file_copy</code> に似た関数を定義します。この関数は引数としてコピーされるバイト数を受け取り、ファイルの末尾がそのサイズと対応していることを確認します。受け取ったバイト数だけ書き込んだ結果ファイルの末尾に到達しなかった場合、エラーを出します。これによってアーカイブ中にファイルが変更されるケースに対応できます。アーカイブの欠損を一つのファイルに抑えるために、引数で受け取ったバイト数を超えて書き込むことはしません。
</p><div class="mylisting"><span class="c001">let</span> write_file len source fdout =
  <span class="c001">let</span> fdin = openfile source [O_RDONLY] 0 <span class="c001">in
  let</span> error () = raise (Error (<span class="c002">"File changed size"</span>, source)) <span class="c001">in
  let rec</span> copy_loop len =
    <span class="c001">match</span> read fdin buffer 0 buffer_size <span class="c001">with</span>
      0 -&gt;
        close fdin; <span class="c001">if</span> len &gt; 0 <span class="c001">then</span> error ()
    | r -&gt;
        <span class="c001">let</span> len = len - r  <span class="c001">in
        if</span> len &lt; 0 <span class="c001">then</span> (close fdin; error ());
        ignore (write fdout buffer 0 r); copy_loop len <span class="c001">in</span>
  copy_loop len;;

<span class="c001">let</span> padding fd len =
  <span class="c001">if</span> len &gt; 0 <span class="c001">then</span> ignore (write fd (Bytes.make len '\000') 0 len);;</div><p>ここからがアーカイブの作成になります。アーカイブに書き込まれたファイルはそのパスと共にハッシュテーブルに保存され、同じファイルが何度もコピーされることが無いように利用されます。またファイルだけではなくディレクトリについてもすでに書き込んだパスをハッシュテーブルを保存します。アーカイブのルートが他のディレクトリに含まれることがありえますが、そのような場合にコピーを行わないようにするためです (ただしコピーをしても問題はありません)。</p><p>アーカイブを書き込むのに必要となるのは書き込みファイルを指すファイルディスクリプタとファイルとディレクトリのキャッシュ (一つ前の練習問題参照)、 そして現在のアーカイブのサイズを記録する変数 (必要な場合に最小サイズにパディングするため) です。<code>archive</code> 型がこれらの情報を保持するレコードです:
</p><div class="mylisting"><span class="c001">type</span> archive =
    { regfiles : (int * int, string) Hashtbl.t;
      dirfiles : (int * int, bool) Hashtbl.t;
      fd : file_descr; st : stats; <span class="c001">mutable</span> size : int }

<span class="c001">let</span> try_new_dir archive dir =
  <span class="c001">try</span> Hashtbl.find archive.dirfiles dir
  <span class="c001">with</span> Not_found -&gt; Hashtbl.add archive.dirfiles dir <span class="c001">false</span>; <span class="c001">true</span></div><p>コマンドラインで与えられるパス <code>file</code> から始まるファイル階層全体を書き込む関数は以下のようになります。この関数は難しくありませんが、いくつか例外的なケースがあります。例えばファイルがアーカイブ中に変更されたことを検出する方法については前に示しました。このケースの特別な場合は、アーカイブがアーカイブ自身をアーカイブしようとしている場合です。
</p><div class="mylisting"><span class="c001">let</span> verbose = <span class="c001">ref true</span>;;

<span class="c001">let</span> write_from archive file =
  <span class="c001">if</span> not (Filename.is_relative file) <span class="c001">then</span>
    raise (Error (<span class="c002">"absolute path"</span>, file));
  <span class="c001">let rec</span> write_rec archive file =
    <span class="c001">let</span> source =
      <span class="c001">if</span> Filename.basename file = <span class="c002">""</span> <span class="c001">then</span> Filename.dirname file <span class="c001">else</span> file <span class="c001">in
    if</span> !verbose <span class="c001">then begin</span> prerr_endline source <span class="c001">end</span>;
    <span class="c001">let</span> st = lstat source <span class="c001">in
    if</span> st.st_ino = archive.st.st_ino &amp;&amp; st.st_dev = archive.st.st_dev
    <span class="c001">then</span> warning source <span class="c002">"Skipping archive itself!"</span>
    <span class="c001">else
      let</span> write_header kind =
        write_header_to_buffer source st kind;
        ignore (write archive.fd buffer 0 block_size) <span class="c001">in
      match</span> st.st_kind <span class="c001">with</span>
        S_REG -&gt;
          <span class="c001">begin try
            if</span> st.st_nlink = 1 <span class="c001">then</span> raise Not_found;
            <span class="c001">let</span> path =
              Hashtbl.find archive.regfiles (st.st_ino, st.st_dev) <span class="c001">in</span>
            write_header (LINK path);
          <span class="c001">with</span> Not_found -&gt;
            <span class="c001">if</span> st.st_nlink &gt; 1 <span class="c001">then</span>
              Hashtbl.add archive.regfiles (st.st_ino, st.st_dev) source;
            write_header REG;
            write_file st.st_size source archive.fd;
            <span class="c001">let</span> t =
              (block_size-1 + st.st_size) / block_size * block_size <span class="c001">in</span>
            padding archive.fd (t - st.st_size);
            archive.size &lt;- archive.size + t + block_size;
          <span class="c001">end</span>
      | S_LNK -&gt;
          write_header (LNK (readlink source));
      | S_DIR <span class="c001">when</span> try_new_dir archive (st.st_ino, st.st_dev) -&gt;
          write_header DIR;
          Misc.iter_dir
            <span class="c001">begin
              fun</span> file -&gt;
                <span class="c001">if</span> file = Filename.current_dir_name <span class="c001">then</span> ()
                <span class="c001">else if</span> file = Filename.parent_dir_name <span class="c001">then</span> ()
                <span class="c001">else</span> write_rec archive (source ^ <span class="c002">"/"</span> ^ file)
            <span class="c001">end</span>
            source
      | S_DIR -&gt;
          warning source <span class="c002">"Ignoring directory already in archive."</span>
      | _ -&gt;
          prerr_endline (<span class="c002">"Can't cope with special file "</span> ^ source) <span class="c001">in</span>
  write_rec archive file;;</div><p>ハードリンクを持つ可能性がある通常ファイルをハッシュテーブル <code>regfile</code> に記録します。リンクを一つしか持たないファイルは記録する必要がありません。</p><p>メイン関数は以下のようになります。エラーが出た場合には、アーカイブを削除したほうが良いでしょう。
</p><div class="mylisting"><span class="c001">let</span> min_archive_size = 20 * block_size;;

<span class="c001">let</span> build tarfile files =
  <span class="c001">let</span> fd, remove =
    <span class="c001">if</span> tarfile = <span class="c002">"-"</span> <span class="c001">then</span> stdout, ignore
    <span class="c001">else</span> openfile tarfile [ O_WRONLY; O_CREAT; O_TRUNC ] 0o666, unlink <span class="c001">in
  try
    let</span> arch =
         { regfiles = Hashtbl.create 13; dirfiles = Hashtbl.create 13;
           st = fstat fd; fd = fd; size =0 } <span class="c001">in</span>
    Array.iter (write_from arch) files;
    padding fd (min_archive_size - arch.size);
    close fd
  <span class="c001">with</span> z -&gt;
    remove tarfile; close fd; raise z;;</div><p>最後にコマンドライン引数をパースする処理を書いて練習問題を終わります。
</p><div class="mylisting"><span class="c001">let</span> usage () =
  prerr_endline <span class="c002">"Usage: tar -cvf tarfile file1 [ file2 ... ] "</span>;
  exit 2;;

<span class="c001">let</span> tar () =
  <span class="c001">let</span> argn = Array.length Sys.argv <span class="c001">in
  if</span> argn &gt; 3 &amp;&amp; Sys.argv.(1) = <span class="c002">"-cvf"</span> <span class="c001">then</span>
    build Sys.argv.(2) (Array.sub Sys.argv 3 (argn-3))
  <span class="c001">else</span> usage ();;

<span class="c001">let</span> _ =
  <span class="c001">try</span> handle_unix_error tar ()
  <span class="c001">with</span> Error (mes, s) -&gt;
    prerr_endline (<span class="c002">"Error: "</span> ^ mes ^ <span class="c002">": "</span> ^ s); exit 1;;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note2" href="#text2">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">ロックファイルが NFS パーティションに存在している場合はこれは不可能です。 NFS が <code><span class="c001">open</span></code> に対する <code>O_CREAT</code> を実装していないためです。</div></dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">訳注: バージョン4.02 以降の OCamlでは、変更可能なバッファとして使われる文字列の型は <code>string</code> ではなく <code>bytes</code> となります。</div></dd><dt class="dt-thefootnotes"><a id="note4" href="#text4">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">実際には OCamlはデータ転送を (現在のバージョンでは) 16KB に制限し全体の転送が終わるまで <code>write</code> システムコールを繰り返します — セクション <a href="#single_write">5.7</a> 参照。しかしこの制限はシステムのキャッシュサイズよりも大きいので無視できます。</div></dd><dt class="dt-thefootnotes"><a id="note5" href="#text5">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Case ライブラリ [<a href="#Cash">3</a>] にはこのような関数が含まれます。</div></dd><dt class="dt-thefootnotes"><a id="note6" href="#text6">5</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">このフィールドは他のフィールドの値が大きすぎて予約されたサイズより大きくなった場合や、 <code>tar</code> フォーマットの拡張などの例外的なケースをエンコードするための値も取ります。</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec/processes" プロセス-->
<h1 class="chapter" id="sec/processes"> 3  プロセス</h1><!--SEC END --><!--NAME processes.html-->
<p>プロセスとはオペレーティングシステム上で実行されるプログラムのことです。プロセスはプログラム (機械語) とその状態 (現在の実行位置、変数の値、関数呼び出しスタック、開いているファイルディスクリプタなど) からなります。</p><p>この章では新しいプロセスを作ったり新しいプログラムを実行したりするための Unix のシステムコールを紹介します。</p>
<!--TOC section id="sec67" プロセスの作成-->
<h2 class="section" id="sec67">3.1  プロセスの作成</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fork.html"><span class="c003">fork</span></a><a id="hevea_default68"></a> はプロセスを作成します。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfork">fork</a> : unit -&gt; int</div><p><code>fork</code> を呼び出した <em>親プロセス</em> のほぼ完璧な複製である <em>子プロセス</em> が新しく作られます。二つのプログラムは同じプログラムを同じ実行位置 (<code>fork</code> から返った位置) から実行します。このとき全ての変数は同じ値を持ち、スタックは同一で、開かれているファイルディスクリプタも同じです。二つのプロセスを区別する唯一のものは <code>fork</code> の返り値です。子プロセスでは <code>fork</code> は 0 を返し、 親プロセスでは 0 でない整数を返します。<code>fork</code> の返り値を確認することで、プログラムは自分が親なのか子なのかを確認してそれによって動作を変えることができます。
</p><div class="mylisting"><span class="c001">match</span> fork () <span class="c001">with</span>
| 0 -&gt;   <em>(* 子プロセスだけが実行するコード *)</em>
| pid -&gt; <em>(* 親プロセスだけが実行するコード *)</em></div><p><code>fork</code> によって親プロセスに返される 0 でない整数は子プロセスの <em>プロセス ID</em> です。カーネルはプロセス IDを使ってプロセスを一意に識別します。プロセスは <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetpid"><span class="c003">getpid</span></a><a id="hevea_default69"></a> 関数を呼ぶことでプロセス ID を取得できます。</p><p>子プロセスは親プロセスと同じ状態 (同じ変数の値、同じファイルディスクリプタ) に初期化されます。この状態は親と子で共有されるのではなく、 <code>fork</code> が呼ばれたときにコピーされます。例えば <code>fork</code> の前に定義した参照変数があった場合、 <code>fork</code> の後には親と子プロセスはこの参照を互いに影響を及ぼすこと無く独立に変更できます。</p><p>同様にファイルディスクリプタも <code>fork</code> が呼ばれたときにコピーされます。そのため一方を閉じたとしてももう一方は開いたままです。ただし二つのディスクリプタは (システムメモリにある) ファイルテーブル内の同じエントリを指すので、入出力の現在位置を共有します。親と子のどちらかが読み込みを行った場合、その次に読み込むのがどちらであっても読み込み位置は変化します。また <code>lseek</code> による入出力位置の変更はもう一方のプロセスにすぐに伝わります。</p>
<!--TOC section id="sec68" 完全な例: <span class="c003">leave</span> コマンド-->
<h2 class="section" id="sec68">3.2  完全な例: <span class="c003">leave</span> コマンド</h2><!--SEC END --><p><code>leave hhmm</code> コマンドは時刻 <code>hhmm</code> に利用を終える時間だとユーザに報告するバックグラウンドプロセスをフォークしてすぐに終了します。このコマンドを作成します。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Unix;;
<span class="c005">   2</span> 
<span class="c005">   3</span> <span class="c001">let</span> leave () =
<span class="c005">   4</span>  <span class="c001">let</span> hh = int_of_string (String.sub Sys.argv.(1) 0 2)
<span class="c005">   5</span>  <span class="c001">and</span> mm = int_of_string (String.sub Sys.argv.(1) 2 2) <span class="c001">in</span>
<span class="c005">   6</span>  <span class="c001">let</span> now = localtime(time ()) <span class="c001">in</span>
<span class="c005">   7</span>  <span class="c001">let</span> delay = (hh - now.tm_hour) * 3600 + (mm - now.tm_min) * 60 <span class="c001">in</span>
<span class="c005">   8</span> <a id="prog:delay"></a>
<span class="c005">   9</span>  <span class="c001">if</span> delay &lt;= 0 <span class="c001">then begin</span>
<span class="c005">  10</span>    print_endline <span class="c002">"Hey! That time has already passed!"</span>;
<span class="c005">  11</span>    exit 0
<span class="c005">  12</span>  <span class="c001">end</span>;
<span class="c005">  13</span>  <span class="c001">if</span> fork () &lt;&gt; 0 <span class="c001">then</span> exit 0;
<span class="c005">  14</span>  sleep delay;
<span class="c005">  15</span>  print_endline <span class="c002">"\007\007\007Time to leave!"</span>;
<span class="c005">  16</span>  exit 0;;
<span class="c005">  17</span> 
<span class="c005">  18</span> handle_unix_error leave ();;</div><p>プログラムは最初にコマンドラインをパースして時刻を取得し、報告するまでの秒数を計算します (<a href="#prog%3Adelay">8</a> 行目) 。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtime"><span class="c003">time</span></a><a id="hevea_default70"></a> 関数はエポック (1970 年 1 月 1 日 午前 0 時 0 分 0 秒) から現在時刻までの経過秒数を返します。 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlocaltime"><span class="c003">localtime</span></a><a id="hevea_default71"></a> を使うとこの値から年、月、日、時、分、秒を計算することができます。プログラムはその後 <code>fork</code> で新しいプロセスを作ります。親プロセス (<code>fork</code> の返り値が 0 でないプロセス) はすぐに終了するため、<code>leave</code> を起動したシェルの制御はすぐにユーザに戻ります。子プロセス (<code>fork</code> の返り値が 0 のプロセス) の実行は続き、<code>sleep</code> を呼んで指定された時間まで待ってからメッセージを表示して終了します。</p>
<!--TOC section id="sec69" プロセスの終了を待つ-->
<h2 class="section" id="sec69">3.3  プロセスの終了を待つ</h2><!--SEC END --><p>システムコール <code>wait</code> は <code>fork</code> によって作られた子プロセスの一つが終了するまで待ち、そのプロセスがどのように終了したかについての情報を返します。これは親子間の同期メカニズムであり、子から親へのとても原始的な形のコミュニケーションです。
<a id="wait"></a>

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwait">wait</a><a id="hevea_default72"></a> : unit -&gt; int * process_status
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwaitpid">waitpid</a> : wait_flag list -&gt; int -&gt; int * process_status</div><p>基礎となるシステムコールは <a href="http://www.opengroup.org/onlinepubs/009696799/functions/waitpid.html"><span class="c003">waitpid</span></a><a id="hevea_default73"></a> であり、 <code>wait ()</code> という呼び出しは <code>waitpid [] (-1)</code> の短縮形に過ぎません。
<code>waitpid [] p</code> の動作は <code>p</code> の値によって異なります。
</p><ul class="itemize"><li class="li-itemize">
<code>p</code> &gt; 0 ならば、プロセス ID が <code>p</code> である子プロセスの終了を待つ。
</li><li class="li-itemize"><code>p</code> = 0 ならば、同じグループ ID を持つ任意の子プロセスの終了を待つ。
</li><li class="li-itemize"><code>p</code> = −1 ならば、任意の子プロセスの終了を待つ。
</li><li class="li-itemize"><code>p</code> &lt;−1 ならば、グループ ID が <code>-p</code> である子プロセスの終了を待つ。
</li></ul><p>
返り値の最初の要素は <code>wait</code> によって終了を捕捉された子プロセスのプロセス ID です。2番目の要素は以下に示す <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEprocess_status"><span class="c003">process_status</span></a> 型の値です:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c014"><code>WEXITED r</code></td><td class="c013">子プロセスは <code>exit</code> が呼ばれるかプログラムの終端に達することによって通常の方法で終了した。<code>r</code> はリターンコード (<code>exit</code> の引数) を表す。 </td></tr>
<tr><td class="c014"><code>WSIGNALED s</code></td><td class="c013">子プロセスはシグナル (ctrl+C, <code>kill</code> など。 <a href="#sec%2Fsignals">4</a> 章参照) によって終了した。<code>s</code> がシグナルの種類を表す。 </td></tr>
<tr><td class="c014"><code>WSTOPPED s</code></td><td class="c013">子プロセスはシグナル <code>s</code> によって停止された。これが起こるのはあるプロセス (典型的にはデバッガ) が他のプロセスの実行を (<code>ptrace</code> を使って) モニターしているという特殊なケースに限られる。
</td></tr>
</table>
</div><p>
子プロセスの一つが <code>wait</code> を呼んだ時点ですでに終了していた場合は呼び出しはすぐに返ります。そうでなければ親プロセスは子プロセスのどれかが終了するまでブロックします (“ランデブー” と呼ばれる動作です)。この子プロセスの終了を待つには <code>wait</code> を <span class="c006">n</span> 回呼ぶ必要があります。</p><p><code>waitpid</code> 関数は二つのオプショナルなフラグを第一引数に受け取ります。一つ目の <code>WNOHANG</code> フラグは終了していない子プロセスが無い場合に待たないことを指示します。子プロセスが無かった場合の返り値は第一要素が 0 で第二要素は未定義です。もう一つの <code>WUNTRACED</code> フラグは <code>sigstop</code> シグナルによって停止させられた子プロセスを返すことを指示します。<code>waitpid</code> は <code>p</code> に該当する子プロセスがないとき(あるいは <code>p</code> が <code>-1</code> で現在のプロセスが子プロセスを持たないとき)には例外を出します。
</p><div class="example">
<!--TOC paragraph id="sec70" 例-->
<h5 class="paragraph" id="sec70">例</h5><!--SEC END --><p>
<a id="ex/forksearch"></a>
以下の <code>fork_search</code> 関数は二つのプロセスを使って線形探索を行います。線形探索には <code>simple_search</code> 関数を使っています。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Unix;;
<span class="c005">   2</span> <span class="c001">exception</span> Found;;
<span class="c005">   3</span> 
<span class="c005">   4</span> <span class="c001">let</span> simple_search cond v =
<span class="c005">   5</span>  <span class="c001">try</span>
<span class="c005">   6</span>    <span class="c001">for</span> i = 0 <span class="c001">to</span> Array.length v - 1 <span class="c001">do</span>
<span class="c005">   7</span>      <span class="c001">if</span> cond v.(i) <span class="c001">then</span> raise Found
<span class="c005">   8</span>    <span class="c001">done</span>;
<span class="c005">   9</span>    <span class="c001">false</span>
<span class="c005">  10</span>  <span class="c001">with</span> Found -&gt; <span class="c001">true</span>;;
<span class="c005">  11</span> 
<span class="c005">  12</span> <span class="c001">let</span> fork_search cond v =
<span class="c005">  13</span>  <span class="c001">let</span> n = Array.length v <span class="c001">in</span>
<span class="c005">  14</span>  <span class="c001">match</span> fork () <span class="c001">with</span>
<span class="c005">  15</span>  | 0 -&gt;
<span class="c005">  16</span>      <span class="c001">let</span> found = simple_search cond (Array.sub v (n/2) (n-n/2)) <span class="c001">in</span> <a id="prog:found"></a>
<span class="c005">  17</span>      exit (<span class="c001">if</span> found <span class="c001">then</span> 0 <span class="c001">else</span> 1) <a id="prog:searchexit"></a>
<span class="c005">  18</span>  | _ -&gt;
<span class="c005">  19</span>      <span class="c001">let</span> found = simple_search cond (Array.sub v 0 (n/2)) <span class="c001">in</span>
<span class="c005">  20</span>      <span class="c001">match</span> wait () <span class="c001">with</span>
<span class="c005">  21</span>      | (pid, WEXITED retcode) -&gt; found || (retcode = 0) <a id="prog:wexit"></a>
<span class="c005">  22</span>      | (pid, _)               -&gt; failwith <span class="c002">"fork_search"</span>;;<a id="prog:wwexit"></a></div><p><code>fork</code> された子プロセスはテーブルの上半分を探索し、 <code>cond</code> を満たす要素を見つけた場合は 1 を、それ以外の場合は 0 をリターンコードとして終了します ( <a href="#prog%3Afound">16</a> 行目と <a href="#prog%3Asearchexit">17</a> 行目)。親プロセスはテーブルの下半分を探索し、 <code>wait</code> を呼んで子プロセスと同期します ( <a href="#prog%3Awexit">21</a> 行目と <a href="#prog%3Awwexit">22</a>行目)。 子プロセスが通常の方法で終了した場合、そのリターンコードとテーブルの下半分の探索結果を組み合わせます。そうでなければエラーが起こっているので、 <code>fork_search</code> 関数は失敗します。
</p><div class="fancybreak">* * *</div></div><p><code>wait</code> はプロセス間の同期を行いますが、それ以外に子プロセスが持つリソースの完全な開放も行います。終了した子プロセスは “ゾンビ” 状態となり大部分のリソース (メモリなど) が開放されますが、子プロセスは <code>wait</code> を呼んだ親プロセスに返り値を伝える必要があるので、プロセステーブルのスロットには乗ったままです。親プロセスが <code>wait</code> を呼べば、子プロセスはプロセステーブルからも削除されます。このテーブルの大きさは固定なので、リークを防ぐためにもフォークした全てのプロセスを <code>wait</code> することが重要です。</p><p><a id="double-fork"></a>
親プロセスが子プロセスよりも先に終了した場合、子の親はプロセス ID が 1 のプロセス (通常は <code>init</code>) に移ります。このプロセスは <code>wait</code> の無限ループを含むので、子プロセスは終了するとすぐに回収されます。この仕組みによって “ダブルフォーク” という便利なテクニックが使えるようになります。このテクニックは子プロセスの終了をブロックして待つことができないときなどに使われます。
</p><div class="mylisting"><span class="c001">match</span> fork () <span class="c001">with</span>
| 0 -&gt; <span class="c001">if</span> fork () &lt;&gt; 0 <span class="c001">then</span> exit 0;
      <em>(* 子プロセスの処理を行う *)</em>
| _ -&gt; wait ();
      <em>(* 親プロセスの処理を行う *)</em></div><p>子プロセスは二回目のフォークの後すぐに終了します。これによって孫プロセスは親を失うので、<code>init</code> の養子となります。この方法ではゾンビプロセスが生まれることはありません。親はフォーク後すぐに <code>wait</code> を呼んで子を回収します。子はすぐに終了するので、この <code>wait</code> が長い間ブロックすることはありません。</p><p><br>
</p>
<!--TOC section id="sec71" プログラムの起動-->
<h2 class="section" id="sec71">3.4  プログラムの起動</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/execve.html"><span class="c003">execve</span></a><a id="hevea_default74"></a>、 <a href="http://www.opengroup.org/onlinepubs/009696799/functions/execv.html"><span class="c003">execv</span></a><a id="hevea_default75"></a>、 そして <a href="http://www.opengroup.org/onlinepubs/009696799/functions/execvp.html"><span class="c003">execvp</span></a><a id="hevea_default76"></a> は現在のプロセスでプログラムを起動します。現在のプログラムの実行を止めて新しいプログラムに移るので、エラーの場合を除いてこの呼び出しが返ることはありません。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecve">execve</a> : string -&gt; string array -&gt; string array -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecv">execv</a>  : string -&gt; string array -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecvp">execvp</a> : string -&gt; string array -&gt; unit</div><p>第一引数は実行するプログラムを含むファイルの名前です。<code>execvp</code> を使った場合ファイルの名前は (環境変数 <code>PATH</code> で指定される) 探索パスのディレクトリから探索されます。</p><p>第二引数はプログラムを実行するときに渡されるコマンドライン引数の配列です。実行するプログラムの中ではこの配列が <code>Sys.argv</code> となります。</p><p><code>execve</code> を使うと第三引数にプログラムが実行される環境を渡すことができます。<code>execv</code> と <code>execvp</code> では現在の環境がそのまま使われます。</p><p><code>execve</code> と <code>execv</code>、そして <code>execvp</code> が結果を返すことはありません。エラーが起こること無くプロセスが指定されたプログラムを実行するか、実行ファイルが見つからないなどのエラーが起きて呼び出し元のプログラムに <code>Unix_error</code> を出すかのどちらかです。</p><div class="example">
<!--TOC paragraph id="sec72" 例-->
<h5 class="paragraph" id="sec72">例</h5><!--SEC END --><p>
次の三つは同じ動作をします:
</p><div class="mylisting">execve <span class="c002">"/bin/ls"</span> [|<span class="c002">"ls"</span>; <span class="c002">"-l"</span>; <span class="c002">"/tmp"</span>|] (environment ())
execv  <span class="c002">"/bin/ls"</span> [|<span class="c002">"ls"</span>; <span class="c002">"-l"</span>; <span class="c002">"/tmp"</span>|]
execvp <span class="c002">"ls"</span>      [|<span class="c002">"ls"</span>; <span class="c002">"-l"</span>; <span class="c002">"/tmp"</span>|]</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec73" 例-->
<h5 class="paragraph" id="sec73">例</h5><!--SEC END --><p>
受け取った <code>grep</code> コマンドへの引数に <code>-i</code> オプション (大文字と小文字を区別しない) を追加して起動するための “ラッパー” コマンドは以下のように書けます:
</p><div class="mylisting"><span class="c001">open</span> Sys;;
<span class="c001">open</span> Unix;;
<span class="c001">let</span> grep () =
 execvp <span class="c002">"grep"</span>
   (Array.concat
      [ [|<span class="c002">"grep"</span>; <span class="c002">"-i"</span>|];
        (Array.sub Sys.argv 1 (Array.length Sys.argv - 1)) ])
;;
handle_unix_error grep ();;</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec74" 例-->
<h5 class="paragraph" id="sec74">例</h5><!--SEC END --><p>
<code>emacs</code> コマンドをターミナルのタイプを変えて起動するための “ラッパー” コマンドは以下のように書けます:
</p><div class="mylisting"><span class="c001">open</span> Sys;;
<span class="c001">open</span> Unix;;
<span class="c001">let</span> emacs () =
 execve <span class="c002">"/usr/bin/emacs"</span> Sys.argv
   (Array.concat [ [|<span class="c002">"TERM=hacked-xterm"</span>|]; (environment ()) ]);;
handle_unix_error emacs ();;</div><div class="fancybreak">* * *</div></div><p><code>exec</code> を呼んだプロセスは新しいプログラムを実行するプロセスと同じです。そのため新しいプログラムは <code>exec</code> を呼んだプログラムの実行環境の一部を引き継ぎ、以下に上げるものは同じになります:
</p><ul class="itemize"><li class="li-itemize">
プロセス ID と親プロセス
</li><li class="li-itemize">標準出力、標準入力、標準エラー出力
</li><li class="li-itemize">無視されるシグナル (<a href="#sec%2Fsignals">4</a> 章を参照)
</li></ul>
<!--TOC section id="sec75" 完全な例: ミニシェル-->
<h2 class="section" id="sec75">3.5  完全な例: ミニシェル</h2><!--SEC END --><p>次のプログラムは単純なコマンドインタープリターです。標準入力から行入力を読み、単語ごとに区切り、コマンドを起動し、標準入力から EOF を受け取るまでこれを繰り返します。文字列を単語のリストに分割する関数から始めます。このひどい処理についてはどうかノーコメントとさせてください。</p><div class="mylisting"><span class="c001">open</span> Unix;;
<span class="c001">open</span> Printf;;

<span class="c001">let</span> split_words s =
 <span class="c001">let rec</span> skip_blanks i =
   <span class="c001">if</span> i &lt; String.length s &amp; s.[i] = ' '
   <span class="c001">then</span> skip_blanks (i+1)
   <span class="c001">else</span> i <span class="c001">in
 let rec</span> split start i =
   <span class="c001">if</span> i &gt;= String.length s <span class="c001">then</span>
     [String.sub s start (i-start)]
   <span class="c001">else if</span> s.[i] = ' ' <span class="c001">then
     let</span> j = skip_blanks i <span class="c001">in</span>
     String.sub s start (i-start) :: split j j
   <span class="c001">else</span>
     split start (i+1) <span class="c001">in</span>
 Array.of_list (split 0 0);;</div><p>次はインタープリターのメイン処理です:
</p><div class="mylisting"><span class="c001">let</span> exec_command cmd =
 <span class="c001">try</span> execvp cmd.(0) cmd
 <span class="c001">with</span> Unix_error(err, _, _) -&gt;
   printf <span class="c002">"Cannot execute %s : %s\n%!"</span>
     cmd.(0) (error_message err);
   exit 255

<span class="c001">let</span> print_status program status =
 <span class="c001">match</span> status <span class="c001">with</span>
 | WEXITED 255 -&gt; ()
 | WEXITED status -&gt;
     printf <span class="c002">"%s exited with code %d\n%!"</span> program status;
 | WSIGNALED signal -&gt;
     printf <span class="c002">"%s killed by signal %d\n%!"</span> program signal;
 | WSTOPPED signal -&gt;
     printf <span class="c002">"%s stopped (???)\n%!"</span> program;;</div><p><code>exec_command</code> 関数がコマンドを実行とエラーの対処を行います。リターンコード 255 はコマンドが実行されなかったことを意味します (これは通常の慣習ではありません。リターンコード 255 で終了するプログラムはほとんど無いはずだという想定からこのようにしています)。<code>print_status</code> は終了プロセスが返した状態をデコードして出力します。
</p><div class="mylisting"><span class="c001">let</span> minishell () =
 <span class="c001">try
   while true do
     let</span> cmd = input_line Pervasives.stdin <span class="c001">in
     let</span> words = split_words cmd <span class="c001">in
     match</span> fork () <span class="c001">with</span>
     | 0 -&gt; exec_command words
     | pid_son -&gt;
         <span class="c001">let</span> pid, status = wait () <span class="c001">in</span>
         print_status <span class="c002">"Program"</span> status
   <span class="c001">done
 with</span> End_of_file -&gt; ()
;;

handle_unix_error minishell ();;</div><p><code>input_line</code> 関数は EOF に達すると <code>End_of_file</code> を出すので、これをもってループの終了とします。その後は行入力を単語に区切ってから <code>fork</code> を呼び出します。子プロセスは <code>exec_command</code> を呼んでコマンドを実行します。親プロセスは <code>wait</code> を使ってコマンドの終了を待った後、<code>wait</code> の返す子プロセスの状態を出力します。</p><div class="exercise">
<!--TOC paragraph id="sec76" 練習問題 10-->
<h5 class="paragraph" id="sec76">練習問題 10</h5><!--SEC END --><p><a id="ex10"></a>
<a id="shell"></a>
コマンドの最後に <code>&amp;</code> が付いている場合にコマンドをバックグラウンドで実行する機能を追加してください。
<a href="#exans10">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 10</arg>-->
<!--NAME exercise10.html-->
<div class="answer">
<!--TOC paragraph id="sec77" 練習問題 exercise 10 の解答-->
<h5 class="paragraph" id="sec77">練習問題 <a href="#ex10">exercise 10</a> の解答</h5><!--SEC END --><p>
<a id="exans10"></a>
コマンドが <code>&amp;</code> で終わっていた場合には親プロセスが <code>wait</code> を呼ばずに次のループにすぐに移るようにすればよいです。しかし一つ難しいところがあります:親プロセスは同時に実行される複数の子プロセスを持つことになるので、<code>wait</code> がそのうちのどれとも同期するようになってしまうことです。そのため同期的に実行されるコマンドの終了を待っているときには回収した子が終了を待っている子であると確認するまで <code>wait</code> を何度も呼ぶ必要があります。

</p><div class="mylisting">   <span class="c001">while true do
     let</span> cmd = input_line Pervasives.stdin <span class="c001">in
     let</span> words, ampersand = parse_command_line cmd <span class="c001">in
     match</span> fork () <span class="c001">with</span>
     | 0 -&gt; exec_command words
     | pid_son -&gt;
         <span class="c001">if</span> ampersand <span class="c001">then</span> ()
         <span class="c001">else
           let rec</span> wait_for_son () =
             <span class="c001">let</span> pid, status = wait () <span class="c001">in
             if</span> pid = pid_son <span class="c001">then</span>
               print_status <span class="c002">"Program"</span> status
             <span class="c001">else
               let</span> p = <span class="c002">"Background program "</span> ^ (string_of_int pid) <span class="c001">in</span>
               print_status p status;
               wait_for_son () <span class="c001">in</span>
           wait_for_son ()
   <span class="c001">done</span></div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC chapter id="sec/signals" シグナル-->
<h1 class="chapter" id="sec/signals"> 4  シグナル</h1><!--SEC END --><!--NAME signals.html-->
<p>シグナル、あるいはソフトウェア割り込みはプログラムの処理を切り替えるためのプログラム外部からの非同期イベントです。シグナルはプログラムの実行中のどんなときにでも起こりえます。この点において、 <span class="c003">read</span><a id="hevea_default77"></a> 関数やパイプ (<a href="#sec%2Fpipes">5</a> 章参照) のような外部からのメッセージを明示的に待つプロセス間通信とは異なっています。</p><p>シグナルによって伝わるのはシグナルの種類という最小限の情報だけです。シグナルはもともとプロセス間通信を目的とするものではありませんでしたが、外部装置 (つまりシステムや他のプロセス) の状態の原始的な情報を送ることでプロセス間通信を可能にしています。</p>
<!--TOC section id="sec79" デフォルトの動作-->
<h2 class="section" id="sec79">4.1  デフォルトの動作</h2><!--SEC END --><p>プロセスがシグナルを受け取ったときの動作としてありえるのは次の四つです:
</p><ul class="itemize"><li class="li-itemize">
シグナルがプロセスを終了させる。加えてシステムはプロセスの状態のイメージをコアファイルに書き込むことができる (コアダンプと呼ばれ、あとでデバッガを使って調べられる)。
</li><li class="li-itemize">シグナルはプロセスの実行を停止させるが、メモリー上に保持する。親プロセス (たいていはシェル) は終了しないので、あとで追加のシグナルを送ることでプロセスの実行をフォアグラウンドまたはバックグラウンドで再開させることができる。
</li><li class="li-itemize">シグナルは完全に無視され、何も起きない。
</li><li class="li-itemize">シグナルを受け取ったプロセスで関連づいた関数が実行される。それまでのプロセスの実行は関数が返ってから再開される。
</li></ul><p>シグナルにはいくつか種類があり、それぞれ特定のイベントと結びついています。表 <a href="#tab%2Fsignals">4</a> にシグナル (の一部) とそのデフォルトの動作を示します。
</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c011">名前</td><td class="c011">イベント</td><td class="c011">デフォルトの動作 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"><code>sighup</code></td><td class="c011">ハングアップ (接続の終了)</td><td class="c011">終了 </td></tr>
<tr><td class="c011"><code>sigint</code></td><td class="c011">割り込み (<code>ctrl-C</code>)</td><td class="c011">終了 </td></tr>
<tr><td class="c011"><code>sigquit</code></td><td class="c011">終了 (<code>ctrl-\</code>)</td><td class="c011">終了 &amp; コアダンプ </td></tr>
<tr><td class="c011"><code>sigfpe</code></td><td class="c011">算術エラー (0 による除算)</td><td class="c011">終了 &amp; コアダンプ </td></tr>
<tr><td class="c011"><code>sigkill</code></td><td class="c011">中止 (無視できない)</td><td class="c011">終了 </td></tr>
<tr><td class="c011"><code>sigsegv</code></td><td class="c011">不正なメモリ参照</td><td class="c011">終了 &amp; コアダンプ </td></tr>
<tr><td class="c011"><code>sigpipe</code></td><td class="c011">読み込み先のいないパイプへの書き出し</td><td class="c011">終了 </td></tr>
<tr><td class="c011"><code>sigalrm</code></td><td class="c011">タイマー割り込み</td><td class="c011">無視 </td></tr>
<tr><td class="c011"><code>sigtstp</code></td><td class="c011">一時中断 (<code>ctrl-Z</code>)</td><td class="c011">中断 </td></tr>
<tr><td class="c011"><code>sigcont</code></td><td class="c011">中断したプロセスの再開</td><td class="c011">無視 </td></tr>
<tr><td class="c011"><code>sigchld</code></td><td class="c011">子プロセスが終了あるいは停止した</td><td class="c011">無視 <br>
</td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>

<a id="tab/signals"></a>
<div class="caption">Table 4 — シグナル (一部) とそのデフォルトの動作</div></div><p>プロセスが受け取るシグナルはいくつかの方法で送られます:
</p><ul class="itemize"><li class="li-itemize">ユーザがキーボードで送る。コンソールで <code>ctrl-C</code> と打つことで <code>sigint</code> シグナルをターミナルがフォアグラウンドで実行しているプロセスに送ることができる。同様に <code>ctrl-\</code> は <code>sigquit</code> シグナルを送る<sup><a id="text7" href="#note7">1</a></sup>。端末が自分自身を終了するか、ネットワークのリンクが切れることで端末が終了したとき、 <code>sighup</code> シグナル送られる。</li><li class="li-itemize">ユーザがシェルコマンド <code>kill</code> で送る。<code>kill</code> を使うと特定のプロセスに特定のシグナルを送ることができる。例えば <code>kill -KILL 194</code> は <code>sigkill</code> シグナルを ID が 194 のプロセスに送り、プロセスを停止させる</li><li class="li-itemize">他のプログラムがシステムコール <code>kill</code> で送る (一つ前のケースと同じ)。</li><li class="li-itemize">プロセスの誤った動作を受けてシステムが送る。例えばゼロによる除算を行おうとしたプロセスには <code>sigfpe</code> が送られる。</li><li class="li-itemize">システムが実行環境が変化したことを通知するために送る。例えば子プロセスが終了すると、親には <code>sigchld</code> シグナルが送られる。</li></ul>
<!--TOC section id="sec/usingsignals" シグナルの利用-->
<h2 class="section" id="sec/usingsignals">4.2  シグナルの利用</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/kill.html"><span class="c003">kill</span></a><a id="hevea_default78"></a> を使うとプロセスにシグナルを送ることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALkill">kill</a> : int -&gt; int -&gt; unit</div><p>第一引数はシグナルを送るプロセスの ID で、第二引数は送るシグナルの番号です。<code>kill</code> を呼んだユーザによって所有されていないプロセスにシグナルを送ろうとするとエラーとなります。プロセスは自分自身にシグナルを送ることができます。システムコール <code>kill</code> が値を返した場合、シグナルが目的のプロセスに届いたことが保証されます。</p><p>プロセスが同じシグナルを短い間に何度も受け取った場合、そのシグナルに対応するコードは一度しか実行しないことがあります。そのためプロセスは受け取ったシグナルの数を数えることはできず、数えられるのはシグナルに反応した回数となります。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/alarm.html"><span class="c003">alarm</span></a><a id="hevea_default79"></a> を使うとシステムクロックを使って割り込みを予約することができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALalarm">alarm</a> : int -&gt; int</div><p><code>alarm s</code> という呼び出しはすぐに返りますが、その後少なくとも <code>s</code> 秒後 (最大で何秒後かについての保証はありません) に <code>sigalrm</code> シグナルが送られます。この呼び出しが返すのはこれまでの <code>alarm</code> によって設定されたアラームまでの残り秒数です。<code>s</code> が <code>0</code> の場合、これまでのアラームをキャンセルします。</p>
<!--TOC section id="sec81" シグナルに対する動作の変更-->
<h2 class="section" id="sec81">4.3  シグナルに対する動作の変更</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/signal.html"><span class="c003">signal</span></a><a id="hevea_default80"></a> を使うとプロセスが指定した種類のシグナルを受け取ったときの動作を変更できます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#VALsignal">signal</a> : int -&gt; signal_behavior -&gt; signal_behavior</div><p>第一引数は動作を変更するシグナルの番号で、 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#TYPEsignal_behavior"><span class="c003">signal_behavior</span></a> 型の第二引数はそのシグナルに対応する動作を指定します。 <code>signal_behavior</code> には以下の値があります:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"> <code>Signal_ignore</code></td><td class="c011">シグナルを無視する。 </td></tr>
<tr><td class="c011"><code>Signal_default</code></td><td class="c011">デフォルトの動作を行う。 </td></tr>
<tr><td class="c011"><code>Signal_handle f</code></td><td class="c011">シグナルを受け取ると <code>f</code> を実行する。
</td></tr>
</table>
</div><p>システムコール <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfork"><span class="c003">fork</span></a><a id="hevea_default81"></a> によってプロセスをフォークしてもシグナルに関する動作は引き継がれます。フォーク直後の子プロセスのシグナルへの動作は <code>fork</code> が実行された時点での親プロセスのものと同じです。システムコール <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecve"><span class="c003">execve</span></a><a id="hevea_default82"></a> は無視されているシグナルは無視されたままにし、それ以外のシグナルについては <code>Signal_default</code> に動作を変更します。</p><div class="example">
<!--TOC paragraph id="sec82" 例-->
<h5 class="paragraph" id="sec82">例</h5><!--SEC END --><p>
ログオフしたりセッションを終了した後でもバックグラウンドでタスク (大規模な計算、あるいは “スパイウェア” など)を実行したままにしておきたいことがあります。プロセスの <code>sighup</code> シグナル (ユーザが接続を終了すると送られます) に対するデフォルトの動作はプロセスの終了なので、このシグナルを無視するように変更すればプロセスを実行されたままにすることができます。Unix コマンド <code>nohup</code> はまさにこのことを行います:
</p><div class="mylisting">nohup cmd arg1 ... argn</div><p><code>nohup</code> はコマンド <code>cmd arg1 ... argn</code> を <code>fighup</code> に影響されない状態で実行します (バックグラウンドで起動された全てのプロセスに対して自動的に <code>nohup</code> を実行するシェルもあります)。この <code>nohup</code> は 3 行で実装できます:
</p><div class="mylisting"><span class="c001">open</span> Sys;;
signal sighup Signal_ignore;;
Unix.execvp argv.(1) (Array.sub argv 1 (Array.length argv - 1));;</div><p>システムコール <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecvp"><span class="c003">execvp</span></a><a id="hevea_default83"></a> は <code>sighup</code> が無視される状態を引き継ぎます。
</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec83" 例-->
<h5 class="paragraph" id="sec83">例</h5><!--SEC END --><p>
異常動作をしたプログラムの注意深い終了処理。例えば <code>tar</code> のようなプログラムは、異常動作によって終了することになっても終了する前にファイルの重要な情報を書き込んだり壊れたファイルを削除することが望ましいです。以下のコードをプログラムの最初に書けばプログラムが終了するときの動作を設定することができます。
</p><div class="mylisting">signal sigquit (Signal_handle quit);
signal sigsegv (Signal_handle quit);
signal sigfpe  (Signal_handle quit);</div><p>ここで <code>quit</code> は以下のような形をしています:
</p><div class="mylisting"><span class="c001">let</span> quit _ =
  <em>(* ファイルの重要な情報の書き込みを試みる *)</em>
  exit 100;;</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec84" 例-->
<h5 class="paragraph" id="sec84">例</h5><!--SEC END --><p>
ユーザが発した割り込みのキャプチャ。インタラクティブなプログラムではユーザが <code>ctrl-C</code> を押したときにメインループを抜けるようになっていることがあります。<code>sigint</code> シグナルを受け取ったときに例外を出すようにすれば実装できます。
</p><div class="mylisting"><span class="c001">exception</span> Break;;
<span class="c001">let</span> break _ = raise Break;;
...
<span class="c001">let</span> main_loop () =
  signal sigint (Signal_handle break);
  <span class="c001">while true do
    try</span> <em>(* ユーザのコマンドを読み込んで評価する  *)</em>
    <span class="c001">with</span> Break -&gt; <em>(* "stopped" と表示する *)</em>
  <span class="c001">done</span>;;</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec85" 例-->
<h5 class="paragraph" id="sec85">例</h5><!--SEC END --><p>
<a id="ex/beep"></a>
アニメーションなどのメインプログラムと切り離された周期的なタスクの実行。例えば次のプログラムメインプログラムの動作 (計算、入出力) に関係なく 30 秒ごとに “ビープ” 音を鳴らします。</p><div class="mylisting"><span class="c001">let</span> beep _ =
  output_char stdout '\007'; flush stdout;
  ignore (alarm 30);;
...
signal sigalrm (Signal_handle beep); ignore (alarm 30);;</div><div class="fancybreak">* * *</div></div><!--TOC subsection id="sec86" チェックポイント-->
<h3 class="subsection" id="sec86">チェックポイント</h3><!--SEC END --><p>シグナルは非同期コミュニケーションに便利です — 実際それが存在理由です — が、この非同期であるという特徴のせいでシグナルはシステムプログラミングにおける難しい部分になっています。</p><p>シグナルハンドラは非同期に実行されるので、この関数とプロセスのメインプログラムとは擬似的に並列な状態で実行されます。シグナルハンドラが値を返せないことから、通常この関数は通常グローバル変数を変更します。したがってメインプログラムも同時にその変数を変更しようとした場合、競合状態に陥ること可能性があります。これに対する一つの解決法は次の節で説明するようにシグナルハンドラが変更する変数をメインプログラムが変更するときにはシグナルを一時的にブロックすることです。</p><p>厳密にいうと、 OCamlはシグナルを非同期に扱いません。OCamlは受け取ったシグナルを記録しますが、シグナルハンドラが実行されるのは特定の <em>チェックポイント</em> においてだけです。チェックポイントはハンドラが非同期に実行されると考えても良い程度に頻繁に設けられています。通常アロケーションやループ制御、システムとのやり取り (システムコールを含む) のときにチェックポイントが設けられます。ループが含まれず、アロケーションをせず、システムとのやり取りをしないプログラムについて、OCamlはメインプログラムとシグナルハンドラの実行が互い違いにならないことを保証しています。そのため例えばアロケートされない値 (整数および真偽値など。小数値は含まれません!) の参照セルは上記の状況でも競合状態に陥りません。</p>
<!--TOC section id="sec87" シグナルのマスク-->
<h2 class="section" id="sec87">4.4  シグナルのマスク</h2><!--SEC END --><p>シグナルはブロックできます。ブロックされたシグナルは無視されるわけではなく、後で届けられるよう待機状態になります。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/sigprocmask.html"><span class="c003">sigprocmask</span></a><a id="hevea_default84"></a> を使うとシグナルのマスクすることができます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsigprocmask">sigprocmask</a> : sigprocmask_command -&gt; int list -&gt; int list</div><p><code>sigprocmask cmd sigs</code> はブロックするシグナルを変更し、この呼び出しの前にブロックされていたシグナルのリストを返します。返り値によってマスクを元の状態に戻すことが可能になります。引数 <code>sigs</code> はシグナルのリストであり、 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsigprocmask_command"><span class="c003">sigprocmask_command</span></a> 型の値 <code>cmd</code> によって呼び出しの効果が異なります:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>SIG_BLOCK</code></td><td class="c011"><code>sigs</code> 内のシグナルがブロックするシグナルのリストに追加される。 </td></tr>
<tr><td class="c011"><code>SIG_UNBLOCK</code></td><td class="c011"><code>sigs</code> 内のシグナルがブロックするシグナルのリストから削除される。 </td></tr>
<tr><td class="c011"><code>SIG_SETMASK</code></td><td class="c011"><code>sigs</code> 内のシグナルがブロックするシグナルとなる。
</td></tr>
</table>
</div><p>
典型的な <code>sigprocmask</code> の利用法はあるシグナルをマスクすることです。
</p><div class="mylisting"><span class="c001">let</span> old_mask = sigprocmask cmd sigs <span class="c001">in</span>
<em>(* 処理を行う *)</em>
<span class="c001">let</span> _ = sigprocmask SIG_SETMASK old_mask</div><p>次のパターンを使うと起こりがちなエラーを防ぐことができます。

</p><div class="mylisting"><span class="c001">let</span> old_mask = sigprocmask cmd sigs <span class="c001">in
let</span> treat () = <em>(* 処理を行う *)</em> <span class="c001">in
let</span> reset () = ignore (sigprocmask SIG_SETMASK old_mask) <span class="c001">in</span>
Misc.try_finalize treat () reset ()</div>
<!--TOC section id="sec/sigsyscalls" シグナルとシステムコール-->
<h2 class="section" id="sec/sigsyscalls">4.5  シグナルとシステムコール</h2><!--SEC END --><p>いくつかのシステムコールは無視されていないシグナルによって中断されます。このようなシステムコールは <em>遅い</em> システムコールと呼ばれる、実行にいくらでも長い時間がかかりうるもの (例えば端末との <span class="c007">i/o</span>や <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALselect"><span class="c003">select</span></a><a id="hevea_default85"></a>、 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsystem"><span class="c003">system</span></a><a id="hevea_default86"></a> など) です。割り込みが起こった場合、これらのシステムコールは実行を完了しないまま <code>EINTR</code> 例外を出します。</p><p>一方ファイル <span class="c007">i/o</span>は割り込みされません。ファイル <span class="c007">i/o</span>中に実行中のプロセスを中断して他のプロセスを実行することはありますが、ディスクが正常に機能しているならばこの中断は常に短時間になります。ゆえにデータのスループットはシステムのみに依存し、他のユーザのプロセスから影響を受けることはありません。</p><p>無視されたシグナルは届かず、マスクされたシグナルはマスクを解くまで届きません。しかしそれ以外の場合はシステムコールをマスクしていないシステムコールから守る必要があります。典型的な例は子プロセスの終了を待っている親プロセスです。子のプロセス ID を <code>wait</code> とすると親は <span class="c003">waitpid</span><a id="hevea_default87"></a> <code>[] pid</code> を実行しますが、<code>waitpid</code> はブロックするシステムコールなので <em>遅い</em> システムコールであり、シグナルによって中断される可能性があります。特に子プロセスが終了したときには <code>sigchld</code> シグナルが親に送られます。</p><p><code>Misc</code> モジュールの <code>restart_on_EINTR</code> 関数はシステムコールが中断されたとき、すなわち <code>EINTR</code> 例外が出たときにシステムコールをやり直します。</p><div class="mylisting"><span class="c001">let rec</span> restart_on_EINTR f x =
  <span class="c001">try</span> f x <span class="c001">with</span> Unix_error (EINTR, _, _) -&gt; restart_on_EINTR f x</div><p>子プロセスの終了をシグナルで中断されないように待つには、<code>restart_on_EINTR (waitpid flags) pid</code> を呼びます。</p><div class="example">
<!--TOC paragraph id="sec89" 例-->
<h5 class="paragraph" id="sec89">例</h5><!--SEC END --><p><a id="ex/childs"></a>
子プロセスの返り値が親プロセスにとって重要でない場合、 <code>sigchld</code> のシグナルハンドラによって子プロセスを非同期に回収することも可能です。ただし短い時間に何度も同じシグナルを受け取った場合シグナルハンドラが一度しか起動しないことがあるので、<code>sigchld</code> を受け取ったときに子プロセスがいくつ終了したかを知ることはできません。このことから、<code>sigchld</code> シグナルを処理するためには以下のライブラリ関数 <code>Misc.free_chidlren</code> が必要になります。

</p><div class="mylisting"><span class="c001">let</span> free_children _ =
  <span class="c001">try while</span> fst (waitpid [ WNOHANG ] (-1)) &gt; 0 <span class="c001">do</span> () <span class="c001">done
  with</span> Unix_error (ECHILD, _, _) -&gt; ()</div><p><code>free_children</code> は <code>waitpid</code> をノンブロッキングモード (<code>WNOHANG</code> オプション) で実行して実行を終了した子プロセスを回収する、という処理を子プロセスが全て実行中となる (<code>waitpid</code> が子のプロセス ID ではなく 0 を返す) か子プロセスがなくなる (<code>ECHILD</code> 例外が出される) まで繰り返します。</p><p><code>waitpid</code> が <code>WNOHANG</code> オプションでノンブロッキングとなっているので <code>EINTR</code> に対する処理は必要ありません。
</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec90" 例-->
<h5 class="paragraph" id="sec90">例</h5><!--SEC END --><p>
<code>Unix</code> モジュールの <code>system</code> 関数は次のように単純に定義されています:
</p><div class="mylisting"><span class="c001">let</span> system cmd = <span class="c001">match</span> fork () <span class="c001">with</span>
  | 0 -&gt; <span class="c001">begin try</span>
          execv <span class="c002">"/bin/sh"</span> [| <span class="c002">"/bin/sh"</span>; <span class="c002">"-c"</span>; cmd |]
         <span class="c001">with</span> _ -&gt; exit 127
         <span class="c001">end</span>
  | id -&gt; snd (waitpid [] id);;</div><p>C 標準ライブラリの <code>system</code> 関数の規格では、親プロセスは <code>sigint</code> と <code>sigquit</code>を無視しコマンドの実行中は <code>sigchld</code> をマスクするようになっています。これによって親プロセスに影響を与えること無く子プロセスを中断したり終了させることが可能になります。</p><p>ここでは <code>system</code> 関数をより一般的な <code>exec_as_system</code> 関数の特殊化として定義します。この関数ではシェルを必ずしも起動されません。


</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let</span> exec_as_system exec args =
<span class="c005">   2</span>   <span class="c001">let</span> old_mask = sigprocmask SIG_BLOCK [ sigchld ] <span class="c001">in</span>
<span class="c005">   3</span>   <span class="c001">let</span> old_int = signal sigint Signal_ignore <span class="c001">in</span>
<span class="c005">   4</span>   <span class="c001">let</span> old_quit = signal sigquit Signal_ignore <span class="c001">in</span>
<span class="c005">   5</span>   <span class="c001">let</span> reset () =
<span class="c005">   6</span>     ignore (signal sigint old_int);
<span class="c005">   7</span>     ignore (signal sigquit old_quit);
<span class="c005">   8</span>     ignore (sigprocmask SIG_SETMASK old_mask) <span class="c001">in</span>
<span class="c005">   9</span>   <span class="c001">let</span> system_call () = <span class="c001">match</span> fork () <span class="c001">with</span>
<span class="c005">  10</span>     | 0 -&gt;
<span class="c005">  11</span>         reset (); <a id="prog:sreset"></a>
<span class="c005">  12</span>         (<span class="c001">try</span> exec args <span class="c001">with</span> _ -&gt; exit 127)
<span class="c005">  13</span>     | k -&gt;
<span class="c005">  14</span>         snd (restart_on_EINTR (waitpid []) k) <span class="c001">in</span>
<span class="c005">  15</span>   try_finalize system_call () reset ();; <a id="prog:stry"></a>
<span class="c005">  16</span> 
<span class="c005">  17</span> <span class="c001">let</span> system cmd =
<span class="c005">  18</span>   exec_as_system (execv <span class="c002">"/bin/sh"</span>) [| <span class="c002">"/bin/sh"</span>; <span class="c002">"-c"</span>; cmd |];;</div><p>シグナルの変更は <code>fork</code> の実行の前に行う必要があることに注意してください。フォークを実行した後にシグナルを変更するようにすると、シグナルが変更しきる前にシグナル (例えばすぐに終了した子プロセスからの <code>sigchld</code>) を受け取ってしまう可能性があるためです。シグナルの変更は子プロセスではコマンドの実行の前に <a href="#prog%3Asreset">11</a> 行目でリセットされます。<code>fork</code> と <code>exec</code> は無視するシグナルを保存し、 <code>fork</code> はシグナルに対する動作を保存します。<code>exec</code> は無視していないシグナルの動作をデフォルトに戻します。</p><p>最後に親プロセスはエラーが起きた場合でもシグナルの変更をリセットする必要があります。このために <a href="#prog%3Astry">15</a> 行目では <code>try_finalize</code> が使われます。
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec91" 時間の経過-->
<h2 class="section" id="sec91">4.6  時間の経過</h2><!--SEC END --><!--TOC subsection id="sec92" 時刻に対するレガシーなアプローチ-->
<h3 class="subsection" id="sec92">時刻に対するレガシーなアプローチ</h3><!--SEC END --><p>Unix の初期のバージョンから、時間は秒で測られてきました。そのため互換性が重要となるならば、常に秒単位で時間を計測するべきです。現在時刻は 1970 年 1 月 1 日 <code>00:00:00</code> <span class="c007">gmt</span> からの経過秒数と定義されます。次の関数で取得できます:</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtime">time</a><a id="hevea_default88"></a> : unit -&gt; float</div><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/sleep.html"><span class="c003">sleep</span></a><a id="hevea_default89"></a> は引数で指定した秒数だけプログラムの実行を止めます:</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtime">time</a><a id="hevea_default90"></a> : unit -&gt; float</div><p>しかしこの関数は原始的ではありません。さらに基本的なシステムコール <code>alarm</code> (前の節を参照) と <code>sigsuspend</code> を使うことで <code>sleep</code> を実装することができます。</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsigsuspend">sigsuspend</a> : int list -&gt; unit</div><p><code>sigsuspend l</code> はリスト <code>l</code> 内のシグナルを一時的に差し止め、無視も差し止めもされていないシグナルを受け取るまでプログラムの実行を停止します。値が返るときにシグナルマスクは元の値に戻ります。</p><div class="example">
<!--TOC paragraph id="sec93" 例-->
<h5 class="paragraph" id="sec93">例</h5><!--SEC END --><p> <code>sleep</code> は以下のように実装できます:

</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let</span> sleep s =
<span class="c005">   2</span>   <span class="c001">let</span> old_alarm = signal sigalrm (Signal_handle (<span class="c001">fun</span> s -&gt; ())) <span class="c001">in</span> <a id="prog:sold"></a>
<span class="c005">   3</span>   <span class="c001">let</span> old_mask = sigprocmask SIG_UNBLOCK [ sigalrm ] <span class="c001">in</span>
<span class="c005">   4</span>   <span class="c001">let</span> _ = alarm s <span class="c001">in</span>
<span class="c005">   5</span>   <span class="c001">let</span> new_mask = List.filter (<span class="c001">fun</span> x -&gt; x &lt;&gt; sigalrm) old_mask <span class="c001">in</span>
<span class="c005">   6</span>   sigsuspend new_mask;
<span class="c005">   7</span>   <span class="c001">let</span> _ = alarm 0 <span class="c001">in</span>
<span class="c005">   8</span>   ignore (signal sigalrm old_alarm);
<span class="c005">   9</span>   ignore (sigprocmask SIG_SETMASK old_mask)<a id="prog:ssigproc"></a>;;</div><p>初期状態では何もしないことが <code>sigalrm</code> シグナルに対する動作です。“何もしない” とはシグナルを無視することとは異なることに注意してください。<code>sigalrm</code> シグナルを受け取ったときにプロセスが起動することを保証するために、このシグナルは無視されないようにします。そのあと <code>sigalrm</code> 以外のマスクされているシグナルを全て差し止めてからスタンバイ状態に移行します。この変更はアラームのシグナルの後で取り消されます。<code>sigsuspend</code> がシグナルマスクを変更しないことから、<a href="#prog%3Assigproc">9</a> 行目は <a href="#prog%3Asold">2</a> 行目の直後に置くこともできます。
</p><div class="fancybreak">* * *</div></div><!--TOC subsection id="sec94" 現代的な時刻の取り扱い-->
<h3 class="subsection" id="sec94">現代的な時刻の取り扱い</h3><!--SEC END --><p>現代的なバージョンの Unix では時刻をマイクロ秒単位で測定することができます。OCamlではマイクロ秒単位で測定した時刻は浮動小数点型で表されます。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/gettimeofday.html"><span class="c003">gettimeofday</span></a><a id="hevea_default91"></a> は現代的なシステムにおいて <code>time</code> の代わりとなるものです。</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgettimeofday">gettimeofday</a> : unit -&gt; float</div><!--TOC subsection id="sec95" タイマー-->
<h3 class="subsection" id="sec95">タイマー</h3><!--SEC END --><p>
現在出回っている Unix では各プロセスはそれぞれ違う時間を測定する 3 つのタイマーを持ちます。タイマーは <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEinterval_timer"><span class="c003">interval_timer</span></a> 型の値として確認できます:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>ITIMER_REAL</code></td><td class="c011">実時間 (<code>sigalrm</code>). </td></tr>
<tr><td class="c011"><code>ITIMER_VIRTUAL</code></td><td class="c011">ユーザ時間 (<code>sigvtalrm</code>). </td></tr>
<tr><td class="c011"><code>ITIMER_PROF</code></td><td class="c011">ユーザ時間とシステム時間 (<code>sigprof</code>).
</td></tr>
</table>
</div><p>
タイマーの状態は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEinterval_timer_status"><span class="c003">interval_timer_status</span></a> 型のレコードによって表され、各フィールドは以下の時間を表します (どちらも <code>float</code> です):
</p><ul class="itemize"><li class="li-itemize">
<code>it_interval</code> フィールドはタイマーの周期を表す。
</li><li class="li-itemize"><code>it_value</code> フィールドはタイマーの現在の値を表す。この値が <code>0</code> になった場合 <code>sigvtalrm</code> シグナルが送られ、タイマーの値は <code>it_interval</code> にリセットされる。
</li></ul><p>
二つのフィールドが <code>0</code> の場合タイマーはアクティブではありません。タイマーは次の関数で取得および変更できます:

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetitimer">getitimer</a><a id="hevea_default92"></a> : interval_timer -&gt; interval_timer_status
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetitimer">setitimer</a><a id="hevea_default93"></a> :
    interval_timer -&gt; interval_timer_status -&gt; interval_timer_status</div><p><code>settimer</code> の返り値は変更前の値です。</p><div class="exercise">
<!--TOC paragraph id="sec96" 練習問題 11-->
<h5 class="paragraph" id="sec96">練習問題 11</h5><!--SEC END --><p><a id="ex11"></a>
複数のタイマーを管理するために、以下のインターフェースを持つモジュールを書いてください:
</p><div class="mylisting"><span class="c001">module type</span> Timer = <span class="c001">sig
  open</span> Unix
  <span class="c001">type</span> t
  <span class="c001">val</span> new_timer : interval_timer -&gt; (unit -&gt; unit) -&gt; t
  <span class="c001">val</span> get_timer : t -&gt; interval_timer_status
  <span class="c001">val</span> set_timer : t -&gt; interval_timer_status -&gt; interval_timer_status
<span class="c001">end</span></div><p><code>new_timer k f</code> はタイプ <code>k</code> の新しいタイマーを作り <code>f</code> の実行を始めます。タイマー作成時にはアクティブではありません。<code>set_timer t</code> はタイマーの値を <code>t</code> に設定し古い値を返します。</p><div class="fancybreak">* * *</div></div><!--TOC subsection id="sec97" 日付の計算-->
<h3 class="subsection" id="sec97">日付の計算</h3><!--SEC END --><p>Unix の現代的なバージョンには日付を処理するための関数も含まれています。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEtm"><span class="c003">tm</span></a> 構造体はカレンダー (年、月など) によって表現でき、<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgmtime"><span class="c003">gmtime</span></a><a id="hevea_default94"></a> や <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlocaltime"><span class="c003">localtime</span></a><a id="hevea_default95"></a>、 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmktime"><span class="c003">mktime</span></a><a id="hevea_default96"></a> などによって他の単位と変換できます。</p>
<!--TOC section id="sec98" シグナルの問題点-->
<h2 class="section" id="sec98">4.7  シグナルの問題点</h2><!--SEC END --><p>シグナルは非同期なので、シグナルをプロセス間通信に使うと制限と困難がいくつかあります:
</p><ul class="itemize"><li class="li-itemize">送られる情報が少なすぎる — シグナルの種類のみ。</li><li class="li-itemize">シグナルプログラムの実行中いつでも起きるので、グローバル変数にアクセスするシグナルハンドラは競合状態を避けるためにメインプログラムと協調しなければならない。</li><li class="li-itemize">シグナルをメインプログラムから使うと、シグナルに対する動作がデフォルトの動作であったとしても、実行に時間のかかるシステムコールが中断される可能性が生まれることになる。</li><li class="li-itemize">ライブラリ関数はシグナルの可能性を常に考慮しシステムコールの割り込みに対する対処をしなければならない。</li></ul><p>シグナルは制限された非同期通信であるにもかからわず、非同期通信にまつわる困難や問題は全て含みます。そのため可能であれば利用を避けるべきです。たとえば短い時間だけ待つためには <span class="c003">select</span><a id="hevea_default97"></a> がアラームの代わりに使えます。ただしコマンドラインのインタープリターなどのシグナルを考えなければいけない状況もあります。</p><p>シグナルはおそらく Unix システムの中で最も有用でない概念です。古いバージョンの Unix (System V など) ではシグナルの動作は受け取った後に自動的に<code>Signal_default</code> にリセットされます。そのためシグナルハンドラは自分自身をもう一度設定し直す必要があり、以下のように書く必要がありました:
</p><div class="mylisting"><span class="c001">let rec</span> beep _ =
  set_signal sigalrm (Signal_handle beep);
  output_char stdout '\007'; flush stdout;
  ignore (alarm 30);;</div><p>しかし問題はシグナルを受け取ってシグナルの動作が自動的に <code>Signal_default</code> に戻ってから<code>set_signal</code> が実行されるまでの短い間にシグナルを受け取った場合です。この場合シグナルはハンドラを呼びだすことなく、種類に応じて無視されるかプロセスを終了させます。</p><p>その他の Unix (<span class="c007">bsd</span> と Linux) はより良い動作をします。シグナルを受け取ってもその動作を置き換えず、シグナルを処理している間は他のシグナルは保留されます。

</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note7" href="#text7">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">これらは端末のデフォルトのキーであり、端末の設定を返ることで変更できます。 <a href="#sec%2Ftermio">2.13</a> 節参照。</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec/pipes" 古典的なプロセス間通信: パイプ-->
<h1 class="chapter" id="sec/pipes"> 5  古典的なプロセス間通信: パイプ</h1><!--SEC END --><!--NAME pipes.html-->
<p>これまでは見てきたのはプロセスを管理する方法とファイルを使って外部環境と通信する方法です。コースの残りの部分では、並列に実行されるプロセス同士がコミュニケーションを取りながら協調する方法を見ていきます。</p>
<!--TOC section id="sec100" パイプ-->
<h2 class="section" id="sec100">5.1  パイプ</h2><!--SEC END --><p>並列に実行されるプロセス同士がやり取りを行う手段として通常ファイルは十分ではありません。例えば一つのファイルにあるプロセスが書き込み、その内容を別のプロセスが読み込む状況を考えてみてください。やり取りの手段としてファイルを使った場合、読み込み側はファイルが終端に達したことを (<code>read</code> が 0 を返すことで)検出することができますが、その理由が書き込みが終わったためなのかそれとも計算に時間がかかっているためなのかを知ることはできません。さらにファイルはやり取りされるデータを全て保持する必要があるので、ディスクを不必要に圧迫します。</p><p>パイプはこのようなやり取りに向いた仕組みです。パイプは二つのファイルディスクリプタからなります。一つがパイプの出力を表し、もう一方がパイプの入力を表します。パイプはシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pipe.html"><span class="c003">pipe</span></a><a id="hevea_default98"></a> で作成できます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALpipe">pipe</a> : unit -&gt; file_descr * file_descr</div><p><code>pipe</code> を呼ぶと <code>(fd_in, fd_out)</code> が返ります。<code>fd_in</code> は <em>読み込み専用</em> で開かれたパイプの出力を表すファイルディスクリプタで、<code>fd_out</code> は <em>書き込み専用</em> で開かれたパイプの入力を表すファイルディスクリプタです。パイプ自身はこれら 2 つのディスクリプタからのみアクセス可能なカーネルの内部オブジェクトです。またパイプはファイルシステムにおいて名前を持ちません。</p><div class="image"><img src="ocamlunix-image6.png" width="60%"></div><p>パイプは先入れ先出しのキューのように振る舞います。最初にパイプに書き込んだものが最初にパイプから読み込まれます。書き込み (パイプの入力ディスクリプタへの <code>write</code>) はパイプを満たし、パイプが満杯の場合はブロックします。ブロックは他のプロセスがパイプの他方の端から十分な量のデータを読み込むまで続き、<code>write</code> に渡された全てのデータが書き込まれるまで続きます。読み込み (パイプの出力ディスクリプタへの <code>read</code>) はパイプの中身を消費します。パイプが空のとき <code>read</code> はパイプの他方の端に少なくとも 1 バイトが書き込まれるまでブロックします。<code>read</code> は要求されたバイト数だけ読み込むまで待つこと無く返ります。</p><p>入出力が同じプロセスから起きるのならばパイプは役に立ちません。そのようなプロセスは大量の書き込みや空のパイプへの読み込みによって永遠にブロックしてしまうからです。そのため普通パイプへの入出力は別々のプロセスが行います。パイプは名前を持たないことから、パイプを利用するプロセスの片方はパイプを作成したプロセスからのフォークによって作られる必要があります。
</p><div class="example">
<!--TOC paragraph id="sec101" 例-->
<h5 class="paragraph" id="sec101">例</h5><!--SEC END --><p> 次の短いコードは典型的なパイプの使用例です。
</p><div class="mylisting"><span class="c001">let</span> (fd_in, fd_out) = pipe () <span class="c001">in
match</span> fork () <span class="c001">with</span>
| 0 -&gt; close fd_in; ... write fd_out buffer1 offset1 count1 ...
| pid -&gt; close fd_out; ... read fd_in buffer2 offset2 count2 ...</div><p><code>fork</code> のあとパイプの入力を指すディスクリプタは二つあり、親プロセスと子プロセスが一つづつ持っています。出力用ディスクリプタについても同様です。
</p><div class="image"><img src="ocamlunix-image7.png" width="45%"></div><p>


この例では子が書き込みを、親が読み取りを行います。子はパイプの出力 <code>fd_in</code> をクローズしますが、これはディスクリプタを節約しプログラミング上のミスを防ぐためです。ディスクリプタはプロセスのメモリに確保され、フォークすると親子でメモリが別々になるので、子プロセスでディスクリプタをクローズしたとしても親プロセス <code>fd_in</code> はその影響を受けません。パイプはシステムメモリに確保され、親プロセスの <code>fd_in</code> がパイプの出力に読み込みモードで開いている限り生き続けます。同じ理由で親プロセスはパイプの入力へのディスクリプタをクローズします。結果的に以下のような状態となります:</p><div class="image"><img src="ocamlunix-image8.png" width="45%"></div><p>


子プロセスが <code>fd_out</code> に書き込んだデータは親の <code>fd_in</code> に書き込まれます。
</p><div class="fancybreak">* * *</div></div><p>
パイプの入力へのディスクリプタが全てクローズされかつパイプが空のとき、パイプの出力への <code>read</code> は 0 (ファイルの終端) を返します。パイプの出力へのディスクリプタが全てクローズされているとき、パイプの入力への <code>write</code> は書き込みプロセスを終了させます。より正確に言うと、カーネルが <code>write</code> を呼んだプロセスに <code>sigpipe</code> シグナルを送り、このシグナルのデフォルトの動作がプロセスの終了です。<code>sigpipe</code> シグナルのハンドラが変更していた場合は、 <code>write</code> は <code>EPIPE</code> エラーを出して失敗します。</p>
<!--TOC section id="ex/crible" 完全な例: 並列エラトステネスのふるい-->
<h2 class="section" id="ex/crible">5.2  完全な例: 並列エラトステネスのふるい</h2><!--SEC END --><p>これは並列プログラミングの古典的な例です。ここで扱うのは素数を順に列挙しながら見つかった順にインタラクティブに表示するという問題です。アルゴリズムのアイデアは次のようなものです。あるプロセスが 2 から順に整数を出力します。このプロセスに整数 <span class="c006">p</span> を一つ受け取って表示する別の <em>フィルター</em> プロセスをつなげます。</p><div class="image"><img src="ocamlunix-image9.png" width="38%"></div><p>


最初のフィルタープロセスは 2 を最初に受け取ることから <span class="c006">p</span>=2 となります。このプロセスは自分の出力と接続した新しいフィルタープロセスを作成します。そして新しいプロセスに <span class="c006">p</span> の倍数でない整数を入力します。
</p><div class="image"><img src="ocamlunix-image10.png" width="65%"></div><p>


新しいフィルタープロセスは 3 を最初に受け取るので <span class="c006">p</span>=3 となります。このプロセスは 3 の倍数をフィルターし、同じことが次のプロセスへと続きます。
</p><div class="image"><img src="ocamlunix-image11.png" width="100%"></div><p>


このアルゴリズムは見つける素数の数よりひとつ多い数のプロセスが必要になりますが、これだとプロセスを多く作りすぎるのでUnix で直接実装できません。多くの Unix システムではプロセス数を数十程度に制限しています。同時に実行されるプロセスが多すぎる場合、プロセスが一つしか無い機械ではコンテキストスイッチによるコストによって性能が大幅に減少します。そのためこれからの実装ではプロセスは最初の <span class="c006">n</span> 個の素数 <span class="c006">p</span><sub>1</sub>, …, <span class="c006">p</span><sub><span class="c006">n</span></sub> を出力し、<span class="c006">p</span><sub>1</sub>, …, <span class="c006">p</span><sub><span class="c006">n</span></sub> の倍数でない整数を次のプロセスへと渡します。<span class="c006">n</span>=1000 程度にすればプロセス生成のコストが見えなくなります。</p><p>まず 2 から <span class="c006">k</span> までの整数を生成するプロセスを作ります。
</p><div class="mylisting"><span class="c001">open</span> Unix;;

<span class="c001">let</span> input_int = input_binary_int
<span class="c001">let</span> output_int = output_binary_int

<span class="c001">let</span> generate k output =
  <span class="c001">let rec</span> gen m =
    output_int output m;
    <span class="c001">if</span> m &lt; k <span class="c001">then</span> gen (m+1)
  <span class="c001">in</span>
  gen 2;;</div><p>整数の入出力には次の関数が使われます:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_binary_int">output_binary_int</a> : out_channel -&gt; int -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_binary_int">input_binary_int</a> : in_channel -&gt; int</div><p>標準ライブラリの <code>output_binary_int</code> 関数は整数を表す 4 バイトのバイナリを<code>out_channel</code> に書き込みます。この整数は <code>in_channel</code> に対する <code>input_binary_int</code> で読み込むことができます。これらの関数を使うことには二つのメリットがあります。まず、整数をバイト表現に変換する関数を作る必要がありません<sup><a id="text8" href="#note8">1</a></sup>。さらに、これらの関数はバッファされた <span class="c007">i/o</span>を使うのでシステムコールの回数が減り、パフォーマンスが上昇します。次の関数は <span class="c007">i/o</span>をバッファするための <code>in_channel</code> または <code>out_channel</code> を作成します。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALin_channel_of_descr">in_channel_of_descr</a><a id="hevea_default99"></a> : file_descr -&gt; in_channel
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALout_channel_of_descr">out_channel_of_descr</a><a id="hevea_default100"></a> : file_descr -&gt; out_channel</div><p>これらの関数を使うと間接的に手に入れたディスクリプタ、あるいはファイルを開いていないディスクリプタに対してバッファされた <span class="c007">i/o</span>を行うことができます。バッファされた <span class="c007">i/o</span>をバッファされていない <span class="c007">i/o</span>と混ぜることはしてはいけません。混ぜることは不可能ではありませんが、とてもエラーを含みやすい — 特に入力に対しては — ので決して行うべきではありません。また一つのディスクリプタに対して二つ以上の <code>in_channel</code> あるいは <code>out_channel</code> を開くことも可能ですが、これも危険なので行うべきではありません。</p><p>フィルタープロセスの話を進めます。このプロセスは補助関数 <code>read_first_primes</code> を使用します。<code>read_first_primes input count</code> は <code>count</code> 個の素数を <code>input</code> (<code>in_channel</code> 型の値) から読み、すでに計算された素数は読み飛ばします。<code>count</code> 個の素数は読み込まれた時点で出力され、計算された素数を保存するリストに入ります。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let</span> print_prime n = print_int n; print_newline ()
<span class="c005">   2</span> 
<span class="c005">   3</span> <span class="c001">let</span> read_first_primes input count =
<span class="c005">   4</span>   <span class="c001">let rec</span> read_primes first_primes count =
<span class="c005">   5</span>     <span class="c001">if</span> count &lt;= 0 <span class="c001">then</span> first_primes <span class="c001">else</span>
<span class="c005">   6</span>     <span class="c001">let</span> n = input_int input <span class="c001">in</span>
<span class="c005">   7</span>     <span class="c001">if</span> List.exists (<span class="c001">fun</span> m -&gt; n <span class="c001">mod</span> m = 0) first_primes <span class="c001">then</span>
<span class="c005">   8</span>       read_primes first_primes count
<span class="c005">   9</span>     <span class="c001">else begin</span>
<span class="c005">  10</span>       print_prime n;
<span class="c005">  11</span>       read_primes (n :: first_primes) (count - 1)
<span class="c005">  12</span>     <span class="c001">end</span>
<span class="c005">  13</span>   <span class="c001">in</span>
<span class="c005">  14</span>   read_primes [] count<a id="prog:pprime"></a>;;</div><p>フィルター関数は以下のようになります:
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let rec</span> filter input =
<span class="c005">   2</span>   <span class="c001">try</span>
<span class="c005">   3</span>     <span class="c001">let</span> first_primes = read_first_primes input 1000 <span class="c001">in</span>
<span class="c005">   4</span>     <span class="c001">let</span> (fd_in, fd_out) = pipe () <span class="c001">in</span>
<span class="c005">   5</span>     <span class="c001">match</span> fork () <span class="c001">with</span> <a id="prog:sievefilterfork"></a>
<span class="c005">   6</span>     | 0 -&gt;
<span class="c005">   7</span>         close fd_out;
<span class="c005">   8</span>         filter (in_channel_of_descr fd_in)
<span class="c005">   9</span>     | p -&gt;
<span class="c005">  10</span>         close fd_in;
<span class="c005">  11</span>         <span class="c001">let</span> output = out_channel_of_descr fd_out <span class="c001">in</span>
<span class="c005">  12</span>         <span class="c001">while true do</span> <a id="prog:sievefilterwhile"></a>
<span class="c005">  13</span>           <span class="c001">let</span> n = input_int input <span class="c001">in</span>
<span class="c005">  14</span>           <span class="c001">if</span> List.exists (<span class="c001">fun</span> m -&gt; n <span class="c001">mod</span> m = 0) first_primes <span class="c001">then</span> ()
<span class="c005">  15</span>           <span class="c001">else</span> output_int output n
<span class="c005">  16</span>         <span class="c001">done</span> <a id="prog:sievefilterdone"></a>
<span class="c005">  17</span>   <span class="c001">with</span> End_of_file -&gt; ();;</div><p>フィルタは <code>read_first_primes</code> を呼んで最初の 1000 個の素数を出力するところから始まります(引数 <code>input</code> は <code>in_channel</code> 型です)。そのあとパイプを作ってから子プロセスをフォークします、親プロセスは整数を入力 <code>input</code> から読み、それが最初に計算した 1000 個の素数の倍数でない場合はそれをパイプに入力します。</p><p>最後に整数を出力するプロセスと最初のフィルタープロセスをつなぐ処理を書けばメインプログラムの完成です。プログラムを <code>sieve k</code> で起動すると <code>k</code> より小さい素数が列挙されます。<code>k</code> が省略された場合には <code>k</code> は <code>max_int</code> となります。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let</span> sieve () =
<span class="c005">   2</span>   <span class="c001">let</span> len = <span class="c001">try</span> int_of_string Sys.argv.(1) <span class="c001">with</span> _ -&gt; max_int <span class="c001">in</span>
<span class="c005">   3</span>   <span class="c001">let</span> (fd_in, fd_out) = pipe () <span class="c001">in</span>
<span class="c005">   4</span>   <span class="c001">match</span> fork () <span class="c001">with</span> <a id="prog:sievefork"></a>
<span class="c005">   5</span>   | 0 -&gt;
<span class="c005">   6</span>       close fd_out;
<span class="c005">   7</span>       filter (in_channel_of_descr fd_in)
<span class="c005">   8</span>   | p -&gt;
<span class="c005">   9</span>       close fd_in;
<span class="c005">  10</span>       generate len (out_channel_of_descr fd_out);; <a id="prog:gen"></a>
<span class="c005">  11</span> 
<span class="c005">  12</span> handle_unix_error sieve ();;</div><p>この例では親プロセスが終了するときに子プロセスの終了を待つことはしません。この理由は親プロセスが子プロセスの <em>ジェネレータ</em> であるためです。</p><p><code>k</code> が与えられたとき最初に実行を終えるのは親プロセスであり、終了するとき子プロセスに繋がったパイプの入力へのディスクリプタをクローズします。OCamlはプロセスが終了するときに書き込みモードで開かれたディスクリプタのバッファを空にすることから、子プロセスは親プロセスが書き込んだ最後の整数まで読みきることができます。その子プロセスが終了するときについても同様です。そのためこのプログラムでは子プロセスは一時的に親を失って <code>init</code> の子となります</p><p><code>k</code> が与えられていない場合はいずれかのプロセスが終了するまで全てのプロセスがずっと動き続けます。プロセスの終了すると上記のように子プロセスも終了します。またプロセスが終了すると親プロセスにつながっているパイプの出力をクローズするので、親プロセスは次の書き込みをしたときに終了します (正確には書き込みのときに <code>sigpipe</code> を受け取り、そのデフォルトの動作によって終了します)。</p><div class="exercise">
<!--TOC paragraph id="sec103" 練習問題 12-->
<h5 class="paragraph" id="sec103">練習問題 12</h5><!--SEC END --><p><a id="ex12"></a>
親プロセスが子プロセスの終了を待つようにするにはどうすればよいでしょうか ?
<a href="#exans12">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 12</arg>-->
<!--NAME exercise12.html-->
<div class="answer">
<!--TOC paragraph id="sec104" 練習問題 exercise 12 の解答-->
<h5 class="paragraph" id="sec104">練習問題 <a href="#ex12">exercise 12</a> の解答</h5><!--SEC END --><p>
<a id="exans12"></a>
親プロセスは子プロセスを待たなくてはいけませんが、そのまえに子プロセスが読み込むパイプへの入力を親が閉じる必要があります。これを閉じなかった場合子プロセスは次の整数が来るのを永遠に待つことになり、デッドロックを引き起こします (チャンネルを閉じると対応するディスクリプタのバッファが空になるので、データが失われることはありません)。具体的には <code>sieve</code> 関数の <a href="#prog%3Agen">10</a> 行目を以下のようにします:
</p><div class="mylisting"><span class="c001">let</span> output = out_channel_of_descr fd_out <span class="c001">in</span>
generate len output;
close_out output;
ignore(waitpid [] p);;</div><p>そして <code>filter</code> 関数の <a href="#prog%3Asievefilterwhile">12</a>–<a href="#prog%3Asievefilterdone">16</a> 行目 (<code>...</code> で表されている部分) を次のコードで覆います。
</p><div class="mylisting"><span class="c001">try</span>
  ...
<span class="c001">with</span> End_of_file -&gt;
  close_out output;
  ignore (waitpid [] p)</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id="sec105" 練習問題 13-->
<h5 class="paragraph" id="sec105">練習問題 13</h5><!--SEC END --><p><a id="ex13"></a>
素数が見つかったとき、<code>print_prime</code> 関数は <code>print_newline ()</code> を実行します。この実行によって出力のバッファを空にするシステムコールが呼ばれるので、プログラムの実行速度が制限されます。<code>print_newline ()</code> は <code>print_char '\n'</code> と <code>flush Pervasives.stdout</code> を実行しますが、フラッシュを省略して <code>print_newline ()</code> を <code>print_char '\n'</code> と置き換えた場合何が起こるでしょうか? この問題を解決するにはどうすればよいでしょうか?
<a href="#exans13">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 13</arg>-->
<!--NAME exercise13.html-->
<div class="answer">
<!--TOC paragraph id="sec106" 練習問題 exercise 13 の解答-->
<h5 class="paragraph" id="sec106">練習問題 <a href="#ex13">exercise 13</a> の解答</h5><!--SEC END --><p>
<a id="exans13"></a>
子プロセスは親プロセスの完全なコピーであることから、標準ライブラリの<span class="c007">i/o</span>バッファは <code>fork</code> のときに複製されます。そのため各書き込みごとにバッファを空にしない場合、<code>fork</code> の直前にバッファを空にしておく必要があります。<code>read_first_prime</code> 関数の <a href="#prog%3Apprime">14</a> 行目の後に <code>flush Pervasives.stdout</code> を追加すればよいです。
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec107" 名前付きパイプ-->
<h2 class="section" id="sec107">5.3  名前付きパイプ</h2><!--SEC END --><p>いくつかの Unix システム (System V, SunOS, Ultrix, Linux など) ではファイルシステム内で名前を持つパイプを作成できます。この <em>名前付きパイプ</em> (あるいは <em>fifo</em>) を使うと親子関係にないプロセス同士がやり取りを行うことができます。パイプを作ったプロセスとその子でしかやり取りのできない通常のパイプとは対称的です。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/mkfifo.html"><span class="c003">mkfifo</span></a><a id="hevea_default101"></a> は名前付きパイプを作成します:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmkfifo">mkfifo</a> : string -&gt; file_perm -&gt; unit</div><p>第一引数がパイプの名前を、第二引数がアクセス権限を表します。</p><p>名前付きパイプは <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopenfile"><span class="c003">openfile</span></a> を使って通常ファイルと同じように開くことができます。名前付きパイプの入出力も通常ファイルと同じです。名前付きパイプを読み込み専用 (あるいは書き込み専用) モードで開くとそのパイプが別のプロセスによって書き込みモード (あるいは読み込みモード) で開かれるまでブロックします。すでに開かれていた場合にはブロックはありません。<code>O_NONBLOCK</code> フラグでパイプを開くことでブロックを避けることができますが、この場合パイプへの入出力もブロックしなくなります。<code>clear_nonblock</code> を使うとパイプを開いた後で入出力をブロックするように変更でき、<code>set_nonblock</code> を使うとブロックしないようにすることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclear_nonblock">clear_nonblock</a><a id="hevea_default102"></a> : file_descr -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALset_nonblock">set_nonblock</a><a id="hevea_default103"></a> : file_descr -&gt; unit</div>
<!--TOC section id="sec108" ディスクリプタのリダイレクト-->
<h2 class="section" id="sec108">5.4  ディスクリプタのリダイレクト</h2><!--SEC END --><p>ここまでの説明では、シェルが <code>cmd1 | cmd2</code> のようなコマンドを実行するときのように標準入出力をパイプに接続する方法はわかりません。<code>pipe</code> で作ったパイプの両端を指すのは <em>新しい</em> ディスクリプタであり、<code>stdin</code> や <code>stdout</code>、 <code>stderr</code> ではないからです。</p><p>この問題に対処するために、Unix には <a href="http://www.opengroup.org/onlinepubs/009696799/functions/dup2.html"><span class="c003">dup2</span></a><a id="hevea_default104"></a> というシステムコールがあります (<code>dup2</code> は「あるディスクリプタを別のディスクリプタに複製する (<em>dup</em>licate <em>to</em>)」 と読めます) 。<code>dup2</code> はあるディスクリプタを別のディスクリプタとして振る舞うようにします。これが可能なのはファイルディスクリプタ (<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_descr"><span class="c003">file_descr</span></a> 型のオブジェクト)と <em>ファイルテーブルエントリ</em> と呼ばれるカーネル内部のオブジェクトとの間に間接参照の仕組みが存在するからです。 <em>ファイルテーブルエントリ</em> が開かれているファイルやパイプ、現在の入出力位置などの情報を保持します。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALdup2">dup2</a> : file_descr -&gt; file_descr -&gt; unit</div><p><code>dup2 fd1 fd2</code> を呼ぶとディスクリプタ <code>fd2</code> が <code>fd1</code> の指すファイルテーブルエントリを指すようになります。この呼び出しの後には同じファイルまたはパイプを指し、同じ入出力位置を持つファイルディスクリプタが二つあることになります。</p><div class="image"><img src="ocamlunix-image12.png" width="80%"></div><div class="example">
<!--TOC paragraph id="sec109" 例-->
<h5 class="paragraph" id="sec109">例</h5><!--SEC END --><p>
標準入力のリダイレクト
</p><div class="mylisting"><span class="c001">let</span> fd = openfile <span class="c002">"foo"</span> [O_RDONLY] 0 <span class="c001">in</span>
dup2 fd stdin;
close fd;
execvp <span class="c002">"bar"</span> [|<span class="c002">"bar"</span>|]</div><p><code>dup2</code> を呼ぶとディスクリプタ <code>stdin</code> はファイル <code>foo</code> を指すようになります。つまり <code>stdin</code> を読み込むとファイル <code>foo</code> から読むことになります (<code>fd</code> への読み込みも同様ですが、これは使用しないのですぐに閉じます) 。<code>stdin</code> の設定は <code>execvp</code> で保存されるので、プログラム <code>bar</code> は標準入力がファイル <code>foo</code> に繋がった状態で実行されます。これはシェルで <code>bar &lt; foo</code> としたときと同じ動作です。</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec110" 例-->
<h5 class="paragraph" id="sec110">例</h5><!--SEC END --><p>
標準出力のリダイレクト
</p><div class="mylisting"><span class="c001">let</span> fd = openfile <span class="c002">"foo"</span> [O_WRONLY; O_TRUNC; O_CREAT] 0o666 <span class="c001">in</span>
dup2 fd stdout;
close fd;
execvp <span class="c002">"bar"</span> [|<span class="c002">"bar"</span>|]</div><p><code>dup2</code> を呼ぶとディスクリプタ <code>stdout</code> はファイル <code>foo</code> を指すようになります。つま<code>stdout</code> への書き込みはファイル <code>foo</code> への書き込みとなります (<code>fd</code> への書き込みも同様ですが、これは使用しないのですぐに閉じます) 。<code>stdout</code> の設定は <code>execvp</code> で保存されるので、プログラム <code>bar</code> は標準出力がファイル <code>foo</code> に繋がった状態で実行されます。これはシェルで <code>bar &gt; foo</code> としたときと同じ動作です。</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec111" 例-->
<h5 class="paragraph" id="sec111">例</h5><!--SEC END --><p> あるプログラムの出力を他のプログラムの入力にする
</p><div class="mylisting"><span class="c001">let</span> (fd_in, fd_out) = pipe () <span class="c001">in
match</span> fork () <span class="c001">with</span>
| 0 -&gt;
       dup2 fd_in stdin;
       close fd_out;
       close fd_in;
       execvp <span class="c002">"cmd2"</span> [|<span class="c002">"cmd2"</span>|]
| _ -&gt;
       dup2 fd_out stdout;
       close fd_out;
       close fd_in;
       execvp <span class="c002">"cmd1"</span> [|<span class="c002">"cmd1"</span>|]</div><p>プログラム <code>cmd2</code> は標準入力がパイプの出力となった状態で実行されます。それと並行してプログラム <code>cmd1</code> は標準出力がパイプの入力となった状態で実行されます。結果として <code>cmd1</code> が標準出力に書いたものはすべて <code>cmd2</code> が標準入力から読みます。</p><p><code>cmd1</code> が <code>cmd2</code> よりも前に終了すると何が起こるでしょうか? <code>cmd1</code> が終了すると全ての開かれているディスクリプタが閉じられるので、パイプの入力を指すディスクリプタがなくなります。結果として <code>cmd2</code> がパイプにあるデータを全て読んだ次の読み込みで EOF を読み込みます。<code>cmd2</code> は標準入力が末尾に達したときの動作を行います — 例えば終了するなどです。</p><p>反対に <code>cmd2</code> が <code>cmd1</code> よりも前に終了した場合、パイプの出力を指す最後のディスクリプタが閉じられるので <code>cmd1</code> は次に標準出力に書き込んだときに <code>sigpipe</code> シグナルを受け取ります (このシグナルのデフォルトの動作はプロセスの終了です)。</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id="sec112" 練習問題 14-->
<h5 class="paragraph" id="sec112">練習問題 14</h5><!--SEC END --><p><a id="ex14"></a>
シェルが持つ他のリダイレクトを実装してください。具体的には以下です:
</p><div class="mylisting">&gt;&gt;      2&gt;      2&gt;&gt;     2&gt;1     &lt;&lt;</div><p><a href="#exans14">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 14</arg>-->
<!--NAME exercise14.html-->
<div class="answer">
<!--TOC paragraph id="sec113" 練習問題 exercise 14 の解答-->
<h5 class="paragraph" id="sec113">練習問題 <a href="#ex14">exercise 14</a> の解答</h5><!--SEC END --><p>
<a id="exans14"></a>
</p><ul class="itemize"><li class="li-itemize">
<code>&gt;&gt;</code> については、ファイルを開くときのフラグを <code>[O_WRONLY; O_APPEND; O_CREAT]</code> に変えれば他は <code>&gt;</code> と同じです。
</li><li class="li-itemize"><code>2&gt;</code> については、 <code>dup2 fd stdout</code> を <code>dup2 fd stderr</code> に変えれば他は <code>&gt;</code> と同じです。
</li><li class="li-itemize"><code>2&gt;1</code> については、コマンドを実行する前に <code>dup2 stderr stdout</code> を実行すればよいです。
</li><li class="li-itemize"><code>&lt;&lt;</code> については、 シェル <code>sh</code> は <code>/tmp</code> フォルダに一時的なファイルを作って <code>&lt;&lt;</code> に続く文字列を保存し、標準入力をこのファイルにリダイレクトしてからコマンドを実行する必要があります。これとは別の解法はコマンドの標準入力をパイプの出力につなぎ、子プロセスを使ってそのパイプの入力に <code>&lt;&lt;</code> に続く文字列を入力することです。</li></ul><div class="fancybreak">* * *</div></div><!--END FLOW-->
<p>二つのディスクリプタを交換する場合には注意が必要です。<code>dup2 fd1 fd2;</code> <code>dup2 fd2 fd1</code> では上手く行きません。一つ目の <code>dup2</code> によって <code>fd1</code> と <code>fd2</code> の両方のディスクリプタがファイルテーブルエントリ内の同じファイルを指すようになるので、最初に <code>fd2</code> に指されていた値は失われ、二つ目の <code>dup2</code> は意味を持ちません。ここで行いたいのは 2 つの参照セルの交換なので、片方の値を保存しておく一時的な変数が必要になります。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/dup.html"><span class="c003">dup</span></a><a id="hevea_default105"></a> によってディスクリプタをコピーして保存することができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALdup">dup</a> : file_descr -&gt; file_descr</div><p><code>dup fd</code> は <code>fd</code> が指すファイルテーブルエントリと同じファイルを指す新しいディスクリプタを返します。これを使うことで、例えば <code>stdout</code> と <code>stderr</code> の交換は次のように行なえます:

</p><div class="mylisting"><span class="c001">let</span> tmp = dup stdout <span class="c001">in</span>
dup2 stderr stdout;
dup2 tmp stderr;
close tmp;;</div><p>ディスクリプタのリークを防ぐために交換の後で <code>tmp</code> をクローズします。</p>
<!--TOC section id="sec114" 完全な例: <span class="c006">N</span> 個のコマンドの合成-->
<h2 class="section" id="sec114">5.5  完全な例: <span class="c006">N</span> 個のコマンドの合成</h2><!--SEC END --><p>以下のようなコマンドを作成します:
</p><div class="mylisting">compose cmd<sub>1</sub> cmd<sub>2</sub> ... cmd<sub><span class="c006">n</span></sub></div><p>このコマンドは次のシェルコマンドのように動作します:
</p><div class="mylisting">cmd<sub>1</sub> | cmd<sub>2</sub> | ... | cmd<sub><span class="c006">n</span></sub></div><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Sys;;
<span class="c005">   2</span> <span class="c001">open</span> Unix;;
<span class="c005">   3</span> 
<span class="c005">   4</span> <span class="c001">let</span> compose () =
<span class="c005">   5</span>   <span class="c001">let</span> n = Array.length Sys.argv - 1 <span class="c001">in</span>
<span class="c005">   6</span>   <span class="c001">for</span> i = 1 <span class="c001">to</span> n - 1 <span class="c001">do</span> <a id="prog:composefor"></a>
<span class="c005">   7</span>     <span class="c001">let</span> (fd_in, fd_out) = pipe () <span class="c001">in</span>
<span class="c005">   8</span>     <span class="c001">match</span> fork () <span class="c001">with</span>
<span class="c005">   9</span>     | 0 -&gt;
<span class="c005">  10</span>         dup2 fd_out stdout;
<span class="c005">  11</span>         close fd_out;
<span class="c005">  12</span>         close fd_in;
<span class="c005">  13</span>         execv <span class="c002">"/bin/sh"</span> [| <span class="c002">"/bin/sh"</span>; <span class="c002">"-c"</span>; Sys.argv.(i) |]
<span class="c005">  14</span>     | _ -&gt;
<span class="c005">  15</span>         dup2 fd_in stdin;
<span class="c005">  16</span>         close fd_out;
<span class="c005">  17</span>         close fd_in
<span class="c005">  18</span>   <span class="c001">done</span>;
<span class="c005">  19</span>   <span class="c001">match</span> fork () <span class="c001">with</span>
<span class="c005">  20</span>   | 0 -&gt; execv <span class="c002">"/bin/sh"</span> [|<span class="c002">"/bin/sh"</span>; <span class="c002">"-c"</span>; Sys.argv.(n) |]
<span class="c005">  21</span>   | _ -&gt;
<span class="c005">  22</span>       <span class="c001">let rec</span> wait_for_children retcode =
<span class="c005">  23</span>         <span class="c001">try</span>
<span class="c005">  24</span>           <span class="c001">match</span> wait () <span class="c001">with</span>
<span class="c005">  25</span>           | (pid, WEXITED n) -&gt; wait_for_children (retcode <span class="c001">lor</span> n)
<span class="c005">  26</span>           | (pid, _)         -&gt; wait_for_children 127
<span class="c005">  27</span>         <span class="c001">with</span>
<span class="c005">  28</span>           Unix_error(ECHILD, _, _) -&gt; retcode <span class="c001">in</span>
<span class="c005">  29</span>       exit (wait_for_children 0)
<span class="c005">  30</span> ;;
<span class="c005">  31</span> handle_unix_error compose ();;</div><p>処理の大部分は <a href="#prog%3Acomposefor">6</a> 行目から始まる <code><span class="c001">for</span></code> ループが行います。最後のコマンドを除いた各コマンドについて、新しいパイプと子プロセスを作成します。子プロセスはパイプの入力を標準出力に接続してからコマンドを実行します。<code>fork</code> のあと子プロセスは親プロセスの標準入力を引き継ぎます。メインプロセス (親プロセス) はパイプの出力を標準入力としてループを続けます。<span class="c006">i</span> 番目の反復において以下のような状況になると (帰納法の仮定として) 仮定します:

</p><div class="image"><img src="ocamlunix-image13.png" width="80%"></div><p>


丸角の四角形がプロセスを表します。プロセスの標準入力を左に、標準出力を右に示しています。楕円は <code>compose</code> プロセスの最初の標準入出力を表します。この状態から <code>pipe</code> と <code>fork</code> を実行すると以下のような状況となります:
</p><div class="image"><img src="ocamlunix-image14.png" width="100%"></div><p>


親プロセスが <code>dup2</code> を実行すると、こうなります:
</p><div class="image"><img src="ocamlunix-image15.png" width="100%"></div><p>


子プロセスが <code>dup2</code> と <code>execv</code> を実行すると、こうなります:
</p><div class="image"><img src="ocamlunix-image16.png" width="100%"></div><p>


これで次の反復への準備が整います。</p><p>最後のコマンドではパイプを作る必要がないのでループの外でフォークが実行されます。<code>compose</code> プロセスの標準入力 (最後から二番目のコマンドの出力) と標準出力(最初 <code>compose</code> コマンドに与えられたもの) が最初から正しいので、ただ <code>fork</code> と <code>exec</code> 呼ぶだけで十分です。親プロセスはそれから子プロセスの終了を待つために<code>wait</code> を <code>ECHILD</code> エラー (終了待ちの子がいない) が出るまで繰り返し呼びます。子プロセスのリターンコードはビットごとの “or” (<code><span class="c001">lor</span></code> 演算子) によってまとめられ、<code>compose</code> の返り値となります。これによって全ての子プロセスが 0 を返した場合には 0 が、そうでない場合には 0 以外が <code>compose</code> コマンドから返ります。</p><p><code>/bin/sh</code> を使ってコマンドを実行していることに注意してください。次のようなコマンドを単語に分割する処理を <code>/bin/sh</code> に任せています:
</p><div class="mylisting">compose <span class="c002">"grep foo" "wc -l"</span></div><p>ミニシェルの例のようにこの処理を自分で書くこともできますが、コードを不必要に複雑にしてしまうだけでしょう。</p>
<!--TOC section id="sec115" 入出力の多重化-->
<h2 class="section" id="sec115">5.6  入出力の多重化</h2><!--SEC END --><p>これまでの全ての例において、プロセス間の通信は <em>線形</em> でした。つまりそれぞれのプロセスが読み込むのは多くとも一つのプロセスからのデータでした。この節では <em>複数の</em> プロセスからのデータを読み込む問題の解決方法を見ていきます。</p><p>複数のウィンドウを持つ端末エミュレータを例として考えます。あるコンピュータ (クライアントと呼びます) がシリアルポートで Unix マシンに接続しており、Unix マシン上の異なるプロセスに接続するためにクライアント上で複数のウィンドウをエミュレートする必要があるとします。例えばウィンドウの一つはシェルに、他のウィンドウはテキストエディタに使いたいという状況です。シェルからの出力は最初のウィンドウに、テキストエディタからの出力は二番目のウィンドウに表示します。最初のウィンドウがアクティブならばクライアントのキーボードからの入力はシェルに送られ、二番目のウィンドウがアクティブな場合はエディタに送られます。</p><p>Unix マシンとクライアントの間には物理的な接続が一つしか無いことから、データの送受信を分割してウィンドウとプロセスの間に仮想的な接続を多重化する必要があります。シリアルポートには次のプロトコルを使用してメッセージを送ります:</p><ul class="itemize"><li class="li-itemize">
受信者のプロセス番号またはウィンドウ番号を表す 1 バイト
</li><li class="li-itemize">これから続くバイト数 <span class="c006">N</span> を表す 1 バイト
</li><li class="li-itemize">受信者に送られる <span class="c006">N</span> バイトのデータ
</li></ul><p>
Unix マシンではユーザプロセス (シェルやエディタなど) はパイプによって一つ以上の補助プロセスに接続され、補助プロセスはデータの多重化 (あるいは逆多重化) やシリアルポートへの入出力を行います。シリアルポート (例えば <code>/dev/ttya</code>) はスペシャルファイルであり、補助プロセスがクライアントとやり取りを行うために使われます。</p><p>逆多重化 (クライアントからユーザプロセスへのデータ転送) は難しくありません。シリアルポートからデータを読み、抽出したデータを目的のユーザプロセスの標準入力に接続されたパイプに書き込めばよいです。
</p><div class="image"><img src="ocamlunix-image17.png" width="55%"></div><p>


多重化 (ユーザプロセスからクライアントへのデータ転送) はもっと複雑になります。まず逆多重化と同じようなことを試してみましょう。ユーザプロセスの標準出力に接続されたパイプからの出力を読み込み、受信者のウィンドウ番号とデータの長さをつけてシリアルポートに送るプロセスです。</p><div class="image"><img src="ocamlunix-image18.png" width="100%"></div><p>


パイプからの読み込みがブロックする可能性があるので、これは上手く行きません。例えばシェルからの出力を読み込みを行ない、その時点では表示するものがなかった場合、多重化プロセスはブロックし、エディターからの文字列は無視されます。表示されるべきデータがあるのはどちらのプロセスのパイプなのかを事前に知る方法はありません(並列アルゴリズムにおいては、あるプロセスが共有リソースへのアクセスをずっと拒否される状況を <em>飢餓</em> と言います)。</p><p>次に別のアプローチを示します。各ユーザプロセスに <em>リピータ</em> プロセスを結びつけます。このリピータはユーザプロセスの標準出力に接続したパイプの出力を読み、データをメッセージに変換し、メッセージをシリアルポートに直接書き込みます。各リピータプロセスは <code>/dev/ttya</code> を書き込みモードで開きます。
</p><div class="image"><img src="ocamlunix-image19.png" width="100%"></div><p>各ユーザプロセスの出力は独立して転送されることから、ブロッキングの問題は解決されます。しかしこの方法を使うとプロトコルが破られる場合があります。二つのリピータが同時にメッセージを書き込んだ場合、 Unix カーネルはそれらの書き込みの原始性、すなわち書き込みが割り込まれることなく行われなければいけないことを考慮することができません。そのため書き込みは最初にメッセージの一部を送り、その次に別のメッセージを送ってから、最初のメッセージの残りの部分を送るかもしれません。クライアントの多重化プロセスはこれに対処できず、二番目のメッセージを最初のメッセージの後半部分と解釈し、それ以降のデータを次のデータのヘッダと解釈するでしょう。</p><p>これを避けるためには、シリアルポートに書き込むプロセスがどんなときでも多くとも一つになるようにリピータプロセス同士が同期する必要があります (並列アルゴリズムではこのことを「リピータのシリアル接続へのアクセスは排他制御される必要がある」と言います)。技術的には、これまでに見た概念でこれを行うことができます。リピータはメッセージを送る前に特定のファイル (“ロック”) を <code>O_EXCL</code> フラグで作成し、シリアルポートへの書き込みが終わった後にそのファイルを削除するようにすればよいです。しかしロックの作成と削除にコストが掛かり過ぎるので、あまり効率的とは言えません。</p><p>より良い解決法は最初のアプローチ (一つの多重化プロセス) をとり、ユーザプロセスの標準出力に接続されたパイプからの出力を <code>set_nonblock</code> によってノンブロッキングに設定することです。空のパイプからの読み込みはブロックせずすぐに <code>EAGAIN</code> または <code>EWOULDBLOCK</code> エラーを出して返るので、このエラーは無視して次のプロセスの出力を読みにいくことができます。こうすることで飢餓と排他制御の問題を回避できます。しかしこれはとても非効率的な方法でもあります。多重化プロセスがデータを送っているプロセスがなくても実行を止めず、“ビジーウェイト” と呼ばれることを行うためです。この非効率性は読み込みループに <code>sleep</code> を入れることで緩和できますが、残念ながら <code>sleep</code> する正しい時間を見つけるのはとても難しいです。<code>sleep</code> が短いとデータが少ないときにプロセッサに無駄な負荷がかかり、<code>sleep</code> が短いとデータが多いときに知覚可能なレベルの遅延を引き起こすためです。</p><p>これは深刻な問題であり、<span class="c007">bsd</span> の設計者たちはこの問題を解決するために <code>select</code> という新しいシステムコールを Unix に追加しました。このシステムコールはほとんどの Unix で利用可能です。<code>select</code> を呼ぶと一つ以上の入出力のイベントを (受動的に) 待つことができます。ここでイベントとは以下のことです:
</p><ul class="itemize"><li class="li-itemize">
読み込みイベント: ディスクリプタからデータを読み込む準備が整った。</li><li class="li-itemize">書き込みイベント: ディスクリプタにブロックせずにデータを書き込む準備が整った。</li><li class="li-itemize">例外的なイベント: ディスクリプタについて例外的な条件が真になった。例えばネットワーク接続において優先度の高いデータ (<em>アウトオブバンドデータ</em>) が送信待ちの通常データを追い抜いて送信された。この種の優先度の高いデータは例外的な条件となる。
</li></ul><p>
システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/select.html"><span class="c003">select</span></a><a id="hevea_default106"></a> は次のシグネチャを持ちます:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALselect">select</a> :
    file_descr list -&gt; file_descr list -&gt; file_descr list -&gt;
      float -&gt; file_descr list * file_descr list * file_descr list</div><p>最初の三つの引数がディスクリプタの集合をリストで表します。最初の引数が読み込みイベントを監視するディスクリプタの集合で、二つ目が書き込みイベントを監視するディスクリプタの集合、三つ目が例外的なイベントを監視するディスクリプタの集合です。第四引数はタイムアウトまでの秒数です。第四引数が 0 以上のとき、<code>select</code> はイベントが何も起こらなかったとしてもその時間が経てば返ります。この値が負のとき、<code>select</code> は監視を要求されたイベントの一つが起こるまでブロックします。</p><p><code>select</code> はディスクリプタのリストの三つ組を返します。最初の要素が読み込みの準備ができたディスクリプタを、二つ目の要素が書き込みの準備ができたディスクリプタを、三つ目の要素が例外的な条件が真となったディスクリプタをそれぞれ表します。イベントが起こる前にタイムアウトした場合、これら三つのリストは全て空です。</p><div class="example">
<!--TOC paragraph id="sec116" 例-->
<h5 class="paragraph" id="sec116">例</h5><!--SEC END --><p>
以下のコードはディスクリプタ <code>fd1</code> と <code>fd2</code> の読み込みイベントを監視し、 0.5 秒後に返ります。
</p><div class="mylisting"><span class="c001">match</span> select [fd1; fd2] [] [] 0.5 <span class="c001">with</span>
| [], [], [] -&gt; <em>(* 0.5 秒でタイムアウトした *)</em>
| fdl, [], [] -&gt;
    <span class="c001">if</span> List.mem fd1 fdl <span class="c001">then</span>
         <em>(* fd1 から読む *)</em>
    <span class="c001">if</span> List.mem fd2 fdl <span class="c001">then</span>
         <em>(* fd2 から読む *)</em></div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id="sec117" 例-->
<h5 class="paragraph" id="sec117">例</h5><!--SEC END --><p>
以下の <code>multiplex</code> 関数は説の最初で説明したマルチウィンドウに対応したターミナルエミュレータの多重化/逆多重化の中心となります。</p><p>単純のために、多重化関数はメッセージの受信者番号を送信者番号と同じようにラベル付けし、逆多重化関数は受け取ったデータを受信者番号に直接リダイレクトすることにします。つまり、ユーザプロセスとクライアントのどちらについても、送信者は必ず同じ番号の受信者とやり取りをすると仮定します。あるいは同じことですが、送信者と受信者の対応付けはシリアル接続の内部で受信者番号を書き換えることで行われると仮定します。</p><p><code>multiplex</code> 関数はシリアルポートへ開いたディスクリプタと同じサイズのディスクリプタの配列二つを受け取ります。配列の一つにはユーザプロセスの標準入力につながったパイプが、もう一方にはユーザプロセスの標準出力に繋がったパイプが含まれています。
</p><div class="mylisting"><span class="c001">open</span> Unix;;

<span class="c001">let rec</span> really_read fd buff start length =
  <span class="c001">if</span> length &lt;= 0 <span class="c001">then</span> () <span class="c001">else
    match</span> read fd buff start length <span class="c001">with</span>
    | 0 -&gt; raise End_of_file
    | n -&gt; really_read fd buff (start+n) (length-n);;

<span class="c001">let</span> buffer = String.create 258;;

<span class="c001">let</span> multiplex channel inputs outputs =
  <span class="c001">let</span> input_fds = channel :: Array.to_list inputs <span class="c001">in
  try
    while true do
      let</span> (ready_fds, _, _) = select input_fds [] [] (-1.0) <span class="c001">in
      for</span> i = 0 <span class="c001">to</span> Array.length inputs - 1 <span class="c001">do
        if</span> List.mem inputs.(i) ready_fds <span class="c001">then begin
          let</span> n = read inputs.(i) buffer 2 255 <span class="c001">in</span>
          buffer.[0] &lt;- char_of_int i;
          buffer.[1] &lt;- char_of_int n;
          ignore (write channel buffer 0 (n+2));
          ()
        <span class="c001">end
      done</span>;
      <span class="c001">if</span> List.mem channel ready_fds <span class="c001">then begin</span>
        really_read channel buffer 0 2;
        <span class="c001">let</span> i = int_of_char(buffer.[0])
        <span class="c001">and</span> n = int_of_char(buffer.[1]) <span class="c001">in
        if</span> n = 0 <span class="c001">then</span> close outputs.(i) <span class="c001">else
        begin</span>
          really_read channel buffer 0 n;
          ignore (write outputs.(i) buffer 0 n);
          ()
        <span class="c001">end
      end
    done
  with</span> End_of_file -&gt; () ;;</div><p><code>multiplex</code> 関数は読み込みに使うディスクリプタの集合 <code>input_fds</code> を作るところから始まります。この集合にはユーザプロセスの標準出力につながっているディスクリプタとシリアルポートのディスクリプタが含まれます。一番外側の <code><span class="c001">while</span></code> の反復では <code>select</code> を呼んで <code>input_fds</code> 内に書き込み待ちがないか確認します。ここでは例外的なイベントを待つことはせず、待ち時間に制限を設けることもありません。<code>select</code> が返ったならば、ユーザプロセスからの入力ディスクリプタまたはシリアルポートのディスクリプタが入力を待っているかを調べます。</p><p>ユーザプロセスからの入力ディスクリプタの準備ができているならば <code>read</code> でデータをバッファに読み、メッセージのヘッダをつけてシリアルポートに書き込みます。<code>read</code> が 0 を返した場合対応するユーザプロセスのパイプが閉じられたことを意味します。クライアントのターミナルエミュレータは 0 バイトのメッセージによってウィンドウに対応する番号のユーザプロセスが終了したことを通知されるので、そのウィンドウを閉じることができます。</p><p>シリアルポートにデータがある場合、まず 2 バイトのヘッダから受信者番号 <code>i</code> と読み込むデータのバイト数 <code>n</code> を読み込みます。その後シリアルポートのチャンネルから <code>n</code> バイトを読み、読み込んだデータを<code>i</code> 番目のユーザプロセスの標準入力に書き込みます。このとき <code>n</code> が 0 ならば、 <code>i</code> 番目の出力ディスクリプタを閉じます。接続先のターミナルエミュレータが発する <code>n = 0</code> というメッセージはそのエミュレータのプロセスの標準入力が終端に達したことを意味するからです。</p><p><code>really_read</code> が <code>End_of_file</code> 例外を出したら一番外側のループを抜けます。この例外はシリアルポートが EOF に達したことを意味します。
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id="single_write" その他: <span class="c003">write</span>-->
<h2 class="section" id="single_write">5.7  その他: <span class="c003">write</span></h2><!--SEC END --><p><code>Unix</code> モジュールの <code>write</code> 関数は要求されたデータがバイト数まで全て書き込まれ終わるまでシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/write.html"><span class="c003">write</span></a><a id="hevea_default107"></a> を呼び続けます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwrite">write</a> : file_descr -&gt; byte -&gt; int -&gt; int -&gt; int</div><p>ディスクリプタがパイプ (あるいはソケット、 <a href="#sec%2Fsockets">6</a> 参照) だった場合、書き込みはブロックしシステムコール <code>write</code> はシグナルによって中断する可能性があります。このような場合には OCamlの <code>Unix.write</code> は中断され <code>EINTR</code> エラーが出ます。ここで問題となるのはシステムコール <code>write</code> によってデータの一部が書き込まれたにも関わらずそのサイズがわからないまま失われてしまうということです。このためシグナルがある状況では <code>Unix</code> モジュールの <code>write</code> は役に立たなくなってしまいます。</p><p>この問題を解決するために、 <code>Unix</code> モジュールには <code>single_write</code> という名前の “生の” システムコールがあります。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsingle_write">single_write</a> : file_descr -&gt; byte -&gt; int -&gt; int -&gt; int</div><p><code>single_write</code> を使えば、エラーが起こったときにデータが書き込まれていないことを保証できます。</p><p>この説の残りではこの関数をどうやって実装するかを示します。基本的にこれは OCamlと C の間のインターフェースの問題です (OCamlのマニュアルにはこの話題に関する情報が載っています) 。次のコードは <code>single_write.c</code> に保存されます:
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">#include</span> &lt;errno.h&gt;
<span class="c005">   2</span> <span class="c001">#include</span> &lt;string.h&gt;
<span class="c005">   3</span> <span class="c001">#include</span> &lt;caml/mlvalues.h&gt;
<span class="c005">   4</span> <span class="c001">#include</span> &lt;caml/memory.h&gt;
<span class="c005">   5</span> <span class="c001">#include</span> &lt;caml/signals.h&gt;
<span class="c005">   6</span> <span class="c001">#include</span> &lt;caml/unixsupport.h&gt;
<span class="c005">   7</span> 
<span class="c005">   8</span> CAMLprim value caml_single_write
<span class="c005">   9</span>         (value fd, value buf, value vofs, value vlen) {
<span class="c005">  10</span>   CAMLparam4(fd, buf, vofs, vlen);
<span class="c005">  11</span>   long ofs, len;
<span class="c005">  12</span>   int numbytes, ret;
<span class="c005">  13</span>   char iobuf[UNIX_BUFFER_SIZE];
<span class="c005">  14</span>   ofs = Long_val(vofs)
<span class="c005">  15</span>   len = Long_val(vlen)
<span class="c005">  16</span>   ret = 0;
<span class="c005">  17</span>   <span class="c001">if</span> (len &gt; 0) {
<span class="c005">  18</span>     numbytes = len &gt; UNIX_BUFFER_SIZE ? UNIX_BUFFER_SIZE : len;
<span class="c005">  19</span>     memmove (iobuf, &amp;Byte(buf, ofs), numbytes);
<span class="c005">  20</span>     caml_enter_blocking_section (); <a id="prog:enterbs"></a>
<span class="c005">  21</span>     ret = write(Int_val(fd), iobuf, numbytes);
<span class="c005">  22</span>     caml_leave_blocking_section (); <a id="prog:leavebs"></a>
<span class="c005">  23</span>     <span class="c001">if</span> (ret == -1) uerror(<span class="c002">"single_write"</span>, Nothing);
<span class="c005">  24</span>   }
<span class="c005">  25</span>   CAMLreturn (Val_int(ret));
<span class="c005">  26</span> }</div><p>最初の二行は標準の C ヘッダをインクルードします。その次の四行はディストリビューションと共にインストールされる OCaml特有の C ヘッダをインクルードします。<code>unixsupport.h</code> ヘッダは OCamlの Unix ライブラリが持つ再利用可能な C の関数を定義しています。</p><p>一番重要な行は <code>write</code> を呼ぶ行です。この関数は (ディスクリプタがパイプかソケットの場合に) ブロックすることがあるので、呼び出す前に OCamlランタイムのグローバルのロックを開放し (<a href="#prog%3Aenterbs">20</a> 行目) 、呼び出した後にロックを取得します (<a href="#prog%3Aleavebs">22</a> 行目)。これによってこの関数は <code>Thread</code> モジュール (<a href="#sec%2Fcoprocessus">7</a> 章参照) と同時に利用できます。ブロックしている間に他のスレッドが実行できるからです。</p><p>システムコールの間に OCamlはガベージコレクションが実行され、OCamlの文字列 <code>buf</code> がメモリ内を移動する可能性があります。この問題を解決するために <code>buf</code> を C の文字列 <code>iobuf</code> にコピーします。これには追加のコストがかかりますが、10% 前後のオーダーです (50% 程度と考えるかもしれませんが、そうではありません)。関数全体のコストはシステムコールがほとんどを占めるためです。バッファに使う C の文字列の大きさは <code>unix_support.h</code> に定義されています。システムコール中にエラーが起こった場合 (負の返り値で示されます) そのエラーは <code>uerror</code> 関数によって OCamlに運ばれます。 <code>uerror</code> 関数は OCamlの Unix ライブラリで定義されています。</p><p>この関数を OCamlから利用するには、 <code>unix.mli</code> を作って以下の宣言を書きます:


</p><div class="mylisting"><span class="c001">external</span> unsafe_single_write :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; int = <span class="c002">"caml_single_write"</span></div><p>実際に使うときには関数を呼ぶ前に引数を確認します:
</p><div class="mylisting"><span class="c001">let</span> single_write fd buf ofs len =
  <span class="c001">if</span> ofs &lt; 0 || len &lt; 0 || ofs &gt; String.length buf - len
  <span class="c001">then</span> invalid_arg <span class="c002">"Unix.write"</span>
  <span class="c001">else</span> unsafe_single_write fd buf ofs len</div><p><code>single_write</code> 関数はバージョン <span class="c003">3.08</span> から <code>Unix</code> モジュールで利用可能ですが、上記のように自分で書いた場合には以下のようにしてコンパイルする必要があります(OCamlのコードは <code>write.mli</code> と <code>write.ml</code> にあると仮定します)。
</p><div class="mylisting">ocamlc -c single_write.c write.ml
ocamlc -custom -o prog unix.cma single_write.o write.cmo mod1.ml mod2.ml</div><p>通常は以下のようにして C と OCamlのコードを両方含むライブラリ <code>write.cma</code> を使ったほうが実用的です。
</p><div class="mylisting">ocamlc -custom -a -o write.cma single_write.o write.cmo</div><p>ライブラリ <code>write.cma</code> は <code>unix.cma</code> のように使えます。
</p><div class="mylisting">ocamlc -o main.byte unix.cma write.cma main.ml</div><p><code>single_write</code> の動作はシステムコール <code>write</code> によく似ていますが、書き込む文字列がとても長い場合の動作だけ異なります。文字列が <code>UNIX_BUFFER_SIZE</code> よりも長い場合一度のシステムコールで全てのデータを書き込むことができないので、システムコールは繰り返されます。そのためシステムコール <code>write</code> が持つ通常ファイルに対する書き込みの原子性は <code>single_write</code> では長い文字列に対しては成り立ちません。この違いは通常重要ではありませんが意識しておくべきでしょう。</p><p>この関数を元にして更に高レベルの関数 <code>really_write</code> を実装することができます。要求されたデータを (アトミックでなく) 全て書き込むので、<code>multiplexer</code> 関数で使った <code>readlly_read</code> 関数に似ています。

</p><div class="mylisting"><span class="c001">let rec</span> really_write fd buffer offset len =
  <span class="c001">let</span> n = restart_on_EINTR (single_write fd buffer offset) len <span class="c001">in
  if</span> n &lt; len <span class="c001">then</span> really_write fd buffer (offset + n) (len - n);;</div>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note8" href="#text8">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">ここで紹介したライブラリ関数によって使われる内部表現は規定されていませんが、言語のバージョンが同じならばプラットフォーム非依存であることが保証されています。</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec/sockets" モダンなプロセス間通信: ソケット-->
<h1 class="chapter" id="sec/sockets"> 6  モダンなプロセス間通信: ソケット</h1><!--SEC END --><!--NAME sockets.html-->
<p>パイプを使った通信にはいくつか制限があります。まず、パイプを使うとローカルのマシンとしか通信できません。名前付きパイプではやり取りをするプロセスが同じマシンで実行される必要があり、名前無しパイプでは二つのプロセスは親子関係になくてはいけません。次に、パイプでは <em>クライアント-サーバ</em> モデルという便利な通信モデルを使うことが難しいです。このモデルではちょうど一つの <em>サーバ</em> プログラムだけが共有リソースにアクセスできます。そして他の <em>クライアント</em> はサーバにアクセスすることで共有リソースにアクセスします。サーバが共有リソースへのアクセスの制御と管理を行うということです。例えば <span class="c007">x</span>-window システムでは共有リソースとはスクリーンとキーボード、そしてマウスです。</p><p>クライアント-サーバモデルをパイプで実装するのは難しいです。一番の困難はクライアントとサーバの間の接続を確立する部分です。名前無しパイプではこれは不可能です。サーバとクライアントに共通の親が必要であり、その親は任意の数のパイプを前もって保持する必要があるからです。名前付きパイプを使えばサーバがクライアントからの接続を読むことは不可能ではありません。しかしこの場合サーバが受け取るリクエストにはクライアントがサーバとやり取りするのに使う他の名前付きパイプの名前も含まれるので、複数のクライアントからの接続リクエストをどう排他制御するかが問題となります。</p><p>ソケットはこれらの問題を解決するために一般化されたパイプです。ソケットの説明のために、まずクライアント-サーバモデルを図 <a href="#fig%2Fclient-server">3</a> に示します。</p><div class="figure">
<div class="image"><img src="ocamlunix-image20.png" width="70%"></div>



<a id="fig/client-server"></a>
<div class="caption">Figure 3 — クライアント-サーバモデル</div></div><ol class="enumerate" type=1><li class="li-enumerate">
サーバ <span class="c006">U</span> がソケット <span class="c006">s</span> をポート <span class="c006">p</span> に作成し、接続を待つ (1)。クライアントはポート番号 <span class="c006">p</span> を知っている。
</li><li class="li-enumerate">クライアント <span class="c006">A</span> がソケットを作成し、ポート <span class="c006">p</span> に接続する (2)。サーバ上では、システムがクライアント <span class="c006">A</span> とプライベートにやり取りするための新しいソケットを確保する (3)。この例ではサーバは補助サーバ <span class="c006">V</span> をフォークし、<span class="c006">A</span> との接続を閉じる (4)。 閉じられた接続は破線で示されている。以降はこの子プロセス <span class="c006">V</span> が <span class="c006">A</span> との通信を行う (5)。
</li><li class="li-enumerate">サーバは新しいクライアント <span class="c006">B</span> を受け付けることができる。新しい接続が作成され、クローンしたプロセス <span class="c006">W</span> によって通信が行われる (6)。以降も同様となる。
</li><li class="li-enumerate">サーバはソケット <span class="c006">s</span> に結び付けられたファイルディスクリプタを閉じることでサービスを終了できる。システムはポート <span class="c006">p</span> を開放して再利用する。このポートは例えば他のサービスをインストールするのに使われる。</li></ol><p>上記のモデルでは、サーバ <span class="c006">U</span> とクライアント <span class="c006">A</span> はプライベートな接続 (3) を確立することで他のクライアントの影響を受けずにやり取りを行います。このことから、この通信方式は <em>コネクション型通信</em> と呼ばれます。通信が短ければサーバが (フォークせずに) 直接リクエストを処理することもできます。しかしこうするとサーバが接続 (3) を処理するのを待つため、あるいは複数の接続が多重化によって管理されているために、クライアントはサーバが利用可能になるまで待たなければいけません。</p><p>ソケットを使うと <em>コネクションレス型通信</em> を利用することもできます。この方式ではサーバはクライアントとプライベートな接続を確立することなく直接通信します。コネクション型通信と比べるとこの方式が使われることは少ないです。 <a href="#sec%2Fmode-deconnecte">6.10</a> 節で少しコメントしますが、この章では主にコネクション型通信を扱います。</p>
<!--TOC section id="sec120" ソケット-->
<h2 class="section" id="sec120">6.1  ソケット</h2><!--SEC END --><p>ソケットはパイプの拡張であり、<span class="c007">bsd</span> 4.2 で初めて実装されました。現在ではネットワークに接続するすべての Unix がソケットの機能を持ちます。クライアント-サーバモデルに沿った通信を行うための専用のシステムコールが存在します。このシステムコールによって、プロセス間のローカル通信およびリモート通信を (ほぼ) 透過的に行うことができます。</p><p>ソケットの <em>通信ドメイン</em> は通信できるプロセス (およびそのアドレスのフォーマット) を制限します。異なる通信ドメインが利用可能です。例えば:</p><ul class="itemize"><li class="li-itemize">
Unix ドメイン:
アドレスはマシンのファイルシステム上の名前。通信は同じマシンで実行されるプロセス間に限られる (パイプを使った通信など)。
</li><li class="li-itemize">インターネットドメイン: アドレスはインターネットネットワークにおけるマシンのアドレス (例えば <code>129.199.129.1</code> のような形をしたもの) とマシンのポート番号。通信はインターネットに接続している任意の二つのマシンで実行されるプロセス間で可能<sup><a id="text9" href="#note9">1</a></sup>。
</li></ul><p>ソケットの <em>通信方式</em> は通信が信頼できるか (データの消失や重複があるか)、そしてデータの送受信の方法 (バイトストリーム、パケット列 — バイトの小さなブロック) を示します。通信方式はデータの送受信に使われるプロトコルを規定します。いくつかの通信方式が利用可能です。三つの通信方式をその特徴と共に示します:
</p><div class="center">
<table class="c000 cellpading0"><tr><td class="c011"> 方式</td><td class="c011">信頼性</td><td class="c011">データ表現 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"> ストリーム</td><td class="c011">信頼できる</td><td class="c011">バイトストリーム </td></tr>
<tr><td class="c011"> データグラム</td><td class="c011">信頼できない</td><td class="c011">パケット </td></tr>
<tr><td class="c011"> セグメント化されたパケット</td><td class="c011">信頼できる</td><td class="c011">パケット </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
</div><p>
“ストリーム” 方式はパイプを使った通信にとても良く似ており、一番良く使われます。例えば構造化されていないバイトシーケンスの転送 (例えば <code>rsh</code>) などに使われます。“セグメント化されたパケット” 方式はデータをパケットとして転送します。すべての書き込みはパケットごとに区切られ、すべての読み込みは多くとも一つのパケットしか読み込めません。この方式はメッセージ指向の通信に適しています。“データグラム” 方式はイーサネットネットワークのハードウェアの特徴に一番近いです。データはパケットで転送されますが、それぞれのパッケットが目的地に届く保証はありません。ネットワークのリソースという観点では、この方式が一番無駄が少ないです。この方式は致命的な重要性を持たないデータの転送を行うプログラム (例えば <code>biff</code>) によって使われます。またデータの消失を手動で管理することでネットワークのパフォーマンスを向上させることもできます。
</p>
<!--TOC section id="sec121" ソケットの作成-->
<h2 class="section" id="sec121">6.2  ソケットの作成</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/socket.html"><span class="c003">socket</span></a><a id="hevea_default108"></a> は新しいソケットを作成します:

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsocket">socket</a> : socket_domain -&gt; socket_type -&gt; int -&gt; file_descr</div><p>返り値は新しいソケットを表すファイルディスクリプタです。初期状態ではこのディスクリプタは “切断” 状態であり、 <code>read</code> や <code>write</code> を受け付ける準備が整っていません。</p><p>第一引数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsocket_domain"><span class="c003">socket_domain</span></a> 型の値で、通信ドメインを指定します:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>PF_UNIX</code></td><td class="c011">ユニックスドメイン </td></tr>
<tr><td class="c011"><code>PF_INET</code></td><td class="c011">インターネットドメイン
</td></tr>
</table>
</div><p>
第二引数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsocket_type"><span class="c003">socket_type</span></a> 型の値で、通信方式を指定します:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>SOCK_STREAM</code></td><td class="c011">信頼できるバイトストリーム </td></tr>
<tr><td class="c011"><code>SOCK_DGRAM</code></td><td class="c011">信頼できないパケット </td></tr>
<tr><td class="c011"><code>SOCK_RAW</code></td><td class="c011">ネットワークの下層への直接のアクセス </td></tr>
<tr><td class="c011"><code>SOCK_SEQPACKET</code></td><td class="c011">信頼できるパケット
</td></tr>
</table>
</div><p>
第三引数は通信で使うプロトコルです。通信ドメインに対するデフォルトのプロトコル (例えば <code>SOCK_DGRAM</code> に対しては <span class="c007">udp</span>、<code>SOCK_STREAM</code> に対しては <span class="c007">tcp</span> など) を選択する <code>0</code> が通常使われます。第三引数に他の値を設定すると特殊なプロトコルを使うことができます。例えば <code>ping</code> コマンドは <span class="c007">icmp</span> (<em>Internet Control Message Protocol</em>) を使って、自動的に送信者に送り返すパケットを送ります。特殊なプロトコルに対する引数の値は <code>/etc/protocols</code> ファイルまたは <span class="c007">nis</span> (<em>Network Information Service</em>) データベース の <code>protocols</code> テーブルが存在すればそこにあります。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getprotobyname.html"><span class="c003">getprotobyname</span></a><a id="hevea_default109"></a> はプロトコルに関する情報をポータブルな形で返します。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetprotobyname">getprotobyname</a> : string -&gt; protocol_entry</div><p>引数はプロトコルの名前で、返り値は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEprotocol_entry"><span class="c003">protocol_entry</span></a> 型のレコードです。このレコードの <code>p_proto</code> フィールドがプロトコルの番号を表します。</p>
<!--TOC section id="sec122" アドレス-->
<h2 class="section" id="sec122">6.3  アドレス</h2><!--SEC END --><p>ソケットに関する操作はソケットアドレスを利用するものがあります。ソケットアドレスはヴァリアント型 <code>sockaddr</code> によって表されます:
</p><div class="mylisting"><span class="c001">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsockaddr">sockaddr</a> =
  | ADDR_UNIX <span class="c001">of</span> string
  | ADDR_INET <span class="c001">of</span> inet_addr * int</div><p><code>ADDR_UNIX f</code> は Unix ドメインにおけるアドレスです。 <code>f</code> は対応するファイルのマシンのファイルシステムにおける名前です。 <code>ADDR_INET (a,p)</code> はインターネットドメインにおけるアドレスです。 <code>a</code> がマシンのインターネットアドレスで、<code>p</code> がそのマシンのポート番号です。</p><p>インターネットアドレスは抽象型 <code>inet_addr</code> を表します。次の二つの関数は <code>128.93.8.2</code> のような形をした文字列と <code>inet_addr</code> 型の値の間の変換を行います。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALinet_addr_of_string">inet_addr_of_string</a><a id="hevea_default110"></a> : string -&gt; inet_addr
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstring_of_inet_addr">string_of_inet_addr</a><a id="hevea_default111"></a> : inet_addr -&gt; string</div><p>インターネットアドレスを調べるもう一つの方法はホストの名前を使って <code>/etc/hosts</code> にあるテーブル、<span class="c007">nis</span> データベース、あるいはドメインネームサーバから引くことです。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/gethostbyname.html"><span class="c003">gethostbyname</span></a><a id="hevea_default112"></a> がこれを行います。現代的なマシンではドメインネームサーバへの問い合わせが最初に行われ、<code>/etc/hosts</code> はフォールバックとしてしか使われませんが、一般的にはこの順番はマシンの設定によります。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgethostbyname">gethostbyname</a> : string -&gt; host_entry</div><p>引数はホストの名前で、返り値は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEhost_entry"><span class="c003">host_entry</span></a> 型のレコードです。このレコードの <code>h_addr_list</code> フィールドが目的のマシンのインターネットアドレスを表します (同じマシンが複数のネットワークに違うアドレスで接続することは可能です)。</p><p>最もよく使われるサービスが使うポート番号は <code>/etc/services</code> のテーブルにリストされており、<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getservbyname.html"><span class="c003">getservbyname</span></a><a id="hevea_default113"></a> 関数でポ−タブルに取得できます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetservbyname">getservbyname</a> : string -&gt; string -&gt; service_entry</div><p>第一引数はサービスの名前 (<span class="c007">ftp</span> サーバには <span class="c002"><code>"ftp"</code></span>、E メールには <span class="c002"><code>"smtp"</code></span>、ニュースサーバには <span class="c002"><code>"nntp"</code></span>、<code>talk</code> と <code>ntalk</code> にはコマンドと同じ文字列、など) です。第二引数はプロトコルの名前です。プロトコルの名前にはサービスの通信方式がストリーム方式の場合は <span class="c002"><code>"tcp"</code></span> が、データグラム方式の場合は<span class="c002"><code>"udp"</code></span> が通常使われます。<code>getservbyname</code> の返り値は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEservice_entry"><span class="c003">service_entry</span></a> 型の値で、<code>s_port</code> フィールドがサービスが用いるポート番号を表します。</p><div class="example">
<!--TOC paragraph id="sec123" 例-->
<h5 class="paragraph" id="sec123">例</h5><!--SEC END --><p> <code>pauillac.inria.fr</code> の <span class="c007">ftp</span> サーバのアドレスを入手するには以下のようにします:
</p><div class="mylisting">ADDR_INET((gethostbyname <span class="c002">"pauillac.inria.fr"</span>).h_addr_list.(0),
          (getservbyname <span class="c002">"ftp" "tcp"</span>).s_port)</div><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec124" サーバへの接続-->
<h2 class="section" id="sec124">6.4  サーバへの接続</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/connect.html"><span class="c003">connect</span></a><a id="hevea_default114"></a> はソケットに関連づいたサーバとの通信を確立します。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALconnect">connect</a> : file_descr -&gt; sockaddr -&gt; unit</div><p>第一引数はソケットのディスクリプタで、第二引数はサーバのアドレスです。</p><p>接続が確立されると、ソケットのディスクリプタに対する <span class="c003">write</span><a id="hevea_default115"></a> はサーバにデータを送信し、<span class="c003">read</span><a id="hevea_default116"></a> はサーバからのデータを受信します。ソケットは入出力の操作に対してパイプのように振る舞います。まず、 <code>read</code> はデータが利用可能でない場合にはブロックし、要求よりも少ないバイト数を返すことがあります。次に、サーバが接続を閉じると <code>read</code> は <code>0</code> を返し、 <code>write</code> は読んだプロセスに <code>sigpipe</code> シグナルを送ります。</p><p><code>connect</code> 関数はソケットをシステムによって選ばれたローカルアドレスにバインドします。このアドレスを手動で選んだほうが良い場合もあります。そのような場合は <code>connect</code> 関数を呼ぶ前に <code>bind</code> 関数 (<a href="#sec%2Fservice">6.7</a> 節を参照) を呼ぶことでアドレスを選ぶことができます。</p><p>Unix コマンド <code>netstat</code> は現在のマシン上の接続と状況をリストします。</p>
<!--TOC section id="sec125" ソケットの切断-->
<h2 class="section" id="sec125">6.5  ソケットの切断</h2><!--SEC END --><p>ソケットを切断する方法は二つあります。最初の方法はソケット <span class="c003">close</span><a id="hevea_default117"></a> を呼んで入出力用の接続が閉じることです。しかしこれでは大雑把すぎることがあります。例えばファイルの終端を伝えるためにクライアントからサーバの接続を閉じつつもサーバからのデータを受け取るために反対側の接続は保ちたい場合があります。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/shutdown.html"><span class="c003">shutdown</span></a><a id="hevea_default118"></a> を使うと接続の一部を切断できます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALshutdown">shutdown</a> : file_descr -&gt; shutdown_command -&gt; unit</div><p>第一引数は閉じるソケットのディスクリプタで、第二引数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEshutdown_command"><span class="c003">shutdown_command</span></a> 型の値で、どちらの方向の節毒を閉じるのかを指定します。
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c014"><code>SHUTDOWN_RECEIVE</code></td><td class="c013">読み込み用のソケットを閉じる。接続のもう一端における <code>write</code> は <code>sigpipe</code> シグナルを呼び出しプロセスに送るようになる。 </td></tr>
<tr><td class="c014"><code>SHUTDOWN_SEND</code></td><td class="c013">書き込み用のソケットを閉じる。接続のもう一端における <code>read</code> はEOF を返すようになる。 </td></tr>
<tr><td class="c014"><code>SHUTDOWN_ALL</code></td><td class="c013">読み込みと書き込み用のソケットを両方閉じる。<code>close</code> と違い、閉じられたソケットのディスクリプタは開放されない。
</td></tr>
</table>
</div><p>
ソケットの切断には <code>close</code> と <code>shutdown</code> のどちらを使っても多少の時間がかかることがあることに注意してください。</p>
<!--TOC section id="sec/univclient" 完全な例: ユニバーサルクライアント-->
<h2 class="section" id="sec/univclient">6.6  完全な例: ユニバーサルクライアント</h2><!--SEC END --><p><code>client host port</code> が <code>host</code> マシンの <code>port</code> ポートへの接続を確立するような <code>client</code>コマンドを作成します。さらにこのコマンドは標準入力からのデータを作成したソケットから送信し、受信したデータを標準出力へ書き込みます。例えば、以下のコマンド
</p><div class="mylisting">echo -e 'GET /~remy/ HTTP/1.0\r\n\r\n' | ./client pauillac.inria.fr 80</div><p>は <code>pauillac.inria.fr</code> の <code>80</code> 版ポートに接続し、ウェブページ <code>/~remy/</code> に対する <span class="c007">http</span> リクエストを送ります。</p><p><code>client</code> が行うのはクライアントとの接続を確立する部分だけであり、特定のプロトコルの実装は <code>client</code> を呼んだプログラムに任されます。この意味で、 <code>client</code> コマンドは “ユニバーサルな” クライアントアプリケーションです。</p><p>ライブラリ関数 <code>Misc.retransmit fdin fdout</code> はディスクリプタ <code>fdin</code> から読んだデータを <code>fdout</code> に書き込みます。入力ディスクリプタの終端に達するとディスクリプタを閉じずに関数は終了します。<code>retransmit</code> はシグナルで中断されることがあることに注意してください。

</p><div class="mylisting"><span class="c001">let</span> retransmit fdin fdout =
  <span class="c001">let</span> buffer_size = 4096 <span class="c001">in
  let</span> buffer = String.create buffer_size <span class="c001">in
  let rec</span> copy () = <span class="c001">match</span> read fdin buffer 0 buffer_size <span class="c001">with</span>
    | 0 -&gt; ()
    | n -&gt; ignore (write fdout buffer 0 n); copy ()
  <span class="c001">in</span>
  copy ();;</div><p>本当の問題はここからです。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Sys;;
<span class="c005">   2</span> <span class="c001">open</span> Unix;;
<span class="c005">   3</span> 
<span class="c005">   4</span> <span class="c001">let</span> client () =
<span class="c005">   5</span>   <span class="c001">if</span> Array.length Sys.argv &lt; 3 <span class="c001">then begin</span>
<span class="c005">   6</span>     prerr_endline <span class="c002">"Usage: client &lt;host&gt; &lt;port&gt;"</span>;
<span class="c005">   7</span>     exit 2;
<span class="c005">   8</span>   <span class="c001">end</span>;
<span class="c005">   9</span>   <span class="c001">let</span> server_name = Sys.argv.(1)
<span class="c005">  10</span>   <span class="c001">and</span> port_number = int_of_string Sys.argv.(2) <span class="c001">in</span>
<span class="c005">  11</span>   <span class="c001">let</span> server_addr =
<span class="c005">  12</span>     <span class="c001">try</span> (gethostbyname server_name).h_addr_list.(0)
<span class="c005">  13</span>     <span class="c001">with</span> Not_found -&gt;
<span class="c005">  14</span>       prerr_endline (server_name ^ <span class="c002">": Host not found"</span>);
<span class="c005">  15</span>       exit 2 <span class="c001">in</span>
<span class="c005">  16</span>   <span class="c001">let</span> sock = socket PF_INET SOCK_STREAM 0 <span class="c001">in</span>
<span class="c005">  17</span>   connect sock (ADDR_INET(server_addr, port_number));
<span class="c005">  18</span>   <span class="c001">match</span> fork () <span class="c001">with</span>
<span class="c005">  19</span>   | 0 -&gt; <a id="prog:add_signal_ignore"></a>
<span class="c005">  20</span>       Misc.retransmit stdin sock;
<span class="c005">  21</span>       shutdown sock SHUTDOWN_SEND;
<span class="c005">  22</span>       exit 0
<span class="c005">  23</span>   | _ -&gt;
<span class="c005">  24</span>       Misc.retransmit sock stdout;
<span class="c005">  25</span>       close stdout;
<span class="c005">  26</span>       wait ();;
<span class="c005">  27</span> 
<span class="c005">  28</span> handle_unix_error client ();;</div><p>接続するインターネットアドレスを決めることから処理が始まります。アドレスはホストネームまたは数字の形を使うことができます。<code>gethostbyname</code> がどちらの場合にも対応しているためです。それからインターネットドメインでストリームタイプのソケットをデフォルトプロトコルで作成し、決定したアドレスのマシンに接続します。</p><p>プロセスは <code>fork</code> を使ってクローンします。子プロセスは標準入力からのデータをソケットにコピーします。標準入力の終端に達すると、子プロセスは送信方向の接続を閉じて終了します。親プロセスはソケットから呼んだデータを標準出力にコピーします。ファイルの終端に達すると標準出力を閉じ、子プロセスの終了を待ってから終了します。</p><p>このプログラムにおいて、接続が切れる原因は以下の三つです:
</p><ul class="itemize"><li class="li-itemize">
子プロセスが標準入力から EOF を受け取った場合。子プロセスはクライアントからサーバ方向の接続を閉じる。これによってサーバはソケットから EOF を受け取るので、おそらくはいくらかの処理をした後に反対方向の接続を閉じる。そして親プロセスはソケットから EOF を受け取り通常終了する。
</li><li class="li-itemize">サーバが接続を閉じた場合。親プロセスはソケットから EOF を受け取り子プロセスの終了を待つ。子プロセスは次にソケットに対する <code>write</code> を実行したときに <code>sigpipe</code> シグナルを受け取って終了する。接続が切れたことは呼び出し側に報告されないが、もし必要ならば以下のコードを <a href="#prog%3Aadd_signal_ignore">19</a> 行目の後に入れることで <code>sigpipe</code> を無視することができる。
<div class="mylisting">ignore (signal sigpipe Signal_ignore)</div><p>これによって代わりに <code>EPIPE</code> エラーが出るようになる。
</p></li><li class="li-itemize">親または子プロセスが実行の途中で終了した場合、入力または出力用のソケットは閉じられる。ソケットが閉じられたことをサーバが検知した場合、サーバはその方向の接続を閉じる。これによってもう一方向の接続もしばらくしてから閉じられることになる。
</li></ul>
<!--TOC section id="sec/service" サービスの確立-->
<h2 class="section" id="sec/service">6.7  サービスの確立</h2><!--SEC END --><p>前の節でクライアントがサーバに接続する方法を見たので、今度はサーバーがクライアントにサービスを提供する方法について見ていきます。まずソケットに特定のアドレスを関連付けネットワークから到達可能にします。システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/bind.html"><span class="c003">bind</span></a><a id="hevea_default119"></a> がこれを行います。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALbind">bind</a> : file_descr -&gt; sockaddr -&gt; unit</div><p>第一引数はソケットのディスクリプタで、第二引数はバインドするアドレスです。インターネットアドレスとして定数 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALinet_addr_any"><span class="c003">inet_addr_any</span></a> を使うと、マシンが持つすべてのインターネットアドレス (複数のサブネットワーク内におけるアドレス) をバインドすることができます。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/listen.html"><span class="c003">listen</span></a><a id="hevea_default120"></a> を使ってソケットが接続を受け入れられる状態にします:
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlisten">listen</a> : file_descr -&gt; int -&gt; unit</div><p>第一引数はソケットのディスクリプタで、第二引数はサーバーがビジー状態のときに保持できるリクエストの数です(数十から大きなサーバーでは数百程度になります) 。接続を待っているクライアントが第二引数で指定した値よりも大きくなった場合、それ以降の接続リクエストは失敗します。</p><p>最後に、ソケットのディスクリプタに対するへの接続リクエストはシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/accept.html"><span class="c003">accept</span></a><a id="hevea_default121"></a> を通じて受け入れられます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALaccept">accept</a> : file_descr -&gt; file_descr * sockaddr</div><p><code>accept</code> の呼び出しが返った場合、引数として与えられたソケットは影響を受けないので続けて接続リクエストを受け入れることができます。返り値の第一要素はクライアントに接続した新しいディスクリプタです。サーバがこのディスクリプタに書き込んだデータは、クライアントが <code>connect</code> に渡したディスクリプタから読み込むことができます。またクライアントが <code>connect</code> に渡したディスクリプタに書き込んだデータは、<code>accept</code> の返り値の第一要素のディスクリプタから読み込むことができます。</p><p><code>accept</code> の返り値の第一要素はクライアントのアドレスです。接続したクライアントが接続する権限を持っているかを確認したり (例えば <span class="c007">x</span> サーバはこの処理を行います。 <code>xhost</code> で新しい許可されたユーザを追加できます)、サーバーからクライアントへの二つめの接続を作成する (<span class="c007">ftp</span> はすべてのファイル転送リクエストに対してこの処理を行います) ことに使うことができます。</p><p><span class="c007">tcp</span> サーバの一般的な構造は以下のようになっています:

</p><div class="mylisting"><span class="c001">let</span> install_tcp_server_socket addr =
  <span class="c001">let</span> s = socket PF_INET SOCK_STREAM 0 <span class="c001">in
  try</span>
    bind s addr;
    listen s 10;
    s
  <span class="c001">with</span> z -&gt; close s; raise z;;</div><p>ライブラリ関数 <code>Misc.install_tcp_server addr</code> は <code>bind</code> と <code>listen</code> を使ってストリームタイプでインターネットドメインのソケットをデフォルトプロトコルで作成し、アドレス <code>addr</code> からの接続を受けられるように準備します。この関数はライブラリ関数なので、エラーの場合にはソケットを閉じます。</p><div class="mylisting"><span class="c001">let</span> tcp_server treat_connection addr =
  ignore (signal sigpipe Signal_ignore);
  <span class="c001">let</span> server_sock = install_tcp_server_socket addr <span class="c001">in
  while true do
      let</span> client = restart_on_EINTR accept server_sock <span class="c001">in</span>
      treat_connection server_sock client
  <span class="c001">done</span>;;</div><p>ライブラリ関数 <code>Misc.tcp_server</code> は <code>Misc.install_tcp_server</code> でソケットを作成した後無限ループに入ります。ループでは <code>accept</code> を使って接続要求を待ち、受け入れた接続は <code>treat_connection</code> 関数を使って処理します。<code>treat_connection</code> はライブラリ関数なことから、<code>accept</code> が途中で終了した場合にはやり直します。また予期しない接続の切断が起こったときにサーバプログラムを終了させるのではなく、<code>EPIPE</code> 例外が <code>treat_connection</code> によって捕捉されるように<code>sigpipe</code> シグナルを無効化しておきます。接続を閉じるときにディスクリプタ <code>client</code> を閉じるのは例外の有無にかかわらず <code>treat_connection</code> の責任です。</p><p><code>treat_connection</code> 関数はアドレスの他にサーバのディスクリプタも受け取りますが、これは <code>treat_connection</code> 関数が <code>fork</code> や <code>double_fork</code> をした場合でもサーバを閉じられるようにするためです。</p><p>以下のアプリケーション特有の <code>service</code> 関数を考えます。この <code>service</code> 関数はクライアントと通信を行ってから接続を閉じます。
</p><div class="mylisting"><span class="c001">let</span> service (client_sock, client_addr) =
  <em>(* ディスクリプタが client_sock のクライアントと処理を行う *)
  (* 処理が終わったならば: *)</em>
  close client_sock;;</div><p>この場合サーバは接続を順番に処理することができます。次の <code>Misc</code> モジュールにあるライブラリ関数はこのパターンに対処します:

</p><div class="mylisting"><span class="c001">let</span> sequential_treatment server service client = service client</div><p><code>sequential_treatment</code> 関数を使った場合サーバがあるクライアントを処理している間は他の接続リクエストを処理することができないので、この関数が使えるのは <code>service</code> 関数が決まった短い時間で終わるサービスのときに限られます。</p><p>ほとんどのサーバプログラムは <code>accept</code> が返った直後に <code>fork</code> を呼ぶことでサービスの実行を子プロセスに移譲します。子プロセスが接続を処理し、親プロセスはもう一度 <code>accept</code> を行います。<code>Misc</code> モジュールの以下の関数がこの操作を行います。

</p><div class="mylisting"><span class="c001">let</span> fork_treatment server service (client_sock, _ <span class="c001">as</span> client) =
  <span class="c001">let</span> treat () = <span class="c001">match</span> fork () <span class="c001">with</span>
    | 0 -&gt; close server; service client; exit 0
    | k -&gt; ()
  <span class="c001">in</span>
  try_finalize treat () close client_sock;;</div><p>親プロセスがディスクリプタ <code>client_socket</code> を閉じることが重要であることに注意してください。ここで閉じることを忘れると子プロセスが <code>client_socket</code> を閉じても接続を終了しなくなり、すぐに親プロセスのディスクリプタが枯渇します。このディスクリプタはフォークが失敗したときにも閉じられます。エラーが致命的でなければサーバの実行が続くためです。</p><p>同様に、子プロセスは接続リクエストを受け取った <code>server</code> ディスクリプタをすぐに閉じます。一つ目の理由はこのディスクリプタが必要がないことです。二つ目の理由は子プロセスが終了する前にサーバが新しい接続の受け付けを終了する場合があることです。ml+exit 0+ の呼び出しは子プロセスがサービスの実行を終えた後に終了するためおよびサーバループを実行し始めないことを確実にするためにあるので重要です。</p><p>今までのライブラリ関数では子プロセスがいずれゾンビプロセスになり回収する必要が生じるというのを無視してきました。この問題の解決方法は二つ考えられます。一つ目のシンプルな方法はダブルフォーク ( <a href="#double-fork">??</a> ページ参照)を使って孫プロセスに接続を処理させる方法です。この方法では <code>Misc</code> モジュールの以下のライブラリ関数を使います:

</p><div class="mylisting"><span class="c001">let</span> double_fork_treatment server service (client_descr, _ <span class="c001">as</span> client) =
  <span class="c001">let</span> treat () = <span class="c001">match</span> fork () <span class="c001">with</span>
    | 0 -&gt;
        <span class="c001">if</span> fork () &lt;&gt; 0 <span class="c001">then</span> exit 0;
        close server; service client; exit 0
    | k -&gt;
        ignore (restart_on_EINTR (waitpid []) k)
  <span class="c001">in</span>
  try_finalize treat () close client_descr;;</div><p>しかしこの方法でサーバプロセスが孫プロセスを管理する方法が一切無くなってしまいます。サービスを終了するときにサーバプロセスとサービスを実行している複数のプロセス全てが終了するように、サービスを同じプロセスグループで管理するのが望ましいです。この理由からサーバはフォークを行いながらも子プロセスを回収できるようにしておくことが多いです。例えば <code>sigchld</code> シグナルのハンドラを使うことができます (<a href="#ex%2Fchilds">??</a> ページの <code>Misc.free_children</code> 関数を参照)。</p>
<!--TOC section id="sec128" ソケットの設定-->
<h2 class="section" id="sec128">6.8  ソケットの設定</h2><!--SEC END --><p>ソケットには設定できる内部変数がたくさんあります。例えば転送バッファのサイズや転送の最小サイズ、接続を閉じるときの動作などです。</p><p>これらの変数は異なった型を持ちます。そのため OCamlには型の数だけ<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetsockopt"><span class="c003">getsockopt</span></a> 関数と <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetsockopt"><span class="c003">setsockopt</span></a> 関数があります。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetsockopt"><span class="c003">getsockopt</span></a> 関数とその仲間の詳細なリストは OCamlのドキュメントを、<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getsockopt.html"><span class="c003">getsockopt</span></a><a id="hevea_default122"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/setsockopt.html"><span class="c003">setsockopt</span></a><a id="hevea_default123"></a> の厳密な意味は <span class="c007">posix</span> のリファレンスをそれぞれ参照してください。</p><div class="example">
<!--TOC paragraph id="sec129" 例-->
<h5 class="paragraph" id="sec129">例</h5><!--SEC END --><p>
この例で紹介する二つの変数はストリームタイプでインターネットドメインのソケットにしか適用することができません。</p><p><span class="c007">tcp</span> プロトコルではソケットの切断にやり取りが必要なために少し時間がかかります。通常は <span class="c003">close</span><a id="hevea_default124"></a> の呼び出しはすぐに返って切断に必要なやり取りはシステムが行います。次のコードを実行すると <code>sock</code> に対する <code>close</code> がブロックするようになります。この例では全てのデータが送られるか 5 秒が経過するまでブロックします。
</p><div class="mylisting">setsockopt_optint sock SO_LINGER (Some 5);;</div><p><code>SO_REUSEADDR</code> オプションを使うとローカルアドレスに対するソケットを閉じた直後に システムコール <span class="c003">bind</span><a id="hevea_default125"></a> で再利用することが可能になります (前の接続のデータを受け取ってしまう可能性はあります)。このオプションを使うとサーバを停止してすぐに再起動できるのでテスト用途にとても便利です。
</p><div class="mylisting">setsockopt sock SO_REUSEADDR;;</div><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec130" 完全な例: ユニバーサルなサーバ-->
<h2 class="section" id="sec130">6.9  完全な例: ユニバーサルなサーバ</h2><!--SEC END --><p>次の <code>server</code> コマンドを作成します:
</p><div class="mylisting">./server port cmd arg1 ... argn</div><p>このコマンドはポート <code>port</code> からの接続リクエストを受け取り、それぞれの接続について <code>cmd</code> を引数 <code>arg1 ... argn</code> として、標準入出力をソケットの接続として実行します。例えば以下のコマンド:
</p><div class="mylisting">./server 8500 grep foo</div><p>をマシン <code>pomerol</code> で実行し、別のマシンでユニバーサルクライアント (<a href="#sec%2Funivclient">6.6</a> ページ参照) を以下のように実行します:
</p><div class="mylisting">./client pomerol 8500 &lt; /etc/passwd</div><p>クライアントは以下のコマンドを実行したときと同じ出力を表示します:
</p><div class="mylisting">grep foo &lt; /etc/passwd</div><p><code>grep</code> がローカルのマシンではなく <code>pomerol</code> で実行される点が異なります。</p><p><code>server</code> コマンドは多くのサーバが行うコードをまとめていて、特定のサービスやコミニケーションプロトコルの実装は起動されるプログラム <code>cmd</code> に任されています。この意味で <code>service</code> コマンドは <em>ユニバーサルな</em> サーバです。</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">open</span> Sys;;
<span class="c005">   2</span> <span class="c001">open</span> Unix;;
<span class="c005">   3</span> 
<span class="c005">   4</span> <span class="c001">let</span> server () =
<span class="c005">   5</span>   <span class="c001">if</span> Array.length Sys.argv &lt; 2 <span class="c001">then begin</span>
<span class="c005">   6</span>     prerr_endline <span class="c002">"Usage: client &lt;port&gt; &lt;command&gt; [arg1 ... argn]"</span>;
<span class="c005">   7</span>     exit 2;
<span class="c005">   8</span>   <span class="c001">end</span>;
<span class="c005">   9</span>   <span class="c001">let</span> port = int_of_string Sys.argv.(1) <span class="c001">in</span>
<span class="c005">  10</span>   <span class="c001">let</span> args = Array.sub Sys.argv 2 (Array.length Sys.argv - 2) <span class="c001">in</span>
<span class="c005">  11</span>   <span class="c001">let</span> host = (gethostbyname(gethostname ())).h_addr_list.(0) <span class="c001">in</span> <a id="prog:gethost"></a>
<span class="c005">  12</span>   <span class="c001">let</span> addr = ADDR_INET (host, port) <span class="c001">in</span>
<span class="c005">  13</span>   <span class="c001">let</span> treat sock (client_sock, client_addr <span class="c001">as</span> client) =
<span class="c005">  14</span>     <em>(* ログを出力 *)</em>
<span class="c005">  15</span>     <span class="c001">begin match</span> client_addr <span class="c001">with</span>
<span class="c005">  16</span>     | ADDR_INET(caller, _) -&gt;
<span class="c005">  17</span>         prerr_endline (<span class="c002">"Connection from "</span> ^ string_of_inet_addr caller);
<span class="c005">  18</span>     | ADDR_UNIX _ -&gt;
<span class="c005">  19</span>         prerr_endline <span class="c002">"Connection from the Unix domain (???)"</span>;
<span class="c005">  20</span>     <span class="c001">end</span>;
<span class="c005">  21</span>     <em>(* 接続を処理 *)</em>
<span class="c005">  22</span>     <span class="c001">let</span> service (s, _) =
<span class="c005">  23</span>       dup2 s stdin; dup2 s stdout; dup2 s stderr; close s;
<span class="c005">  24</span>       execvp args.(0) args
<span class="c005">  25</span>     <span class="c001">in</span>
<span class="c005">  26</span>     Misc.double_fork_treatment sock service client <span class="c001">in</span>
<span class="c005">  27</span>   Misc.tcp_server treat addr;;
<span class="c005">  28</span> 
<span class="c005">  29</span> handle_unix_error server ();;</div><p><code>tcp_server</code> に渡されるアドレスにはプログラムを実行しているマシンのインターネットアドレスが含まれます。このアドレスを取得するには普通 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgethostname"><span class="c003">gethostname</span></a><a id="hevea_default126"></a> を使います(<a href="#prog%3Agethost">11</a> 行目)。しかし一般的には複数のアドレスが一つのマシンを指していることがあります。例えばマシン <code>pauillac</code> のアドレスが <code>128.93.11.35</code> だったとしても、ローカルならば (すでに <code>pauillac</code> の中にいるならば)このマシンには <code>127.0.0.1</code> を使ってアクセスすることができます。定数インターネットアドレス <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALinet_addr_any"><span class="c003">inet_addr_any</span></a> を使えば、マシンを指す全てのアドレスにサービスを行うことができます。</p><p>サービスは “ダブルフォーク” で処理されます。孫プロセスによって実行される <code>service</code> は標準入力と標準出力、そして標準エラー出力をソケットにリダイレクトしてからコマンドを実行します。サービスの処理をブロックしながら順番に行うことはできないことに注意してください。</p><p>クライアントからの接続は <code>server</code> の親プロセスからの介入なしに閉じられます。以下の三つのケースが考えられます。</p><ul class="itemize"><li class="li-itemize">
クライアントがサーバ方向の接続を閉じた。サーバによって起動されたコマンドは標準入力に EOF を受け取る。行うべきを行った後、コマンドを実行するプロセスは <code>exit</code> を実行して終了する。これによって標準出力が閉じられ、このディスクリプタはクライアントにつながるソケットの出力を指す最後のディスクリプタであるから、クライアントは次の読み込みで EOF を受け取る。</li><li class="li-itemize">クライアントが途中で終了し、サーバからクライアント方向の接続が閉じた。サーバによって起動されたコマンドは次の書き込みで <code>sigpipe</code> シグナルを受け取る場合がある。これによってプロセスが終了するが、誰もコマンドの出力を読んでいないことから、これは問題ない。</li><li class="li-itemize">サーバによって起動されたコマンドが入力から EOF を読む前に終了した。クライアントは次に書き込みで <code>sigpipe</code> シグナル (あるいは <code>EPIPE</code> 例外) を受け取る。
</li></ul><!--TOC subsection id="sec131" 注意点-->
<h3 class="subsection" id="sec131">注意点</h3><!--SEC END --><p>サーバを書くのはクライアントを書くよりも労力が要ります。クライアントは接続するサーバのことを普通知っているのに対し、サーバはクライアントのことを何も知らないからです。とくにサーバがパブリックな場合、クライアントは “敵” である可能性があります。そのため例外的なケースに対する防御をしなければいけません。</p><p>典型的な攻撃は接続を開けた後リクエストを送ることなく開いたままにするというものです。接続を受け入れた後サーバはクライアントが接続している間ずっとブロックします。攻撃者は何もしない接続を大量に開くことでサービスを飽和させることができます。そのためサーバは同時接続数を制限してリソースを枯渇を防ぐと共に、長い間何もしていない接続を終了させる必要があります。</p><p>サーバがフォークを行わず、接続を来た順番に処理する場合、このブロッキングの問題が生じることになります。処理している接続は何もしていないにもかかわらず他の接続に応答することができなくなります。順番に処理するサーバに対する解決法として通信の多重化がありますが、これは実装するのが難しくなります。並列サーバはよりエレガントですが、それでもタイムアウトは必要になります。タイムアウトには例えばアラームを使うことができます(<a href="#sec%2Fusingsignals">4.2</a> 節参照)。</p>
<!--TOC section id="sec/mode-deconnecte" コネクションレス型通信-->
<h2 class="section" id="sec/mode-deconnecte">6.10  コネクションレス型通信</h2><!--SEC END --><p><code>SOCK_STREAM</code> タイプの接続のほとんどで使われる <span class="c007">tcp</span> プロトコルではコネクション型通信だけを使うことができます。逆に、<code>SOCK_DGRAM</code> タイプの接続のほとんどで使われる <span class="c007">udp</span> プロトコルでは常にコネクションレス型通信が使われ、二つのマシンの間には確立された接続がありません。このタイプのソケットではデータの転送はシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/recvfrom.html"><span class="c003">recvfrom</span></a><a id="hevea_default127"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/sendto.html"><span class="c003">sendto</span></a><a id="hevea_default128"></a> を使って行われます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrecvfrom">recvfrom</a> :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int * sockaddr

<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsendto">sendto</a> :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; sockaddr -&gt; int</div><p>転送されたデータのサイズを返すという点で、インタフェースは <code>read</code> と <code>write</code> に似ています。<code>recvfrom</code> は読み込んだバイト数の他にデータを送っているマシンのアドレスも返します。</p><p><code>SOCK_DGRAM</code> タイプのソケットに <span class="c003">connect</span><a id="hevea_default129"></a> を呼ぶと疑似接続が取得できます。この疑似接続は本当は存在せず、 <span class="c003">connect</span><a id="hevea_default130"></a> の引数に渡されたアドレスがソケットによって記憶され、データの送受信で使われるようになるというだけです (他のアドレスからのデータは無視されます)。<code>connect</code> を複数回読んでアドレスを変更したり、0 などの無効なアドレスを渡して疑似接続を切断することは可能です。反対にストリームタイプのソケットにこのようなことを行うとエラーが出ます。</p>
<!--TOC section id="sec133" 低レベル入出力-->
<h2 class="section" id="sec133">6.11  低レベル入出力</h2><!--SEC END --><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/recv.html"><span class="c003">recv</span></a><a id="hevea_default131"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/send.html"><span class="c003">send</span></a><a id="hevea_default132"></a> はそれぞれ <span class="c003">read</span><a id="hevea_default133"></a> と <span class="c003">write</span><a id="hevea_default134"></a> に対応しますが、ソケットのディスクリプタ専用です。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrecv">recv</a> : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; msg_flag list -&gt; int
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsend">send</a> : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; msg_flag list -&gt; int</div><p><a href="http://www.opengroup.org/onlinepubs/009696799/functions/recv.html"><span class="c003">recv</span></a><a id="hevea_default135"></a> と <a href="http://www.opengroup.org/onlinepubs/009696799/functions/send.html"><span class="c003">send</span></a><a id="hevea_default136"></a> のインタフェースは <code>read</code> と <code>write</code> に似ていますが、<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEmsg_flag"><span class="c003">msg_flag</span></a> 型のフラグのリストが引数に追加されています。この型の値と意味を次に示します:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c011"><code>MSG_OOB</code></td><td class="c011">アウトオブバンドデータを処理する。 </td></tr>
<tr><td class="c011"><code>MSG_DONTROUTE</code></td><td class="c011">デフォルトのルーティングテーブルを使用しない。 </td></tr>
<tr><td class="c011"><code>MSG_PEEK</code></td><td class="c011">データを読むことなく確認だけ行う。
</td></tr>
</table>
</div><p>
これらのプリミティブ (原始的な関数) はコネクション型通信通信でも <code>read</code> と <code>write</code> の代わりに利用できるほか、疑似通信モードでも <code>recvfrom</code> と <code>sendto</code> の代わりに利用できます。</p>
<!--TOC section id="sec134" 高レベルプリミティブ-->
<h2 class="section" id="sec134">6.12  高レベルプリミティブ</h2><!--SEC END --><p>ユニバーサルクライアント/サーバの例はよく利用されるので、<code>Unix</code> モジュールにはネットワークサービスを確立したり利用するための高レベルな関数があります。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopen_connection">open_connection</a><a id="hevea_default137"></a> : sockaddr -&gt; in_channel * out_channel
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALshutdown_connection">shutdown_connection</a><a id="hevea_default138"></a> : Pervasives.in_channel -&gt; unit</div><p><code>open_connection</code> は引数のアドレスに対する接続を開き、そのソケットに対する入出力用の <code>Pervasives</code> チャンネルの組を作成します。返り値のチャンネルに対する入出力はサーバとの通信となりますが、チャンネルはバッファされるために、リクエストを本当に送られたことを保証するにはチャンネルをフラッシュする必要があります。クライアントはチャンネルを閉じる (この操作はソケットも閉じます) ことで任意のタイミングで接続を閉じることができるほか、 <code>shutdown_connection</code> を使って “きれいに” 接続を閉じることもできます。サーバが接続を閉じた場合、クライアントは入力チャンネルから EOF を受け取ります。</p><p><code>establish_server</code> 関数でサービスを確立することができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALestablish_server">establish_server</a><a id="hevea_default139"></a> :
  (in_channel -&gt; out_channel -&gt; unit) -&gt; sockaddr -&gt; unit</div><p><code>establish_server f addr</code> はアドレス <code>addr</code> にサービスを確立し、リクエストを関数 <code>f</code> で処理します。コネクションがあるたびにサーバは新しいソケットを作成してフォークします。子プロセスはクライアントと通信に利用する入出力用の <code>Pervasives</code> チャンネルを作成し <code>f</code>に渡します。<code>f</code> が返ると子プロセスはソケットを閉じて終了します。クライアントが接続をきれいに閉じたならば、子プロセスは入力チャンネルに EOF を受け取ります。そうでなくクライアントが接続を突然閉じた場合には <code>f</code> が書き込みを行おうとしたときに <code>sigpipe</code> を受け取ります。いずれの場合でもこのとき親プロセスは他のリクエストを処理しているはずです。<code>establish_server</code> はエラー (サービスの確立時の OCamlランタイムやシステムのエラーなど) の場合を除いて返りません。</p>
<!--TOC section id="sec135" プロトコルの例-->
<h2 class="section" id="sec135">6.13  プロトコルの例</h2><!--SEC END --><p>クライアントとサーバの間でやり取りされるデータは単純なプロトコル (<code>rsh</code>, <code>rlogin</code>, …) ではクライアントからサーバへ、およびサーバからクライアントへの二つのバイト列として自然に表現できます。その他のプロトコルではやり取りされるデータはもっと複雑であり、バイト列からデータへ、あるいはデータからバイト列へのデコード/エンコードが必要になります。クライアントとサーバはリクエストの形式と接続で交わされるレスポンスについて取り決めた転送プロトコルについて合意しておく必要があります。Unix コマンドが利用するプロトコルの多くは “<span class="c007">rfc</span>” (request for comments) と呼ばれるドキュメントに記載されています。これらのドキュメントは議論のための提案として始まりましたが、時が経ちユーザがこのプロトコルに慣れるにしたがって標準となりました<sup><a id="text10" href="#note10">2</a></sup>。</p><!--TOC subsection id="sec136" “バイナリ” プロトコル-->
<h3 class="subsection" id="sec136">“バイナリ” プロトコル</h3><!--SEC END --><p>バイナリプロトコルの多くはデータをメモリ内の表現にできるだけ近いコンパクトな形式で転送します。エンコード/デコードに必要な処理を最小化しネットワーク帯域を節約するためです。このタイプのプロトコルの典型的な例は <span class="c007">x</span> サーバと <span class="c007">x</span> アプリケーションの間の通信で利用される <span class="c007">x</span>-window プロトコルと <span class="c007">nfs</span> プロトコル (<a href="http://www.faqs.org/rfcs/rfc1094.html"><span class="c007">rfc</span> 1094</a>) です。</p><p>バイナリプロトコルはデータを次のようにエンコードすることが多いです。整数と浮動小数点数には同じ 1, 2, 4, あるいは 8 バイトのバイナリ表現が使われます。文字列には長さを示す整数とその後に続く内容で表現されます。構造化されたオブジェクト (タプル、レコード) はフィールドを順番通りに並べて表現されます。可変長のオブジェクト (配列、リスト) は長さを表す整数とそれに続く要素で表現されます。転送されるデータの型が正確に分かっているならば、受け取ったプロセスは簡単にメモリ上に復元できます。そうでなく異なるタイプのデータがソケットでやり取りされた場合、データのエンコードはタイプを表すデータ先頭の整数を読み取ってから行われます。</p><div class="example">
<!--TOC paragraph id="sec137" 例-->
<h5 class="paragraph" id="sec137">例</h5><!--SEC END --><p>
<span class="c007">x</span> ライブラリの <code>XFillPolygon</code> 関数は
多角形を塗りつぶす関数であり、以下の形のメッセージを送信します:
</p><ul class="itemize"><li class="li-itemize">
バイト 69 (<code>FillPoly</code> コマンドの番号)
</li><li class="li-itemize">パディングバイト
</li><li class="li-itemize">多角形の頂点数 <span class="c006">n</span> を表す 16 ビット整数
</li><li class="li-itemize">描画するウィンドウを表す 32 ビット整数
</li><li class="li-itemize">“グラフィクスコンテキスト” を表す 32 ビット整数
</li><li class="li-itemize">“形” を表すバイト。 多角形が凸であるか、など。
</li><li class="li-itemize">頂点の座標が絶対か相対かを表すバイト
</li><li class="li-itemize">頂点の座標を 16 ビット整数でエンコードした 4<span class="c006">n</span> バイト
</li></ul><div class="fancybreak">* * *</div></div><p>バイナリプロトコルでは接続するマシンのアーキテクチャに注意する必要があります。例えば複数のバイトからなる整数は <em>ビッグエンディアン</em> のマシンでは最上位バイトを先に (メモリの若いアドレスに) 格納しますが、 <em>リトルエンディアン</em>のマシンでは最下位バイトが先になります。16 ビット整数 12345 = 48 × 256 + 57はビッグエンディアンのマシンではアドレスが <span class="c006">n</span> の場所に 48 が、 <span class="c006">n</span>+1 の場所に 57 が格納されますが、リトルエンディアンのマシンではアドレスが <span class="c006">n</span> の場所に 57 が、 <span class="c006">n</span>+1 の場所に 48 が格納されます。このためプロトコルは複数のバイトからなる整数を転送する場合にどちらの方法を使うのかを指定する必要があります。あるいは転送されるメッセージのヘッダにどちらの方法を使うか書くことでどちらも使えるようにすることもできます。</p><p>OCamlシステムにはデータ構造をエンコード/デコードする (文献によっては <em>マーシャリング</em> とか <em>シリアライゼーション</em> とか <em>ピックリング</em> などと呼ばれる処理です) ための関数が二つあります。これらの関数を使うと OCamlの値とバイト列の間の変換を行うことができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_value">output_value</a><a id="hevea_default140"></a> : out_channel -&gt; 'a -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_value">input_value</a><a id="hevea_default141"></a> : in_channel -&gt; 'a</div><p><code>output_values</code> と <code>input_values</code> は値をディスクに保存してあとで読み出せるようにするための関数ですが、任意の値をパイプやソケットへ送ることにも利用できます。関数を除く全ての OCamlの値を処理でき、値の間の共有や循環を保存し、エンディアンの異なるマシン間でも利用できます。これ以上の情報は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html"><span class="c003">Marshal</span></a> モジュールで確認できます。</p><p>セマンティクス上は <code>input_value</code> の型が間違っていることを指摘しておきます。全ての型 <code>'a</code> に対して <code>input_value</code> の返り値の型が<code>'a</code> になることはないので、この関数の型は一般的すぎます。<code>input_value</code> の返り値は明確な型であり、全ての可能な型ではありませんが、これをコンパイル時にチェックすることはできません。返り値の型は実行時に入力チャンネルから読み込むデータに依存しているからです。<code>input_value</code> に正しく型検査を行うにはダイナミックオブジェクトと呼ばれる ML 言語の拡張が必要になります。ダイナミックオブジェクトでは値が型と組にされ、実行時の型検査が可能になります。詳細は [<a href="#Dynamiques">15</a>] を参照してください。</p><div class="example">
<!--TOC paragraph id="sec138" 例-->
<h5 class="paragraph" id="sec138">例</h5><!--SEC END --><p>
<span class="c007">x</span>-ウィンドウプロトコルが OCamlで書かれていたならば、サーバへのクエストのためのヴァリアント型 <code>request</code> とサーバからのレスポンスのためのヴァリアント型 <code>reply</code> が定義されていたでしょう。
</p><div class="mylisting"><span class="c001">type</span> request =
  | FillPolyReq <span class="c001">of</span> (int * int) array * drawable * graphic_context
                                    * poly_shape * coord_mode
  | GetAtomNameReq <span class="c001">of</span> atom
  | ...
<span class="c001">and</span> reply =
  | GetAtomNameReply <span class="c001">of</span> string
  | ...</div><p>サーバの主な処理はリクエストをデコードして返事を書くループとなるはずです:
</p><div class="mylisting"><em>(* 接続リクエストをディスクリプタ s に受け取る *)</em>
<span class="c001">let</span> requests = in_channel_of_descr s
<span class="c001">and</span> replies  = out_channel_of_descr s <span class="c001">in
try
  while true do
    match</span> input_value requests <span class="c001">with</span>
        ...
      | FillPoly(vertices, drawable, gc, shape, mode) -&gt;
          fill_poly vertices drawable gc shape mode
      | GetAtomNameReq atom -&gt;
          output_value replies (GetAtomNameReply(get_atom_name atom))
      | ...
  <span class="c001">done
with</span> End_of_file -&gt; <em>(* 接続の終了 *)</em></div><p>アプリケーションとリンクされる <span class="c007">x</span> ライブラリの関数は次のような構造になるでしょう:
</p><div class="mylisting"><em>(* まずサーバとの接続を確立してディスクリプタを s とする *)</em>
...
<span class="c001">let</span> requests = out_channel_of_descr s
<span class="c001">and</span> replies  = in_channel_of_descr s;;

<span class="c001">let</span> fill_poly vertices drawable gc shape mode =
  output_value requests
               (FillPolyReq(vertices, drawable, gc, shape, mode));;
<span class="c001">let</span> get_atom_name atom =
  output_value requests (GetAtomNameReq atom);
  <span class="c001">match</span> input_value replies <span class="c001">with</span>
  | GetAtomNameReply name -&gt; name
  | _ -&gt; fatal_protocol_error <span class="c002">"get_atom_name"</span>;;</div><div class="fancybreak">* * *</div></div>
<!--TOC paragraph id="sec139" 遠隔手続き呼び出し-->
<h5 class="paragraph" id="sec139">遠隔手続き呼び出し</h5><!--SEC END --><p>バイナリプロトコルのもう一つの使用例は遠隔手続き呼び出しです。遠隔手続き呼び出しとは、マシン A のユーザがマシン B で関数を <code>f</code> を実行するというものです。関数を直接呼び出すことは当然できません。ですが、マシン B に接続して関数を実行し、結果をマシン A に送り返すという作業を呼び出しごとにプログラムすることは可能です。</p><div class="figure">
<div class="image"><img src="ocamlunix-image21.png" width="80%"></div>



<a id="fig/rpc"></a>
<div class="caption">Figure 4 — 遠隔手続き呼び出し</div></div><p>遠隔手続き呼び出しは一般的な状況であるために、これを行う <span class="c007">rpc</span> サービスが存在します (図 <a href="#fig%2Frpc">4</a>)。<span class="c007">rpc</span> サーバはマシン A と B の両方で実行され、以下のように動作します。まずマシン A 上のユーザがマシン A 上の <span class="c007">rpc</span> サーバに遠隔地のマシン B 上における関数の実行をリクエストします。次にマシン A 上の <span class="c007">rpc</span> サーバはリクエストをマシン B 上の <span class="c007">rpc</span> サーバにリレーし、マシン B は <code>f</code> を実行して結果をマシン A 上の <span class="c007">rpc</span> サーバに送り返します。最後にマシン A 上の <span class="c007">rpc</span> サーバが結果をユーザに渡して終わりです。</p><p>マシン B 上で実行される他の関数に対する遠隔手続き呼び出しが、マシン A 上の同じ <span class="c007">rpc</span> サーバで処理されることになります。マシン A と B にインストールされた <span class="c007">rpc</span> サービスの間で接続処理は共有され、ユーザからはこれらの遠隔手続き呼び出しの処理が単純な関数呼び出しに見えます (図の破線)。</p><!--TOC subsection id="sec140" “テキスト” プロトコル-->
<h3 class="subsection" id="sec140">“テキスト” プロトコル</h3><!--SEC END --><p>プロトコルの効率が重要でないネットワークサービスでは “テキスト” プロトコルがよく利用されます。 “テキスト” プロトコルは実際のところ小さなコマンド言語です。リクエストは複数のコマンドであり、最初の語がリクエストのタイプを、残りの語がコマンドの引数を表します。応答も一つ以上のテキストからなり、大抵は応答の種類を表す数字コードから始まります。“テキスト” プロトコルの例をいくつか示します:
</p><div class="center">
<table class="c000 cellpading0"><tr><td class="c011">名前</td><td class="c011">説明</td><td class="c011">目的 </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c011"><span class="c007">smtp</span> (Simple Mail Transfer Protocol)</td><td class="c011"><a href="http://www.faqs.org/rfcs/rfc821.html"><span class="c007">rfc</span> 821</a>
</td><td class="c011">電子メール
</td></tr>
<tr><td class="c011"><span class="c007">ftp</span>
(File Transfer Protocol)</td><td class="c011"><a href="http://www.faqs.org/rfcs/rfc959.html"><span class="c007">rfc</span> 959</a>
</td><td class="c011">ファイル転送
</td></tr>
<tr><td class="c011"><span class="c007">nntp</span>
(Network News Transfer Protocol)</td><td class="c011"><a href="http://www.faqs.org/rfcs/rfc977.html"><span class="c007">rfc</span> 977</a>
</td><td class="c011">ニュースの閲覧
</td></tr>
<tr><td class="c011"><span class="c007">http</span>/1.0 (HyperText Transfer Protocol)</td><td class="c011"><a href="http://www.faqs.org/rfcs/rfc1945.html"><span class="c007">rfc</span> 1945</a>
</td><td class="c011">ウェブの巡回
</td></tr>
<tr><td class="c011"><span class="c007">http</span>/1.1 (HyperText Transfer Protocol)</td><td class="c011"><a href="http://www.faqs.org/rfcs/rfc2068.html"><span class="c007">rfc</span> 2068</a>
</td><td class="c011">ウェブの巡回<br>
</td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
</div><p>
これらのプロトコルの大きな利点はクライアントとサーバ間のやり取りが人間にも読めることです。例えば <code>telnet</code> コマンドを使ってサーバと直接対話することができます。<code>host</code> を接続するホストの名前、 <code>service</code> をサーバで実行されたサービスの名前 (<code>http</code> や<code>smtp</code>、 <code>nntp</code> など) として <code>telnet host service</code> を起動すると、クライアントとしてのリクエストを打ち込ことができ、それに対するサーバからの応答は標準出力に出力されます。これによってプロトコルは理解しやすくなりますが、コーディングとリクエストと応答のデコードはバイナリプロトコルよりも複雑になり、メッセージはより大きく、したがって非効率になる傾向にあります。</p><div class="example">
<!--TOC paragraph id="sec141" 例-->
<h5 class="paragraph" id="sec141">例</h5><!--SEC END --><p>
シェルから <span class="c007">smtp</span> サーバにメールを送ったときの対話ログの例を示します。&gt;&gt; から始まる行はクライアントからサーバへ向かうテキストであり、&lt;&lt; から始まる行はサーバからクライアントへ向かうテキストです。

</p><div class="mylisting">    telnet margaux smtp
    Trying 128.93.8.2 ...
    Connected <span class="c001">to</span> margaux.inria.fr.
    Escape character is '^]'.
&lt;&lt;  220 margaux.inria.fr Sendmail 5.64+/AFUU-3 ready at Wed, 15 Apr 92 17:40:59
&gt;&gt;  HELO pomerol.inria.fr
&lt;&lt;  250 Hello pomerol.inria.fr, pleased <span class="c001">to</span> meet you
&gt;&gt;  MAIL From:&lt;god@heavens.sky.com&gt;
&lt;&lt;  250 &lt;god@heavens.sky.com&gt;... Sender ok
&gt;&gt;  RCPT To:&lt;xleroy@margaux.inria.fr&gt;
&lt;&lt;  250 &lt;xleroy@margaux.inria.fr&gt;... Recipient ok
&gt;&gt;  DATA
&lt;&lt;  354 Enter mail, <span class="c001">end with</span> <span class="c002">"."</span> on a line by itself
&gt;&gt;  From: god@heavens.sky.com (Himself)
&gt;&gt;  To: xleroy@margaux.inria.fr
&gt;&gt;  Subject: Hello!
&gt;&gt;
&gt;&gt;  Is everything ok down there?
&gt;&gt;  .
&lt;&lt;  250 Ok
&gt;&gt;  QUIT
&lt;&lt;  221 margaux.inria.fr closing connection
    Connection <span class="c001">closed</span> by foreign host.</div><p>
コマンド <code>HELO</code>、<code>MAIL</code> そして <code>RCPT</code> はそれぞれクライアントのマシン名、送信者のアドレス、受信者のアドレスをサーバに送信します。<code>DATA</code> コマンドは電子メールの本文を送信してよいかをサーバに訪ねます。その後にメールの本文を入力し、 <code>'.'</code> だけからなる行で終了します(この文字だけからなる行をメール本文に含めたい場合には、<code>'.'</code> を二つ書いておけばサーバは一つ目のピリオドを読み飛ばします) 。</p><p>サーバからの応答は全てコメントのついた 3 桁の数字コードです。<code>5xx</code> の形をした応答はエラーを表し、 <code>2xx</code> は全てが上手くいっていることを表します。クライアントが実際のプログラムであれば応答コードだけを解釈します。コメントはメールシステムの開発者を助けるために存在します。
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec142" 完全な例: <span class="c007">http</span> リクエスト-->
<h2 class="section" id="sec142">6.14  完全な例: <span class="c007">http</span> リクエスト</h2><!--SEC END --><p><span class="c007">http</span>(HyperText Transfer Protocol) プロトコルは有名な “ワールドワイドウェブ” でドキュメントを読むのに主に使われます。この分野はクライアント-サーバの例のニッチな領域です。ページを読み込むクライアントとページを書き込むサーバの間には無数の中継リレーが存在し、それらは実際のクライアントに対して仮想サーバとして振る舞ったり、物理サーバに対して移譲されたクライアントとして振る舞ったりします。これらのリレーではキャッシングやフィルタリングなどのサービスがよく実行されます。</p><p><span class="c007">http</span>プロトコルにはいくつかのバージョンがあります。本質的な部分、つまりクライアントとリレーのアーキテクチャ、に集中するために、一番最初のバージョンの <span class="c007">http</span>プロトコルを改変したシンプルなプロトコルを使います。このプロトコルはホコリをかぶっていますが、それでもほとんどのサーバによって理解されます。節の最後にはウェブを探索する本物のツールを作るために必要となる、より現代的でより複雑なバージョンのプロトコルを示します。ただし例をこの新しいバージョンに書き直す部分は練習問題として残しておきます。</p><p><span class="c007">http</span>プロトコルのバージョン 1.0 は <a href="http://www.faqs.org/rfcs/rfc1945.html"><span class="c007">rfc</span> 1945</a> で規定され、以下の形のリクエストを定義しています:
</p><div class="mylisting">GET <span class="c006">sp uri crlf</span></div><p>ここで <code><span class="c006">sp</span></code> はスペースを、 <code><span class="c006">crlf</span></code> は文字列<span class="c002"><code>"\r\n"</code></span> (“リターン” と改行) を表します。この単純なリクエストに対する応答もシンプルであり、応答はヘッダの何もない <span class="c007">url</span>の要素そのものです。</p><p>リクエストの終端は EOF によって合図され、そこで接続が閉じられます。バージョン 0.9 のプロトコルから受け継いだこの形のリクエストは一つの接続に対するリクエストを一つだけに制限します。</p><!--TOC subsection id="sec143" <span class="c007">url</span> の取得-->
<h3 class="subsection" id="sec143"><span class="c007">url</span> の取得</h3><!--SEC END --><p>引数 <span class="c007">url</span>を一つ取り、それが表すウェブ上のリソースを取得して表示するプログラム <code>geturl</code> を作ります。</p><p>最初のタスクは <span class="c007">url</span>をパースしてプロトコルの名前 (ここでは <span class="c002"><code>"http"</code></span> でなくてはいけません)、サーバのアドレス、ポート番号 (無くても良い)、そしてサーバ上のドキュメントの絶対パスを取り出すことです。この処理には OCamlの正規表現ライブラリ <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html"><span class="c003">Str</span></a> を使います。
</p><div class="mylisting"><span class="c001">open</span> Unix;;

<span class="c001">exception</span> Error <span class="c001">of</span> string
<span class="c001">let</span> error err mes = raise (Error (err ^ <span class="c002">": "</span> ^ mes));;
<span class="c001">let</span> handle_error f x = <span class="c001">try</span> f x <span class="c001">with</span> Error err -&gt; prerr_endline err; exit 2

<span class="c001">let</span> default_port = <span class="c002">"80"</span>;;

<span class="c001">type</span> regexp = { regexp : Str.regexp; fields : (int * string option) list; }

<span class="c001">let</span> regexp_match r string =
  <span class="c001">let</span> get (pos, default) =
    <span class="c001">try</span> Str.matched_group pos string
    <span class="c001">with</span> Not_found -&gt;
      <span class="c001">match</span> default <span class="c001">with</span> Some s -&gt; s | _ -&gt; raise Not_found <span class="c001">in
  try
    if</span> Str.string_match r.regexp string 0 <span class="c001">then</span>
      Some (List.map get r.fields)
    <span class="c001">else</span> None
  <span class="c001">with</span> Not_found -&gt; None;;

<span class="c001">let</span> host_regexp =
  { regexp = Str.regexp <span class="c002">"\\([^/:]*\\)\\(:\\([0-9]+\\)\\)?"</span>;
    fields = [ 1, None; 3, Some default_port; ] };;

<span class="c001">let</span> url_regexp =
  { regexp = Str.regexp <span class="c002">"http://\\([^/:]*\\(:[0-9]+\\)?\\)\\(/.*\\)"</span>;
    fields = [ 1, None; 3, None ] };;

<span class="c001">let</span> parse_host host = <span class="c001">match</span> regexp_match host_regexp host <span class="c001">with</span>
  | Some (host :: port :: _) -&gt; host, int_of_string port
  | _ -&gt; error host <span class="c002">"Ill formed host"</span>;;

<span class="c001">let</span> parse_url url = <span class="c001">match</span> regexp_match url_regexp url <span class="c001">with</span>
  | Some (host :: path :: _) -&gt; parse_host host, path
  | _ -&gt; error url <span class="c002">"Ill formed url"</span>;;</div><p>次の関数が示すように、シンプルなリクエストの送信は簡単な処理です。
</p><div class="mylisting"><span class="c001">let</span> send_get url sock =
  <span class="c001">let</span> s = Printf.sprintf <span class="c002">"GET %s\r\n"</span> url <span class="c001">in</span>
  ignore (write sock s 0 (String.length s));;</div><p><span class="c007">url</span>はサーバのアドレスとポート番号を含む完全なものであるか、そうでなければアドレスとサーバ上のパスだけが含まれるものであることに注意してください。</p><p>応答はドキュメントの内容だけを含み追加の情報を含まないので、応答を読み込むのはより簡単です。リクエストにエラーがあった場合、サーバからはエラーメッセージが<span class="c007">html</span> ドキュメントとして返ります。このことから、応答がエラーかどうかを確認することなく <code>Misc.retransmit</code> を使って出力すればすむことがわかります。プログラムの残りの部分ではサーバとの接続を確立します。
</p><div class="mylisting"><span class="c001">let</span> get_url proxy url fdout =
  <span class="c001">let</span> (hostname, port), path = <span class="c001">match</span> proxy <span class="c001">with</span>
    | None -&gt; parse_url url
    | Some host -&gt; parse_host host, url
  <span class="c001">in
  let</span> hostaddr =
    <span class="c001">try</span> inet_addr_of_string hostname
    <span class="c001">with</span> Failure _ -&gt;
      <span class="c001">try</span> (gethostbyname hostname).h_addr_list.(0)
      <span class="c001">with</span> Not_found -&gt; error hostname <span class="c002">"Host not found"</span>
  <span class="c001">in
  let</span> sock = socket PF_INET SOCK_STREAM 0 <span class="c001">in</span>
  Misc.try_finalize
    <span class="c001">begin function</span> () -&gt;
      connect sock (ADDR_INET (hostaddr, port));
      send_get path sock;
      Misc.retransmit sock fdout
    <span class="c001">end</span> ()
    close sock;;</div><p>いつもどおり、コマンドライン引数のパースする処理を追加して完成です。

</p><div class="mylisting"><span class="c001">let</span> geturl () =
  <span class="c001">let</span> len =  Array.length Sys.argv <span class="c001">in
  if</span> len &lt; 2 <span class="c001">then</span>
    error <span class="c002">"Usage:"</span> (Sys.argv.(0) ^ <span class="c002">" [ proxy [:&lt;port&gt;] ] &lt;url&gt;"</span>)
  <span class="c001">else
    let</span> proxy, url =
      <span class="c001">if</span> len &gt; 2 <span class="c001">then</span> Some Sys.argv.(1), Sys.argv.(2) <span class="c001">else</span>
      None, Sys.argv.(1)
    <span class="c001">in</span>
    get_url proxy url stdout;;

handle_unix_error (handle_error geturl) ();;</div><!--TOC subsection id="sec/relay" <span class="c007">http</span> リレー-->
<h3 class="subsection" id="sec/relay"><span class="c007">http</span> リレー</h3><!--SEC END --><p>この節では <span class="c007">http</span>リレー (あるいは <em>プロキシ</em>) プログラムを作成します。このプログラムはクライアントからの <span class="c007">http</span>リクエストを他のサーバにリダイレクト(あるいはリレー) し、応答をクライアントに転送します。</p><p>リレーの役割を図 <a href="#fig%2Frelais">5</a> に示します。クライアントがリレーを使った場合、そのリクエストは世界中に存在する個々の<span class="c007">http</span>サーバではなくリレーサーバに送信します。リレーにはいくつもの利点があります。まず、リレーサーバは最後の、あるいは頻繁に送られる応答を記録してリモートサーバに問い合わせることなくリクエストに答えることができます。これによってネットワークの過負荷を避け、サーバがダウンしているときでも応答が得られるようになります。次に、広告や画像の削除といった応答のフィルターを行うことができます。また、ワールドワイドウェブ全体を一つのサーバを通して見るようにすることでプログラムの開発が容易になります。</p><div class="figure">
<div class="image"><img src="ocamlunix-image22.png" width="70%"></div>



<a id="fig/relais"></a>
<div class="caption">Figure 5 — <span class="c007">http</span> リレー</div></div><p>コマンド <code>proxy port</code> が <code>port</code> 番ポート (省略された場合は <span class="c007">http</span>プロトコルのデフォルトのポート番号) にリレーサーバを作成するようなコマンド <code>proxy</code> を作成します。<code>get_url</code> 関数を作るときに使った関数のコードを <code>Url</code> モジュールに入れて再利用します。書くべきなのはリクエストの解析とサーバの立ち上げの部分だけです。
</p><div class="mylisting"><span class="c001">open</span> Unix
<span class="c001">open</span> Url

<span class="c001">let</span> get_regexp =
  { regexp = Str.regexp <span class="c002">"^[Gg][Ee][Tt][ \t]+\\(.*[^ \t]\\)[ \t]*\r"</span>;
    fields = [ 1, None ] }

<span class="c001">let</span> parse_request line = <span class="c001">match</span> regexp_match get_regexp line <span class="c001">with</span>
  | Some (url :: _) -&gt; url
  | _ -&gt; error line <span class="c002">"Ill formed request"</span></div><p>サービスを確立には <code>establish_server</code> 関数を使うので、定義する必要があるのは接続リクエストを処理する関数だけです:
</p><div class="mylisting"><span class="c001">let</span> proxy_service (client_sock, _) =
  <span class="c001">let</span> service () =
    <span class="c001">try
      let</span> in_chan = in_channel_of_descr client_sock <span class="c001">in
      let</span> line = input_line in_chan <span class="c001">in
      let</span> url = parse_request line <span class="c001">in</span>
      get_url None url client_sock
    <span class="c001">with</span> End_of_file -&gt;
      error <span class="c002">"Ill formed request" "End_of_file encountered"</span>
  <span class="c001">in</span>
  Misc.try_finalize
    (handle_error service) ()
    close client_sock</div><p><a id="page/get_url"></a>
プログラムの残りの部分ではサービスを確立するだけです:
</p><div class="mylisting"><span class="c001">let</span> proxy () =
  <span class="c001">let</span> http_port =
    <span class="c001">if</span> Array.length Sys.argv &gt; 1 <span class="c001">then
      try</span> int_of_string Sys.argv.(1)
      <span class="c001">with</span> Failure _ -&gt; error Sys.argv.(1) <span class="c002">"Incorrect port"</span>
    <span class="c001">else
      try</span> (getservbyname <span class="c002">"http" "tcp"</span>).s_port
      <span class="c001">with</span> Not_found -&gt; error <span class="c002">"http" "Unknown service"</span>
  <span class="c001">in
  let</span> treat_connection s = Misc.double_fork_treatment s proxy_service <span class="c001">in
  let</span> addr = ADDR_INET(inet_addr_any, http_port) <span class="c001">in</span>
  Misc.tcp_server treat_connection addr;;

handle_unix_error (handle_error proxy) ();;</div><!--TOC subsection id="sec145" The <span class="c007">http</span>/1.1 プロトコル-->
<h3 class="subsection" id="sec145">The <span class="c007">http</span>/1.1 プロトコル</h3><!--SEC END --><p>単純な <span class="c007">http</span>リクエストはリクエストごとに新しい接続を必要としますが、これは非効率です。なぜならリクエストには通常他のリクエストが続くからです(例えばクライアントが画像つきのウェブページを受け取った場合、クライアントは続けて画像をリクエストします)。さらに接続を確立する時間はリクエストを処理する時間を簡単に上回ります(<a href="#sec%2Fcoprocessus">7</a> 章ではプロセスではなくスレッドでリクエストを処理することでこの時間を削減する方法を見ます)。<a href="http://www.faqs.org/rfcs/rfc2068.html"><span class="c007">rfc</span> 2068</a> で規定される <span class="c007">http</span>バージョン 1.1 では一つの接続で複数のリクエストを処理することが可能になる複雑なリクエストが利用されます<sup><a id="text11" href="#note11">3</a></sup>。</p><p><span class="c007">http</span>/1.1 で使われる複雑なリクエストではサーバは全ての応答の先頭に応答のフォーマットと転送されるドキュメントのサイズを表すヘッダを付けます。これによってサイズが既知となってドキュメントの終端は EOF ではなくなり、更に多くのリクエストを処理できるようになります。複雑なリクエストは以下の形をしています:
</p><div class="mylisting">GET <span class="c006">sp uri sp</span> HTTP/1.1 <span class="c006">crlf
header crlf</span></div><p><code><span class="c006">header</span></code> の部分はキーと値からなるフィールドのリストであり、以下の構文を持ちます:
</p><div class="mylisting"><span class="c006">field</span> : <span class="c006">value crlf</span></div><p><code>':'</code> の周りに余分なスペースを置くことが許されており、スペースはタブまたは複数のスペースと取り替えることができます。ヘッダフィールドは複数行からなっていても構いません。このとき、およびこのときに限り、行末 <code><span class="c006">crlf</span></code> の次にスペース <code><span class="c006">sp</span></code> が続きます。最後に、大文字と小文字はフィールドのキーワードと特定のフィールドの値において無視されます。</p><p>フィールドが必須かどうかはリクエストの種類によります。例えば <code>GET</code> リクエストでは目的地となるマシンを示すフィールドが必須です。
</p><div class="mylisting">Host : <span class="c006">hostname crlf</span></div><p>この種類のリクエストでは必要に応じて <span class="c003">If-Modified</span> フィールドを指定することで、ドキュメントが指定した日時から改変されている場合に限ってドキュメントを返すようにすることができます。
</p><div class="mylisting">If-Modified : <span class="c006">date crlf</span></div><p><code><span class="c006">header</span></code> 内のフィールドの数は前もって定まっていませんが、ヘッダの終わりは <code><span class="c006">crlf</span></code> だけからなる行で示されます。</p><p>以下は完全な例です (各行の最後の <code>\r</code> の次には <code>\n</code> が続きます):
</p><div class="mylisting">GET /~remy/ HTTP/1.1\r
Host:pauillac.inria.fr\r
\r</div><p>複雑なリクエストに対する応答も複雑になります。応答はステータスを表す行、ヘッダ、そして(もしあれば)応答の本体からなります。
</p><div class="mylisting">HTTP/1.1 <span class="c006">sp status sp message crlf
header crlf
body</span></div><p>応答のヘッダのフィールドはリクエストのものと似た構文を持ちますが、必須、あるいは必須でないフィールドが異なっています (リクエストの種類と応答のステータスによって異なります — プロトコルのドキュメントを見てください)。</p><p>応答の <code><span class="c006">body</span></code> は空でなければ一つのブロックまたは複数のチャンクで送られます。</p><ul class="itemize"><li class="li-itemize">
<code><span class="c006">body</span></code> が一つのブロックの場合、ブロックのバイト数を 10 進で表した <span class="c007">ascii</span> 文字列を指定する <code>Content-Length</code> フィールドがヘッダに含まれる。</li><li class="li-itemize"><code><span class="c006">body</span></code> がチャンクで転送される場合、ヘッダは “<code>chunked</code>” という値を持つ <code>Transfer-Encoding</code> フィールドを持つ。データ本体は空のチャンクで終わる複数のチャンクの列であり、各チャンクは以下の形を持つ:
<div class="mylisting"><span class="c006">size [ ; arg ] crlf
chunk crlf</span></div>ここで <code><span class="c006">size</span></code> はチャンクのサイズを 16 進で表し、 <code><span class="c006">chunk</span></code> はそのサイズのデータ本体である (<code><span class="c006">[</span></code> と <code><span class="c006">]</span></code> の間の部分は必須ではないので安全に無視できる)。最後の空のチャンクは必ず以下の形式となる:
<div class="mylisting">0 <span class="c006">crlf
header crlf crlf</span></div></li><li class="li-itemize">応答が <code>Content-Length</code> フィールドを持っておらず、チャンクされてもいない場合、データ本体は空である (例えば <code>HEAD</code> リクエストに対する応答はヘッダしか持たない)。
</li></ul><p>
一つのブロックからなる応答の例を示します:
</p><div class="mylisting">HTTP/1.1 200 OK\r
Date: Sun, 10 Nov 2002 09:14:09 GMT\r
Server: Apache/1.2.6\r
Last-Modified: Mon, 21 Oct 2002 13:06:21 GMT\r
ETag: <span class="c002">"359-e0d-3db3fbcd"</span>\r
Content-Length: 3597\r
Accept-Ranges: bytes\r
Content-Type: text/html\r
\r
&lt;html&gt;
...
&lt;/html&gt;</div><p>ステータス <code>200</code> はリクエストが成功したことを示します。<code>301</code> は <span class="c007">url</span>が応答の <code>Location</code> フィールドで示される 他の <span class="c007">url</span>にリダイレクトされたことを示します。<code>4XX</code> の形のステータスはクライアントにおけるエラーを、 <code>5XX</code> はサーバにおけるエラーを示します。</p><div class="exercise">
<!--TOC paragraph id="sec146" 練習問題 15-->
<h5 class="paragraph" id="sec146">練習問題 15</h5><!--SEC END --><p><a id="ex15"></a>
<a id="ex/proxy-1.1"></a>
<span class="c007">http</span>/1.1 プロトコルで動くリレーを書いてください。
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id="sec147" 練習問題 16-->
<h5 class="paragraph" id="sec147">練習問題 16</h5><!--SEC END --><p><a id="ex16"></a>
リレーにキャッシュを追加してください。ページはハードドライブに保存され、リクエストされたページがキャッシュに存在していてキャッシュが古すぎない場合にはそれを返します。そうでない場合にはサーバは問い合わせを行いキャッシュを更新します。
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id="sec148" 練習問題 17-->
<h5 class="paragraph" id="sec148">練習問題 17</h5><!--SEC END --><p><a id="ex17"></a>
<a id="ex/wget"></a>
次の <code>wget</code> コマンドを作ってください。<code>wget u1 u2 ... un</code> は <code>u1</code>, <code>u2</code>, …, <code>un</code> へのリクエストを送り、応答を <code>./m1/p1</code>, <code>./m2/p2</code>, …, <code>./mn/pn</code> に保存します。ここで <code>mi</code> と <code>pi</code> はそれぞれサーバの名前とリクエスト <code>ui</code> の絶対パスを表します。連続するリクエストが同じマシン <code>m</code> に対するものである場合、プロトコルの利点を活かしてコマンドが開く接続はひとつだけにするべきです。パーマネント <span class="c007">url</span>によるリダイレクトは追うようにしてください。以下のオプションを追加することもできるでしょう:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c014"><code>-N</code></td><td class="c013">ファイル <code>./mi/ui</code> が存在しない場合、あるいは <span class="c007">url</span>よりも古い場合にはダウンロードしない </td></tr>
<tr><td class="c014"><code>-r</code></td><td class="c013"><span class="c007">html</span> フォーマットの応答に含まれる <span class="c007">url</span>を再帰的に全てダウンロードする。
</td></tr>
</table>
</div><div class="fancybreak">* * *</div></div>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note9" href="#text9">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">インターネットは専用のリンクで接続されたローカルネットワーク (通常はイーサネットネットワーク) で構成され、世界中の何百万台のマシンが接続しています。インターネットドメインにおいては、同じイーサネットケーブルで接続されている隣のマシンとの通信と、いくつものルータと通信衛星を使って接続された地球の反対側にあるマシンとの通信にはなんの違いもありません。</div></dd><dt class="dt-thefootnotes"><a id="note10" href="#text10">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"><span class="c007">rfc</span> はたくさんのサイトから匿名 <span class="c007">ftp</span> で入手できます。フランスでは <a href="ftp://ftp.inria.fr"><span class="c003">ftp.inria.fr</span></a> のディレクトリ <a href="ftp://ftp.inria.fr/pub/rfc/"><span class="c003">rfc</span></a> から入手できます。リファレンスサイトは <a href="http://www.faqs.org/rfcs/"><span class="c003">http://www.faqs.org/rfcs/</span></a> です。</div></dd><dt class="dt-thefootnotes"><a id="note11" href="#text11">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"><span class="c007">http</span>/1.0 プロトコルでも複雑なリクエストを使って複数のリクエストを一つの接続で処理することは可能ですが、ここではそれとは関係のない <span class="c007">http</span>/1.1 で使われるリクエストを説明します。</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec/coprocessus" スレッド-->
<h1 class="chapter" id="sec/coprocessus"> 7  スレッド</h1><!--SEC END --><!--NAME threads.html-->
<p><em>スレッド</em> とは一つのプログラムの中で互いに並列に実行できる制御の流れであり、<em>軽量プロセス</em> とも言われます。</p><p>この章ではスレッドを作成し (<code>Thread</code> モジュール) 同期を行うプログラムを説明します。同期にはロック (<code>Mutex</code> モジュール)、 条件変数 (<code>Condition</code> モジュール)、そして同期イベント (<code>Event</code> モジュール) が使われます。</p>
<!--TOC section id="sec150" イントロダクション-->
<h2 class="section" id="sec150">7.1  イントロダクション</h2><!--SEC END --><p><span class="c003">fork</span><a id="hevea_default142"></a> は現在のプロセスのコピーを作成します (したがってプログラムのコピーも作成します) が、スレッドの作成はこれとは大きく異なります。フォークを行った場合親プロセスと子プロセスのアドレス空間は完全に分離し、二つのプロセスは (ファイルやパイプに対する入出力といった) システムコールを通じてでしかやり取りをすることができません。</p><p>これに対して、あるプログラム内の全てのスレッドは同じアドレス空間を共有します。スレッド間で共有されず、スレッド同士で異なる唯一の情報はスレッドの ID と実行スタック (シグナルマスクやロックと条件変数の状態などのシステム情報を含む) です。この観点では、スレッドはコルーチンに似ています。プログラム内のスレッドは全て同じ方法で扱われますが、プログラムが始まって最初に作られるスレッドは別です。このスレッドが終了すると、そのプログラムが持つ全てのスレッドが終了ししたがってプログラム全体が終了します(これから複数のスレッドといった場合には考えているプログラム内の複数のスレッドを意味し、別のプログラム内で動いているスレッドのことは意味しないことにします)。</p><p>制御を明示的にに受け渡し並列に実行できないコルーチンと違い、スレッドは並列に実行でき、(他のスレッドやプロセスではなく) システムによってプリエンプティブにスケジュールされます。この観点ではスレッドはプロセスに似ています。</p><p>アドレス空間が共有されることで、スレッド同士は共有メモリを使って直接通信することができます。スレッドは並列に実行されるために、全てのスレッドは共有データに対するアクセスを同期しなければいけません。あるスレッドが書き込み終わってから別のスレッドが読み込むようにするためです。原理上は必要なわけではありませんが、実際にはこれを行うためにオペレーティングシステムを介する必要があります。スレッドの同期はロックや条件変数を使うか、あるいはイベントを使って高レベルに行われます。</p><p>プロセスに対するスレッドの利点は低い作成コストと大きなデータを受け渡すときにデータ全体をコピーするのではなくポインタを渡すだけですむことです。</p><p>一方、スレッドを使うとスレッド同士の同期を管理しなければならず、スレッドが致命的なエラーを出す場合にも対処する必要があります。例えばスレッドは停止する前にロックを開放し不変量が保存されるようにする必要があります。上記の利点による恩恵があまりないのであればスレッドよりもプロセスのほうが望ましいでしょう。</p>
<!--TOC paragraph id="sec151" OCaml における実装-->
<h5 class="paragraph" id="sec151">OCaml における実装</h5><!--SEC END --><p>ネイティブスレッドを使うアプリケーションをコンパイルするには次のようにします:
</p><div class="mylisting">ocamlc -thread unix.cma threads.cma -o prog mod1.ml mod2.ml mod3.ml

ocamlopt -thread unix.cmxa threads.cmxa -o prog mod1.ml mod2.ml mod3.ml</div><p><code>ocamlbuild</code> ツールを使うのであれば、<code>_tags</code> ファイルに以下の内容を追加するだけですみます:
</p><div class="mylisting">&lt;<span class="c001">mod</span>{1,2,3}.ml&gt; : thread
&lt;prog.{native,byte}&gt; : use_unix, thread</div><p>インストールされた OCamlがネイティブスレッドをサポートしない場合、<a href="#sec%2Fthread-implementation">7.8</a> 節およびマニュアルにあるシミュレートされた “<span class="c007">vm</span> レベル” スレッドを使う方法を参照してください。この章のこれ以降の内容はネイティブスレッドを仮定し、<span class="c007">vm</span> レベルスレッドには一般的では成り立ちません。</p>
<!--TOC section id="sec152" スレッドの作成と終了-->
<h2 class="section" id="sec152">7.2  スレッドの作成と終了</h2><!--SEC END --><p>この章で説明される関数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html"><span class="c003">Thread</span></a> モジュールに定義されています。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_create.html"><span class="c003">create</span></a><a id="hevea_default143"></a> <code>f v</code> は関数適用 <code>f v</code> を実行する新しいスレッドを作成し、スレッド ID を返します。呼び出し側はこの ID を使って新しく作られたスレッドを制御することができます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALcreate">create</a> : ('a -&gt; 'b) -&gt; 'a -&gt; t</div><p>新しいスレッドで実行される <code>f v</code> という関数適用はプログラム内の他のスレッドと並行に実行されます。関数適用が値を返すとスレッドは終了し、返り値は無視されます。スレッドが捕捉されないエラーによって終了したとしても、そのエラーが他のスレッドに及ぶことはありません。そのエラーに関するメッセージが標準エラー出力に出力されるか、エラーは完全に無視されます。他のスレッドは独立して実行されるので、このエラーを受け取ることはできません。</p><p>スレッドはこの他にも <code>Thread</code> モジュールのシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_exit.html"><span class="c003">exit</span></a><a id="hevea_default144"></a> を呼ぶことによってでも終了できます。 <code>Pervasives.</code><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALexit"><span class="c003">exit</span></a><a id="hevea_default145"></a> と混同しないようにしてください。これはプログラム全体、つまり全てのスレッドを終了します。</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALexit">exit</a><a id="hevea_default146"></a> : unit -&gt; unit</div><p>プログラムの最初のスレッドは終了するときに暗黙のうちに <code>Pervasives.exit</code> を呼びます。</p><p>最初のスレッドが終了する前にそれ以外のスレッドが終了すると、そのスレッドは OCamlのランタイムライブラリによってすぐに開放されます。<code>fork</code> で作成された Unix プロセスのようにゾンビになることはありません。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_self.html"><span class="c003">self</span></a><a id="hevea_default147"></a> は呼び出したスレッドのスレッド ID を返します。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALself">self</a> : unit -&gt; t</div><p>前の章で作成した “フォーク” と “ダブルフォーク” を使った並行サーバを、子プロセスではなくスレッドを使うように書き換えるための準備が整いました。そのようなサーバを作るためには、<a href="#sec%2Fservice">6.7</a> 節で定義した <code>Misc.fork_treatment</code> に似た <code>Misc.co_treatment</code> を作成します。</p><div class="mylisting"><span class="c001">let</span> co_treatment server_sock service (client_descr, _ <span class="c001">as</span> client) =
  <span class="c001">try</span> ignore (Thread.create service client)
  <span class="c001">with</span> exn -&gt; close client_descr; raise exn;;</div><p>スレッドの作成に成功した場合、サービスと <code>client_descr</code> を閉じる処理は <code>service</code> 関数によって処理されます。スレッドの作成に失敗した場合、ディスクリプタ <code>client_descr</code> を閉じてクライアントを放棄し、エラーに対する処理をメインプログラムに任せます。</p><p>スレッドを使ったサーバでは難しい部分が <code>service</code> 関数に隠れていることに注意してください。この関数は接続を切断するまでロバストに処理しなければいけません。プロセスを使った並行サーバの例ではサービスが他のプロセスによって実行されており、エラーが起こってサービスが途中で終了したとしても望みどおりの処理 — 接続の処理 — が行われます。これはプロセスが終了するとシステムがファイルディスクリプタを閉じるためです。しかしサービスがスレッドによって実行されている場合、デフォルトの設定ではディスクリプタはスレッド間で共有され、スレッドの終了時に閉じられることがありません。そのためスレッドは終了する前にディスクリプタを閉じる必要があります。加えて、サービスは致命的なエラーのときに <code>Pervasives.exit</code> を呼ぶこともできません。なぜならこの呼び出しはサービスだけではなくサーバ全体を終了させるからです。致命的なエラーのときに <code>Thread.exit</code> を使っても解決にならないことが多いです。なぜならスレッドの持つ開いたままのリソース、つまり接続が閉じられていない可能性があるからです。</p><p>一つの解決法は終了処理を実行するコードがハンドラとして登録されている例外 (例えば <code>Exit</code> 例外) を使うことです。また同様の理由でサービスの実行中に <code>sigpipe</code> シグナルをブロックし、シグナルに対する動作を動作をスレッドの終了から <code>EPIPE</code> 例外に変えておくことが重要です。</p>
<!--TOC section id="sec153" スレッドの終了待ち-->
<h2 class="section" id="sec153">7.3  スレッドの終了待ち</h2><!--SEC END --><p>この節で説明される関数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html"><span class="c003">Thread</span></a> モジュールに定義されています。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_join.html"><span class="c003">join</span></a><a id="hevea_default148"></a> を使うとあるスレッドから他のスレッドの終了を待つことができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALjoin">join</a> : t -&gt; unit</div><p>この関数を呼んだスレッドの実行は指定された ID のスレッドの実行が終了するまで中断されます。主スレッドがこの関数を使えば終了する前に他の全てのスレッドが終了するのを待つことができます(この関数を使わないと主スレッドが終了した時点で他の全てのスレッドも終了します)。</p><p><code>join</code> はブロックするので “遅い” システムコールですが、この関数はシグナルを受け取ったときに自動的に再開します。正確にはシグナルによって実行が中断され、ハンドラが呼び出されてから、もう一度関数が呼ばれます。そのためこの関数は指定したスレッドが本当に終了するまで返らず、<code>EINTR</code> 例外を出すことはありません。OCamlプログラマの観点からは、<code>join</code> はシグナルは関数から返った瞬間に実行されるように振る舞います。</p><p>スレッドは非同期に実行されるので、値を返すことがありません。しかしその動作は — 幸運にも! — 副作用によって観測することができます。例えばスレッドは計算の結果を参照値に保存し、他のスレッドは計算が終わったことを確認してからその値を読み込むことができます。次の例がこのことを説明します。

</p><div class="mylisting"><span class="c001">exception</span> Exited
<span class="c001">type</span> 'a result = Value <span class="c001">of</span> 'a | Exception <span class="c001">of</span> exn
<span class="c001">let</span> eval f x = <span class="c001">try</span> Value (f x) <span class="c001">with</span> z -&gt; Exception z
<span class="c001">let</span> coexec (f : 'a -&gt; 'b) (x : 'a) : unit -&gt; 'b =
  <span class="c001">let</span> result = <span class="c001">ref</span> (Exception Exited) <span class="c001">in
  let</span> p = Thread.create (<span class="c001">fun</span> x -&gt; result := eval f x) x <span class="c001">in
  function</span> () -&gt; <span class="c001">match</span> (join p; !result) <span class="c001">with</span>
    | Value v -&gt; v
    | Exception exn -&gt; raise exn;;

<span class="c001">let</span> v1 = coexec succ 4 <span class="c001">and</span> v2 = coexec succ 5 <span class="c001">in</span> v1 () + v2 ();;</div><p>システムは他のスレッドに制御を移すため、あるいはスレッドが他のスレッドやプロセスが利用中のリソース (例えばロックや条件変数、ファイルディスクリプタ) を待つために、スレッドを停止することができます。<code>yeild</code> 関数を使うとシステムによるプリエンプションを待つことなく明示的に実行を停止することができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALyield">yield</a><a id="hevea_default149"></a> : unit -&gt; unit</div><p>この関数はスレッドスケジューラに対してヒントを出しますが、なんの効果も持たない場合もあります。例えば <code>yield</code> が呼ばれた時点で他に実行できるスレッドがない場合は、システムは同じスレッドの実行を続けます。</p><p>また他のスレッドが実行されるためには <code>yeild</code> を呼ばなくてはいけないわけではありません。システムは <code>yield</code> コマンドを任意のタイミングで実行する権限を持っているからです。実際にはシステムはこの権限を頻繁に使って他のスレッドを実行し、プロセスが一つしか無いマシンでもスレッドが並列に実行されているように見せています。</p><div class="example">
<!--TOC paragraph id="sec154" 例-->
<h5 class="paragraph" id="sec154">例</h5><!--SEC END --><p>
<a href="#ex%2Fforksearch">3.3</a> 節の例をプロセスではなくスレッドを使って書き直します。

</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let rec</span> psearch k cond v =
<span class="c005">   2</span>   <span class="c001">let</span> n = Array.length v <span class="c001">in</span>
<span class="c005">   3</span>   <span class="c001">let</span> slice i = Array.sub v (i * k) (min k (n - i * k)) <span class="c001">in</span>
<span class="c005">   4</span>   <span class="c001">let</span> slices = Array.init (n/k) slice <span class="c001">in</span>
<span class="c005">   5</span>   <span class="c001">let</span> found = <span class="c001">ref false in</span>
<span class="c005">   6</span>   <span class="c001">let</span> pcond v = <span class="c001">if</span> !found <span class="c001">then</span> (Thread.exit (); cond v) <span class="c001">else</span> cond v <span class="c001">in</span>
<span class="c005">   7</span>   <span class="c001">let</span> search v = <span class="c001">if</span> simple_search pcond v <span class="c001">then</span> found := <span class="c001">true in</span> <a id="prog:search"></a>
<span class="c005">   8</span>   <span class="c001">let</span> proc_list = Array.map (Thread.create search) slices <span class="c001">in</span>
<span class="c005">   9</span>   Array.iter Thread.join proc_list;
<span class="c005">  10</span>   !found;;</div><p>
<code>psearch k f v</code> は <code>k</code> このスレッドを使って配列の要素のうち <code>f</code> を満たすものを並列に探索します。<code>pcond</code> は探索がすでに成功している場合にスレッドを終了させることで探索を打ち切ります。全てのスレッドは参照 <code>found</code> を共有し、アクセスは並列に起こります。この参照への書き込みは必ず値を <code><span class="c001">true</span></code> にするので、クリティカルセクションは存在しません。探索対象が見つからなかったときに全体の探索結果をセットしてはいけません。例えば <a href="#prog%3Asearch">7</a> 行目を
</p><div class="mylisting"><span class="c001">let</span> search v = found := !found &amp;&amp; simple_search pcond v</div><p>あるいは:
</p><div class="mylisting"><span class="c001">let</span> search v = <span class="c001">let</span> r = simple_search pcond v <span class="c001">in</span> found := !found &amp;&amp; r</div><p>に入れ替えると正しく動かなくなります。
</p><div class="fancybreak">* * *</div></div><p>
要素の比較が (デイスクアクセスやネットワークへの接続で) 一時的なブロックを引き起こすならば、並列探索はプロセスが一つしか無いマシンでも意味があります。この場合リソースを待っているスレッドが他のスレッドに実行を譲ることで配列の他の部分の計算を続けることができ、ブロックされたスレッドの実行はリソースが利用可能になってから再開されます。</p><p>特定の要素へのアクセスがとても大きなレイテンシを持つという場合があり、とくにネットワーク越しにデータを取得しなければいけない場合にはレイテンシが他の要素に比べて数百倍となります。このようなケースではシーケンシャルな探索と並列な探索の差が明確になります。
<br>
</p><div class="exercise">
<!--TOC paragraph id="sec155" 練習問題 18-->
<h5 class="paragraph" id="sec155">練習問題 18</h5><!--SEC END --><p><a id="ex18"></a>
<a id="ex/qsort"></a>
配列に対するクイックソートを並列化してください。
<a href="#exans18">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 18</arg>-->
<!--NAME exercise18.html-->
<div class="answer">
<!--TOC paragraph id="sec156" 練習問題 exercise 18 の解答-->
<h5 class="paragraph" id="sec156">練習問題 <a href="#ex18">exercise 18</a> の解答</h5><!--SEC END --><p>
<a id="exans18"></a>
クイックソートは目的の配列を分割し、分割した配列をそれぞれ独立にソートするので並列化はしやすいです。クイックソートを実行するスレッドにおける唯一の同期は分割した配列のソートが終わるのを待つ部分だけです。</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">let</span> qsort cmp arr =
<span class="c005">   2</span>   <span class="c001">let rec</span> qsort lo hi =
<span class="c005">   3</span>   <span class="c001">if</span> hi - lo &gt; 0 <span class="c001">then</span>
<span class="c005">   4</span>     <span class="c001">begin</span>
<span class="c005">   5</span>       <span class="c001">let</span> mid = (lo + hi) <span class="c001">lsr</span> 1 <span class="c001">in</span>
<span class="c005">   6</span>       <span class="c001">if</span> cmp arr.(mid) arr.(lo) <span class="c001">then</span> swap arr mid lo;
<span class="c005">   7</span>       <span class="c001">if</span> cmp arr.(hi) arr.(mid) <span class="c001">then</span>
<span class="c005">   8</span>         <span class="c001">begin</span>
<span class="c005">   9</span>           swap arr mid hi;
<span class="c005">  10</span>           <span class="c001">if</span> cmp arr.(mid) arr.(lo) <span class="c001">then</span> swap arr mid lo
<span class="c005">  11</span>         <span class="c001">end</span>;
<span class="c005">  12</span>       <span class="c001">let</span> pivot = arr.(mid) <span class="c001">in</span>
<span class="c005">  13</span>       <span class="c001">let</span> i = <span class="c001">ref</span> (lo + 1) <span class="c001">and</span> j = <span class="c001">ref</span> (hi - 1) <span class="c001">in</span>
<span class="c005">  14</span>       <span class="c001">while</span> !i &lt; !j <span class="c001">do</span>
<span class="c005">  15</span>         <span class="c001">while</span> not (cmp pivot arr.(!i)) <span class="c001">do</span> incr i <span class="c001">done</span>;
<span class="c005">  16</span>         <span class="c001">while</span> not (cmp arr.(!j) pivot) <span class="c001">do</span> decr j <span class="c001">done</span>;
<span class="c005">  17</span>         <span class="c001">if</span> !i &lt; !j <span class="c001">then</span> swap arr !i !j;
<span class="c005">  18</span>       <span class="c001">done</span>;
<span class="c005">  19</span>       <span class="c001">let</span> u = Thread.create (qsort lo) (!i-1) <span class="c001">in</span>
<span class="c005">  20</span>       <span class="c001">let</span> v = Thread.create (qsort (!i+1)) hi <span class="c001">in</span> <a id="prog:tcreate"></a>
<span class="c005">  21</span>       Thread.join u; <a id="prog:tjoin"></a>
<span class="c005">  22</span>       Thread.join v
<span class="c005">  23</span>     <span class="c001">end in</span>
<span class="c005">  24</span>   qsort 0 (Array.length arr - 1);;</div><p>
<a href="#prog%3Atcreate">20</a> 行目と <a href="#prog%3Atjoin">21</a> 行目を入れ替えても正しい答えは得られますが、あまり意味がないでしょう。配列の前半分がソートされてから後半分のソートが始まるので、動作はシーケンシャルなプログラムと同じになりますが、スレッドの生成の分だけ実行が遅くなります。</p><p>並列クイックソートを実際のプログラムで使う場合には、配列の長さがある程度よりも小さくなったらスレッドを作らずにシーケンシャルにソートしたほうが良いでしょう。
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->
<p>これから紹介するスレッドを停止させる別の方法は、オペレーティングシステムのリソースに関係しています。スレッドは <code>delay s</code> を呼ぶことで任意の時間だけ実行を停止することができます。実行は <code>s</code> 秒後に再開されます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALdelay">delay</a><a id="hevea_default150"></a> : float -&gt; unit</div><p>この関数は <span class="c007">vm</span>-レベルのスレッドでもポータブルに使うことができますが、<code>delay s</code> は <code>ignore (Unix.select [] [] [] s)</code> の省略形に過ぎません。<code>join</code> と違ってこの関数はシグナルで中断されても自動的に再開しません。</p><p>スレッドを外部の操作と同期させるために <span class="c003">select</span><a id="hevea_default151"></a> を使うことができます。この関数がブロックするのはプログラム全体ではなくこの関数を読んだスレッドだけであることに注意してください。シミュレートされたスレッドが <code>Unix</code> モジュールの <code>select</code> を呼ぶとプログラム全体すなわち全てのスレッドをブロックしてしまうために、<code>Thread</code> モジュールはこの関数を再定義しています。ネイティブスレッドを利用するプログラムでは <code>Unix.select</code> と <code>Thread.select</code> の動作に違いはありませんが、この理由からネイティブスレッドを利用するプログラムでも <code>Unix</code> モジュールではなく <code>Thread</code> モジュールの <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALselect"><span class="c003">select</span></a> 関数を使うことが必要になります。</p><div class="example">
<!--TOC paragraph id="sec157" 例-->
<h5 class="paragraph" id="sec157">例</h5><!--SEC END --><p>
<a id="ex/crible-copro"></a>
<a href="#ex%2Fcrible">5.2</a> 節のエラトステネスのふるいの例を Unix プロセスではなくスレッドを使って動かすためには、 <code>filter</code> 関数の <a href="#prog%3Asievefilterfork">5</a>–<a href="#prog%3Asievefilterdone">16</a> 行目を

</p><div class="mylisting">    <span class="c001">let</span> p = Thread.create filter (in_channel_of_descr fd_in) <span class="c001">in
    let</span> output = out_channel_of_descr fd_out <span class="c001">in
    try
      while true do
        let</span> n = input_int input <span class="c001">in
        if</span> List.exists (<span class="c001">fun</span> m -&gt; n <span class="c001">mod</span> m = 0) first_primes <span class="c001">then</span> ()
        <span class="c001">else</span> output_int output n
      <span class="c001">done</span>;
    <span class="c001">with</span> End_of_file -&gt;
      close_out output;
      Thread.join p</div><p>に変え、さらに <code>sieve</code> 関数の <a href="#prog%3Asievefork">4</a>–<a href="#prog%3Agen">10</a> 行目を

</p><div class="mylisting">  <span class="c001">let</span> k = Thread.create filter (in_channel_of_descr fd_in) <span class="c001">in
  let</span> output = out_channel_of_descr fd_out <span class="c001">in</span>
  generate len output;
  close_out output;
  Thread.join k;;</div><p>
に変えれば十分です。ただし、計算時間に比べてプロセスをあまり使わないこの例では実行速度の高速化は望めません。
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec158" スレッドの同期: ロック-->
<h2 class="section" id="sec158">7.4  スレッドの同期: ロック</h2><!--SEC END --><p>
この節で説明される関数は <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html"><span class="c003">Mutex</span></a> (<code>Mut</code>ual <code>ex</code>clusion) モジュールに定義されています。</p><p>前の節で変更可能なリソースに対する並行アクセスの問題に触れました。次のシナリオは共有リソースへのアクセスの問題を説明します。二つのスレッド <span class="c006">p</span> と <span class="c006">q</span> がカウンタ <span class="c006">c</span> の値を進めようとしているとします。</p><p>図<a href="#fig%2Fcompetition">6</a>にあるシナリオを考えます。スレッド <span class="c006">p</span> がカウンタ <span class="c006">c</span> の値を読み、実行が <span class="c006">q</span> へ移ります。この次に <span class="c006">q</span> は <span class="c006">c</span> の値を読み、値 <span class="c006">k</span>+1 を <span class="c006">c</span> に書き込みます。次に実行は <span class="c006">p</span> へと戻りますが、このスレッドは <span class="c006">k</span>+1 を <span class="c006">c</span> に書き込みます。この結果、最小的な <span class="c006">c</span> の値は <span class="c006">k</span>+2 ではなく <span class="c006">k</span>+1 となってしまいます。
</p><div class="figure">
<div class="image"><img src="ocamlunix-image23.png" width="100%"></div>



<a id="fig/competition"></a>
<div class="caption">Figure 6 — 共有リソースへのアクセスの競合</div></div><p>この古典的な問題はロックを使って <span class="c006">p</span> と <span class="c006">q</span> が交互に実行されることをなくすことで解決できます。</p><p>ロックとは共有オブジェクトであり、プログラムの各時点でロックを所有できるのは多くとも一つのスレッドだけです。ロックは <code>create</code> 関数で作成します。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALcreate">create</a> : unit -&gt; t</div><p>この関数はどのスレッドにも所有されていない新しいロックを返します。作成したロックを取得するには、そのロックに対してシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_mutex_lock.html"><span class="c003">lock</span></a><a id="hevea_default152"></a> を呼ぶ必要があります。目的のロックが他のスレッドによって所有されていた場合、 <code>lock</code> を読んだスレッドはロックが開放されるまでブロックします。ロックを所有しているスレッドはシステムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_mutex_unlock.html"><span class="c003">unlock</span></a><a id="hevea_default153"></a> によってロックを開放しなければいけません。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALlock">lock</a> : t -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALunlock">unlock</a> : t -&gt; unit</div><p>シグナルへの動作について、<code>lock</code> は <code>Thread.join</code> に似ています。もし <code>lock</code> の実行中にシグナルを受け取った場合、そのシグナルは記録されOCamlランタイムがシグナルの到着を通知しますが、関数を呼び出したスレッドは <code>lock</code> がロックが取得できるまでブロックされ、<code>lock</code> から <code>ENITR</code> 例外が出ることはありません。OCamlによるシグナルの処理は <code>lock</code> が返るタイミングで行われます。</p><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_mutex_trylock.html"><span class="c003">trylock</span></a><a id="hevea_default154"></a> を使うとブロックせずにロックの取得を試みることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALtry_lock">try_lock</a> : t -&gt; bool</div><p>この関数はロックが取得できた場合に <code><span class="c001">true</span></code> を返し、それ以外のときには <code><span class="c001">false</span></code> を返します。後者の場合、ロックは取得されないのでスレッドの実行が停止することはありません。そのためスレッドは他の処理を行ってからもう一度ロックの取得を試みることができます。</p><div class="example">
<!--TOC paragraph id="sec159" 例-->
<h5 class="paragraph" id="sec159">例</h5><!--SEC END --><p>複数のスレッドによって利用されるグローバルなカウンタを進める処理には同期の問題があります。カウンタの値を読んでから新しい値を書き込むまでの間はクリティカルセクション、つまり二つ以上のスレッドが同時に実行してはいけない区間になります。ロックを使えば同期を簡単に管理できます。
</p><div class="mylisting"><span class="c001">type</span> counter = { lock : Mutex.t; <span class="c001">mutable</span> counter : int }
<span class="c001">let</span> newcounter () = { lock = Mutex.create (); counter = 0 }
<span class="c001">let</span> addtocounter c k =
  Mutex.lock c.lock;
  c.counter &lt;- c.counter + k;
  Mutex.unlock c.lock;;</div><p>カウンタの値を読むだけであれば同期の問題は起こりません。カウンタの変更と同時に読み込みが起こることはありえます。しかしその場合書き込みの直前または直後の値を読み込むだけであり、いずれにせよ矛盾が起きることはありません。
</p><div class="fancybreak">* * *</div></div><p>ある関数を実行する間ロックを保持するというパターンがよく必要になります。このパターンでは関数が成功するか失敗するかにかかわらず最後にロックを開放することが当然必要になります。この処理を次のライブラリ関数にまとめます:

</p><div class="mylisting"><span class="c001">let</span> run_with_lock l f x =
  Mutex.lock l; try_finalize f x Mutex.unlock l</div><p>一つ前の例は次のように書けます:

</p><div class="mylisting"><span class="c001">let</span> addtocounter c =
  Misc.run_with_lock c.lock (<span class="c001">fun</span> k -&gt; c.counter &lt;- c.counter + k)</div><div class="example">
<!--TOC paragraph id="sec160" 例-->
<h5 class="paragraph" id="sec160">例</h5><!--SEC END --><p>
スレッドを使ったサーバのモデルの代わりに、リクエストを並列に処理するスレッドをいくつか事前に作っておくことができます。

</p><div class="mylisting"><span class="c001">val</span> tcp_farm_server :
  int -&gt; (file_descr -&gt; file_descr * sockaddr -&gt; 'a) -&gt; sockaddr -&gt; unit</div><p><code>tcp_farm_server</code> 関数は <code>tcp_server</code> と同じように動作しますが、開始するスレッドの数を表す引数を追加で取ります。スレッドは同じアドレスに対するサーバになります。スレッドプールを使う利点はスレッドを一括して事前に作っておくことで接続を処理するときにスレッドを作る処理の分だけ時間を節約できる点です。

</p><div class="mylisting"><span class="c001">let</span> tcp_farm_server n treat_connection addr =
  <span class="c001">let</span> server_sock = Misc.install_tcp_server_socket addr <span class="c001">in
  let</span> mutex = Mutex.create () <span class="c001">in
  let rec</span> serve () =
    <span class="c001">let</span> client =
      Misc.run_with_lock mutex
        (Misc.restart_on_EINTR accept) server_sock <span class="c001">in</span>
    treat_connection server_sock client;
    serve () <span class="c001">in
  for</span> i = 1 <span class="c001">to</span> n-1 <span class="c001">do</span> ignore (Thread.create serve ()) <span class="c001">done</span>;
  serve ();;</div><p>唯一注意するべき点は <code>accept</code> 関数を排他的に実行することです。これによって接続を受け付ける関数が常に多くとも一つとなります。ここでは <code>treat_connection</code> 関数がシーケンシャルな処理を行うことを想定していますが、これが必須なわけではありません。スレッドプールとスレッドの作成を同時に行って使用率に応じてスレッドの数を調整することもできます。
</p><div class="fancybreak">* * *</div></div><p>ロックの取得がブロックせずに成功した場合、処理はすぐに終了します。ロックの取得は全ての現代的なプロセッサで提供される “test-and-set” 命令 (とキャシュの更新などのコストの小さないくつかの処理) で一般的に実装されているためです。一方ロックが利用可能でない場合は、スレッドは実行を停止しもう一度スケジュールされるまで待たなくてはならず、大量のコストがかさみます。そのためこのコストを取るのは他のスレッドに実行を受け渡すために本当に実行を中断するときだけにするべきであり、ロックを取得しようとした結果実行がブロックされたというのはできる限り避けるべきです。したがってほとんど常にロックはなるべく早く開放して必要になったらもう一度取得するようにするべきで、ロックを保持したままでいることは避けるべきです。ロックの開放を行わないとクリティカルセクションが大きくなり、他のスレッドのロックの取得が競合し、実行を停止しなければならなくなる頻度が上がります。</p><p>ロックによってスレッドが交互に実行されなくなりますが、そのかわりデッドロックの危険性があります。例えばスレッド <span class="c006">p</span> がロック <span class="c006">v</span> の開放を待っていて、<span class="c006">v</span> を持っているスレッド <span class="c006">q</span> は <span class="c006">p</span> が持っているロック <span class="c006">u</span> を待っている場合です (最悪な場合には、スレッドが自分が持っているロックを待つこともあります) 。並行プログラミングは難しく、デッドロックの排除は常に簡単なわけではありません。デッドロックを避ける単純で実行可能なことが多い方法は、ロックに階層を定義してロックの取得が階層をたどるようにするというものです。スレッドがあるロックを取得できるのはそのロックよりも下のロックを全て取得しているときだけです。</p>
<!--TOC section id="ex/th-relais" 完全な例: <span class="c007">http</span> リレー-->
<h2 class="section" id="ex/th-relais">7.5  完全な例: <span class="c007">http</span> リレー</h2><!--SEC END --><p><a href="#sec%2Frelay">6.14</a> 節で作成した <span class="c007">http</span>リレーを改変し、リクエストをスレッドを使って処理するようにします。</p><p>直感的には、プロセスのクローンを作成する <code>establish_server</code> 関数をスレッドを作るようにすればすみます。しかし、いくつか注意点があります。複数のスレッドを使用する上での困難はメモリ空間を全て共有することです。そのためあるスレッド行ったことを他のスレッドが打ち消してしまうような、“互いのつま先を踏み合う” ことのないようにしなければなりません。これは二つのスレッドが変更可能な同じ構造体を並列に変更するときによく起こります。</p><p><span class="c007">http</span>サーバにはいくつかの変更が必要になります。まずリソースへのアクセスの問題から始めます。 <a href="#page%2Fget_url">6.14</a> 節で説明した <code>proxy_service</code> 関数は接続への対応を処理します。<code>parse_host</code> と <code>parse_url</code> そして <code>parse_request</code> を途中で使って、<code>proxy_service</code> は <code>Str</code> ライブラリの <code>regexp_match</code> 関数を呼びます。しかし、このライブラリは再入可能ではありません (最後の探索の結果がグローバル変数にか格納されます)。一見害の無いように見える関数呼び出しも内部にデータの衝突を隠しているかもしれないので注意しなければいけないことをこの例は示しています。今回は <code>Str</code> ライブラリを書き直すのではなく単純にその利用をシーケンシャルにします。ライブラリ関数の呼び出しをロックで防御するだけで十分です (他の選択肢があるわけでもありません)。例外によって関数が異常終了した場合にもロックを開放するように注意する必要があります。</p><p>現在のコードへの変更を最小限にするために、<code>Url</code> モジュールの<code>regexp_match</code> 関数の名前を <code>unsafe_regexp_match</code> に変更し、新たに <code>regexp_match</code> 関数を防御された <code>unsafe_regexp_match</code> として作成します。

</p><div class="mylisting"><span class="c001">let</span> strlock = Mutex.create ();;
<span class="c001">let</span> regexp_match r string =
  Misc.run_with_lock strlock (unsafe_regexp_match r) string;;</div><p>変更は最小限だと言えるでしょう。<code>regexp_match</code> 関数が正規表現に対するマッチングとマッチしてグループの取得を両方を含むことを指摘しておきます。<code>Str.string_match</code> と <code>Str.matched_group</code> を個別にロックで防御するのは完全な間違いです。</p><p>もう一つの解法は <code>Str</code> ライブラリを使わずに解析関数を書き直すことです。しかしライブラリ関数を同期して実行するのは簡単であり、実行を遅くしないことが実行すれば分かるので、この方法を取るべき理由は何もありません。ただ <code>Str</code> が最初から再入可能であればそのほうが良かったでしょう。</p><p>他の関数はすでに再入可能です。例えば <code>Misc.retransmit</code> 関数は呼び出しごとに違うバッファを確保します。</p><p>これ以外にエラー処理に関連して気をつけなければいけないことがあります。前に書いたように、スレッドによる接続の処理はロバストでなければいけません。特にエラーが起こった場合に他のスレッドが影響を受けてはいけません。つまりそのスレッドは受け持った接続を適切に閉じて他の待っている接続を受け付ける状態に戻るという “通常” 終了をする必要があります。</p><p>このためにまず <code>handle_error</code> 関数中の <code>exit</code> の呼び出しを <code>Thread.exit</code> に変更します。これは <code>exit</code> がプロセス全体を終了させるためです。しかしただ <code>Thread.exit</code> を読ぶだけでは正しくなりません。なぜならプロセスの終了と違ってスレッドの終了は (共有された) ディスクリプタを閉じないからです。接続処理中にエラーが起きても接続は開いたままなので、 <code>Exit</code> 例外を出して最終処理を行うようにする必要があります。そして <code>treat_connection</code> 関数は <code>EPIIE</code> だけでなく <code>Exit</code> を含んだ全ての例外を補足しなければいけません。例外を捕捉するように関数を呼び出す関数を使ってこれを行います:</p><div class="mylisting"><span class="c001">let</span> allow_connection_errors f s =
  <span class="c001">try</span> f s <span class="c001">with</span> Exit | Unix_error(EPIPE,_,_) -&gt; ()</div><div class="mylisting"><span class="c001">let</span> treat_connection s =
  Misc.co_treatment s (allow_connection_errors proxy_service) <span class="c001">in</span></div><div class="exercise">
<!--TOC paragraph id="sec162" 練習問題 19-->
<h5 class="paragraph" id="sec162">練習問題 19</h5><!--SEC END --><p><a id="ex19"></a>
<span class="c007">http</span>/1.1 プロトコルのプロキシをスレッドを使って書き直してください。
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id="sec163" 練習問題 20-->
<h5 class="paragraph" id="sec163">練習問題 20</h5><!--SEC END --><p><a id="ex20"></a>
コルーチンは別のスレッドへの実行の受け渡しを常に明示的に行う必要がある非常に特殊なスレッドと見ることができます。スレッドを使ってコルーチンを実装してください。
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec164" 条件変数-->
<h2 class="section" id="sec164">7.6  条件変数</h2><!--SEC END --><p>この節で説明される関数は <code>Condition</code> モジュールに定義されています。</p><p>ロックを使った同期はとてもシンプルですが、機能が十分ではありません。ロックを使うと共有データが開放されるのを待つことができますが、データがある状態になるのを待つことはできません。</p><p>カウンタの例をスレッド感で共有される (先入れ先出しの) キューを使って書き直してみましょう。キューに要素を追加することはこれまで説明してきたロックによって行えます。これはキューの状態にかかわらず要素を追加することは常に可能なためです。</p><p>しかしキューから要素を削除する場合はどうでしょうか? キューが空のときは何をすればいいでしょうか? キューが空の場合にロックを持ちながら新しい要素を待つことはできません。なぜならキューに要素を追加するにはロックが必要なために、ロックを持っている限りキューに新しい要素が足されることはないからです。だとすれば、キューが空でないことをどうやって知ることができるでしょうか?キューの状態を定期的にチェックする方法は “ビジーウェイト” と呼ばれ、望ましい解決法ではありません。(周期が短ければ) 計算機のサイクルを無駄遣いし、 (周期が長ければ) 反応時間が長くなるからです。</p><p><em>条件変数</em> がこの問題を解決します。ロックを持つスレッドは条件変数に対して別のスレッドがシグナルを送るまで待つことができます。ロックと同じように、条件変数は同期関数によって生成される中身の見えないオブジェクトです。<code>create</code> 関数で条件変数を作ることができます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALcreate">create</a> : unit -&gt; t</div><p>システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_cond_wait.html"><span class="c003">wait</span></a><a id="hevea_default155"></a> を使うと、ロック <span class="c006">v</span> を <em>すでに持つ</em> プロセス <span class="c006">p</span> は条件変数 <code>c</code> とロック <code>v</code>に対して待つことができます。この呼び出しによって プロセス <span class="c006">p</span> はシステムに条件変数 <code>c</code> とロック <code>v</code> に対して待っていると伝え、ロック <code>v</code> を開放して実行を中断します。他のスレッド <span class="c006">q</span> が条件変数 <code>c</code> の変更をシグナルし、かつロック <code>v</code> が利用可能になると <code>v</code> を持った状態で実行が再開されます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALwait">wait</a> : t -&gt; Mutex.t -&gt; unit</div><p>ロック <code>v</code> を取得していない状態で <code>wait c v</code> を呼ぶとエラーとなります。またシグナルに対する <code>wait c v</code> の動作は <code>Mutex.lock</code> と同じです。</p><p>スレッドが条件変数が変更されたシグナルを送ると、その条件変数に対して待っている全てのスレッドを起動する (システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_cond_broadcast.html"><span class="c003">broadcast</span></a><a id="hevea_default156"></a>) か、それらのうち一つを起動する (システムコール <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_cond_signal.html"><span class="c003">signal</span></a><a id="hevea_default157"></a>) かのどちらかが行われます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALsignal">signal</a> : t -&gt; unit
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALbroadcast">broadcast</a> : t -&gt; unit</div><p>条件変数のシグナルの送信またはブロードキャストは (<code>wait</code> と違って) ロックを必要としません。そのためシステムのエラーは起きませんが、それでもプログラミング上のエラーは起きます。
</p><p>スレッドを一つだけ起動するのか全て起動するかは問題によります。キューの例をもう一度考えると、スレッドが空のキューに要素を入れたときに待っているスレッドを全て起動する必要はありません。キューから要素を取り出して処理を行えるのは一つのスレッドだけだからです。一方、もしスレッドが複数の要素をキューに入れ、その要素の数が静的にわからない場合には待っている全てのスレッドを起動する必要があります。</p><p>空でないキューに要素を追加するときにシグナルを出さない場合には、空のキューへの要素の追加は常にブロードキャストを行う必要があることに注意してください。空のキューへの要素の追加されてからシグナルが発せられるまでに他の要素が追加されることがあり、このときは要素が複数追加されたとして対処しなければならないためです。</p><p>通常スレッドは他のスレッドが条件変数に対して待っている理由を近似的にしか知りません。そのため他のスレッドが条件変数を待っているかもしれない状況では常にシグナルすることが求められます。また起動されたスレッドは期待した状況が整っていると仮定してはいけません。一般的には、起動されたスレッドは共有状態のデータを読み取って所望の条件が成り立っていることを確認し、必要ならばもう一度待つ必要があります。この処理は他のスレッドがシグナルしたときにだけ起こるのでビジーウェイトとは違います。</p><p>このアプローチを正当化する理由がもう一つあります。スレッドが大量のリソースを生み出して <code>broadcast</code> を使って全てのスレッドを起動したときに、最初に実行されるスレッドは貪欲に全てのリソースを消費することが可能な点です。このとき二番目以降に起動されるスレッドは次回はもっとラッキーになるように願いながらもう一度実行を中断することになります。</p><p>今までの説明でキューに関する完全な回答の準備が整いました。<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Queue.html"><span class="c003">Queue</span></a> に定義されているキューの構造がロックと条件変数 <code>non_empty</code> で拡張されます。
</p><div class="mylisting"><span class="c005">   1</span> <span class="c001">type</span> 'a t =
<span class="c005">   2</span>   { queue : 'a Queue.t; lock : Mutex.t; non_empty : Condition.t }
<span class="c005">   3</span> <span class="c001">let</span> create () =
<span class="c005">   4</span>   { queue = Queue.create ();
<span class="c005">   5</span>     lock = Mutex.create (); non_empty = Condition.create () }
<span class="c005">   6</span> 
<span class="c005">   7</span> <span class="c001">let</span> add e q =
<span class="c005">   8</span>   Mutex.lock q.lock;
<span class="c005">   9</span>   <span class="c001">if</span> Queue.length q.queue = 0 <span class="c001">then</span> Condition.broadcast q.non_empty;<a id="prog:broadcast"></a>
<span class="c005">  10</span>   Queue.add e q.queue;
<span class="c005">  11</span>   Mutex.unlock q.lock;;
<span class="c005">  12</span> 
<span class="c005">  13</span> <span class="c001">let</span> take q =
<span class="c005">  14</span>   Mutex.lock q.lock;
<span class="c005">  15</span>   <span class="c001">while</span> Queue.length q.queue = 0 <a id="prog:lock"></a>
<span class="c005">  16</span>   <span class="c001">do</span> Condition.wait q.non_empty q.lock <span class="c001">done</span>;  <a id="prog:slock"></a>
<span class="c005">  17</span>   <span class="c001">let</span> x = Queue.take q.queue <span class="c001">in</span>
<span class="c005">  18</span>   Mutex.unlock q.lock; x;;</div><p>要素の追加ではスレッドはブロックしませんが、追加の前にキューが空だった場合に条件変数 <code>non_empty</code> をシグナルすることを忘れてはいけません。この条件変数に対して待っているスレッドが存在する可能性があるからです。</p><p>要素の削除はもう少し複雑です。スレッドはロックを取得してから削除を試みますが、キューが空だった場合には条件変数 <code>non_empty</code>に対して待ち起動されたあとにもう一度同じことを行います。同じことができるのは起動されたスレッドがロックを持っているからです。</p><p>上で説明したように、<code>broadcast q.non_empty</code> によるシグナル (<a href="#prog%3Abroadcast">9</a> 行目) はすでにロック <code>q.lock</code> を持っているスレッド <span class="c006">p</span> によって実行されます。これは読み込むを行うために <code>take</code> を実行するスレッド <span class="c006">q</span> が <a href="#prog%3Alock">15</a> 行目と <a href="#prog%3Aslock">16</a> 行目の間の、キューが空であることは確認したがまだ実行を中断していない状態にないことを意味します。もしスレッド <span class="c006">q</span> がこの状態になったとすると、<span class="c006">p</span> によって送られるシグナルは無視され効果を持ちません。その後 <span class="c006">q</span> は実行を中断しますが、 <span class="c006">p</span> がすでにシグナルしているために <span class="c006">q</span> が起動されることはありません。スレッド <span class="c006">p</span> によるロックの取得は <span class="c006">q</span> がすでに実行を中断したかキューの状態を調べていないかのどちらかであり、キューの状態を調べたが実行を中断していないという状況にならないことを保証します。</p><div class="exercise">
<!--TOC paragraph id="sec165" 練習問題 21-->
<h5 class="paragraph" id="sec165">練習問題 21</h5><!--SEC END --><p><a id="ex21"></a>
有界なキューを実装してください。キューへ追加されるのはキューがある長さに達したときにブロックする機能です (並行プログラミングで限りなく生産する生産者と実行がブロックする消費者が存在する場合にこのキューが必要になります)。
<a href="#exans21">解答</a></p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 21</arg>-->
<!--NAME exercise21.html-->
<div class="answer">
<!--TOC paragraph id="sec166" 練習問題 exercise 21 の解答-->
<h5 class="paragraph" id="sec166">練習問題 <a href="#ex21">exercise 21</a> の解答</h5><!--SEC END --><p>
<a id="exans21"></a>
新しい条件変数 <code>non_full</code> と <code>size</code> フィールドを追加します。
</p><div class="mylisting"><span class="c001">type</span> 'a t =
    { queue : 'a Queue.t; size : int; lock : Mutex.t;
      non_empty : Condition.t; non_full : Condition.t; }

<span class="c001">let</span> create k =
  <span class="c001">if</span>  k &gt; 0 <span class="c001">then</span>
    { queue = Queue.create (); size = k; lock = Mutex.create ();
      non_empty = Condition.create (); non_full = Condition.create () }
  <span class="c001">else</span> failwith <span class="c002">"Tqueue.create: empty size"</span>;;</div><p>要素の追加は <code>add</code> と <code>take</code> の処理を組み合わせたものになります。
</p><div class="mylisting"><span class="c001">let</span> add x q =
  Mutex.lock q.lock;
  <span class="c001">while</span> Queue.length q.queue = q.size
  <span class="c001">do</span> Condition.wait q.non_full q.lock <span class="c001">done</span>;
  <span class="c001">if</span> Queue.is_empty q.queue <span class="c001">then</span> Condition.broadcast q.non_empty;
  Queue.add q x;
  Mutex.unlock q.lock;;</div><p>要素の削除は追加と似ていますが、削除する前のキューが満杯な場合には <code>non_full</code> をシグナルする必要があります。

<code>size</code> を <code>max_int</code> とすれば動作が制限のないキューと同じになります。
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id="sec167" イベントベースの同期通信-->
<h2 class="section" id="sec167">7.7  イベントベースの同期通信</h2><!--SEC END --><p>この節で説明される関数は <code>Event</code> モジュールに定義されています。</p><p>ロックと条件変数を使えばどんな形の同期も行うことができますが、必ずしも簡単に行えるというわけではありません。最初は単純だったキューでも同期のためのコードが緻密になることは前節の例で見ました。</p><p>イベントベースの同期通信は高レベルの通信プリミティブを集めたものであり、並行プログラミングを容易にすることを意図しています。<code>Event</code> モジュールのプリミティブはまず John Reppy によって <em>Standard ML</em> 言語の拡張 <em>Concurrent ML</em> [<a href="#CML">16</a>] として開発されました。OCamlではこれらの通信プリミティブはロックと条件変数などの基本的な同期よりも上のレベルに位置しています。</p><p>通信は <em>イベント</em> を <em>チャンネル</em> を通じて送ることで行います。チャンネルとは “軽量パイプ” のようなものです。これを使うと同じプログラム内のスレッド間で通信を行い、生産者と消費者の間で同期を行うことができます。<code>'a</code> 型の値を運ぶチャンネルは <code>'a channel</code> 型を持ちます。チャンネルは途中で型を変えることなく常に同じ型の値を運びます。チャンネルは <code>new_channel</code> 関数で作成されます。

</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALnew_channel">new_channel</a><a id="hevea_default158"></a> : unit -&gt; 'a channel</div><p>メッセージの送受信は直接的にではなくイベントという中間体を通して行われます。基本的なイベントは “メッセージの送信” と “メッセージの受信” であり、以下のプリミティブによって作成できます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALsend">send</a><a id="hevea_default159"></a> : 'a channel -&gt; 'a -&gt; unit event
<span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALreceive">receive</a><a id="hevea_default160"></a> : 'a channel -&gt; 'a event</div><p>メッセージの作成してもすぐに何かが起こるわけではありません。行われるべき動作を示すデータ構造が作られるだけです。イベントを実際に起こすには、スレッドはそのイベントを実行すべきスレッドと同期しなければいけません。<code>sync</code> プリミティブを使うと引数として渡すイベントが実際に実行されるのを待つことができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALsync">sync</a><a id="hevea_default161"></a> : 'a event -&gt; 'a</div><p>まとめると、値 <code>v</code> をチャンネル <code>c</code> に送るには <code>sync (send c v)</code> を実行します。<code>sync</code> を読んだスレッドはイベントが起こるまで、つまり他のスレッドがチャンネル <code>c</code>から値を受信可能になるまでブロックされます。対称的に、スレッドがチャンネル <code>c</code> に対するメッセージを待つには <code>sync (recieve c)</code> を使います。</p><p>全ての生産者と全ての消費者は競合します。例えばいくつかのスレッドが一つのチャンネルにメッセージを送りメッセージを受信できるスレッドが一つしか無かった場合、自分の送ったイベントが起きる生産者は一つだけなのは明らかです。他の生産者は実行を中断されたままであり、先に他のスレッドがイベントを受け取ったことに気がつくことはありません。</p><p>競合は同じスレッド内でも起こりえます。複数のイベントは <code>choose</code> プリミティブを使うとまとめることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALchoose">choose</a><a id="hevea_default162"></a> : 'a event list -&gt; 'a event</div><p>この関数は引数に渡されたイベントを並列にオファーし、これらのイベントのうちちょうど一つが実行されます。ここではオファーと実行を区別していることに注意してください。<code>sync (choose [e1; e2])</code> は二つのイベント <code>e1</code> と <code>e2</code> の選択をオファーし、同期したときには二つのうち一つのイベントしか実行されません (実行と同時に同時にもう一つのイベントはキャンセルされます)。<code>wrap_abort</code> プリミティブを使うとイベントがキャンセルされたときの処理を設定できます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALwrap_abort">wrap_abort</a><a id="hevea_default163"></a> : 'a event -&gt; (unit -&gt; unit) -&gt; 'a event</div><p><code>wrap_abort e f</code> は <code>e</code> と同じイベントを作成しますが、同期したときにこのイベントが実行されなかった場合には <code>f</code> が実行されます (このイベントが複雑なイベントの一部であるときにだけ意味を持ちます)。</p><p><code>poll</code> を使うと (<code>Mutex.try_lock</code> のように) ブロックせずにイベントの同期を試みることができます。
</p><div class="mylisting"><span class="c001">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALpoll">poll</a><a id="hevea_default164"></a> : 'a event -&gt; 'a option</div><p><code>poll e</code> はイベント <code>e</code> をオファーしますが、このイベントがすぐに実行されない場合にはブロックせずにオファーをキャンセルします。このとき関数呼び出しはなんの効果も持ちません (より正確には、<code>poll e</code> という式が <code>None</code> で置き換えられたかのような動作をします)。これに対して、もしイベントがすぐに実行できるならば <code>sync e</code> が実行されたときの動作をします。ただしその時の返り値は <code>v</code> ではなく <code>Some v</code> となります。</p><div class="example">
<!--TOC paragraph id="sec168" 例-->
<h5 class="paragraph" id="sec168">例</h5><!--SEC END --><p>
<a href="#ex%2Fcrible-copro">7.3</a> 節で示したエラトステネスのふるいの例では、異なるスレッド感の通信には元のプログラムと同じパイプが使われ、システムメモリ (パイプ) が中間体でした。プロセスのメモリを使って直接通信を行ったほうが効率的な可能性もあります。単純な解法はパイプを整数が送られるチャンネルで置き換えることです。</p><p>整数をチャンネルに送るだけでは十分ではなく、ストリームの終端を検出する必要もあります。最も単純な解法は整数を <code>Some n</code> の形で送り、<code>None</code> を送ることで終了することです。変更を最小にするために、<a href="#ex%2Fcrible">5.2</a> 節の例で使ったコードを再利用します。パイプとその入出力関数をチャンネルとその入出力関数でシミュレートします。</p><p>前のバージョンのプログラムを取ってきて入出力関数を <code>Pervasives</code> ライブラリの入出力バッファを使ったものからチャンネルを使ったものに入れ替えればすみます。例えば次のコードを <code><span class="c001">open</span> Unix</code> 命令の後に追加します。

</p><div class="mylisting"><span class="c001">let</span> pipe () = <span class="c001">let</span> c = Event.new_channel () <span class="c001">in</span> c, c
<span class="c001">let</span> out_channel_of_descr x = x
<span class="c001">let</span> in_channel_of_descr x = x

<span class="c001">let</span> input_int chan =
  <span class="c001">match</span> Event.sync (Event.receive chan) <span class="c001">with</span>
  | Some v -&gt; v
  | None -&gt; raise End_of_file
<span class="c001">let</span> output_int chan x = Event.sync (Event.send chan (Some x))
<span class="c001">let</span> close_out chan = Event.sync (Event.send chan None);;</div><p>しかしチャンネルを使ったバージョンの実行速度を前のバージョンと比べると、チャンネルを使うほうが二倍程度遅いことがわかります。整数を通信するときに毎回二つのスレッドの同期が必要となり、ロックの取得と開放に何回かのシステムコールが必要となるためです。一方で、バッファされた <span class="c007">i/o</span>を使うパイプを用いた通信では一回のシステムコールで数千個の整数がまとめて送られます。</p><p>公平な比較のためには、チャンネルを使った通信にバッファを用意していくつかの整数をまとめてチャンネルを利用するようにするべきです。子はプライベートなキューに計算結果を他のスレッドと同期することなく蓄積します。キューが満杯になるか明示的な要求が届くと、チャンネルが同期されてキューが空になります。親は自分用のキューを持ち、このキューはチャンネル同期によって満たされ計算が進むに連れて一つづつ消費されます。</p><p>このときのコードは以下のようになります:

</p><div class="mylisting"><span class="c001">type</span> 'a buffered =
    { c : 'a Queue.t Event.channel;
      <span class="c001">mutable</span> q : 'a Queue.t;
      size : int }

<span class="c001">let</span> pipe () = <span class="c001">let</span> c = Event.new_channel () <span class="c001">in</span> c, c;;

<span class="c001">let</span> size = 1024;;
<span class="c001">let</span> out_channel_of_descr chan =
  { c = chan; q = Queue.create (); size = size };;
<span class="c001">let</span> in_channel_of_descr = out_channel_of_descr;;

<span class="c001">let</span> input_int chan =
  <span class="c001">if</span> Queue.length chan.q = 0 <span class="c001">then begin
    let</span> q = Event.sync (Event.receive chan.c) <span class="c001">in
    if</span> Queue.length q &gt; 0 <span class="c001">then</span> chan.q &lt;- q
    <span class="c001">else</span> raise End_of_file
  <span class="c001">end</span>;
  Queue.take chan.q;;

<span class="c001">let</span> flush_out chan =
  <span class="c001">if</span> Queue.length chan.q &gt; 0 <span class="c001">then</span> Event.sync (Event.send chan.c chan.q);
  chan.q &lt;- Queue.create ();;

<span class="c001">let</span> output_int chan x =
  <span class="c001">if</span> Queue.length chan.q = size <span class="c001">then</span> flush_out chan;
  Queue.add x chan.q

<span class="c001">let</span> close_out chan =
  flush_out chan;
  Event.sync (Event.send chan.c chan.q);;</div><p>
このバージョンではパイプを使ったバージョンと比較可能な程度の効率を取り戻すことができます。</p><p>プロセスとパイプを使ったオリジナルのバージョンと比べると、チャンネルと使った方法には利点が二つあります。一つ目はスレッドの起動はプロセスのものと比べてコストがかからないことです。二つ目はチャンネルを使った通信がデータ全体のコピーではなくポインタの受け渡しのみを行うことです。今回の例ではスレッドの数とやり取りされるデータのサイズがシステムコールと計算のコストに比べて小さいのでこの利点はわかりにくなっています。</p><p>まとめると、スレッド間の通信は (プロセスが中断される場合) システムコールと同程度のコストがかかりますが、このコストは通信をバッファして大きな構造体をやり取りすることで大きく削減できるということになります。
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id="sec169" 練習問題 22-->
<h5 class="paragraph" id="sec169">練習問題 22</h5><!--SEC END --><p><a id="ex22"></a>
<span class="c007">http</span>サーバには高く激しい負荷がかかることがあります。応答にかかる時間を減らすために、新しい接続を処理するためのスレッドを常に数十個保持するように <span class="c007">http</span>サーバのアーキテクチャを変更することができます。この変更は各スレッドが一つのリクエストを処理するのではなく、キューから読んだリクエストを際限なく処理することを意味します。</p><p>マシンへの負荷を避けるために、スレッドの数をタスクを管理する時間がリクエストに対応する時間 (ディスクのデータ待ちの時間など) よりも小さくなる数に制限する必要があります。さらに接続が増えた場合は接続を処理待ち状態にしておき、それ以上に増えた場合は接続を拒否します。負荷が減りスレッドの数が “理想的な” 数よりも大きくなればスレッドのいくつかを削除します。</p><p><a href="#ex%2Fth-relais">7.5</a> 節の例をこのアーキテクチャに変更してください。
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id="sec170" 実装の詳細-->
<h2 class="section" id="sec170">7.8  実装の詳細</h2><!--SEC END -->
<!--TOC paragraph id="sec171" Unix におけるスレッドの実装-->
<h5 class="paragraph" id="sec171">Unix におけるスレッドの実装</h5><!--SEC END --><p>もともと Unix システムはスレッドをサポートするようにデザインされていませんでしたが、ほとんどの現代的な Unix 実装はスレッドをサポートします。ただしスレッドが後から追加されたものであるということが明白になることがあります。例えば <code>exec</code> を直後に実行するのでない限り、スレッドを使っているときに <span class="c003">fork</span><a id="hevea_default165"></a> を使うことは強く非推奨とされています。<code>fork</code> は現在のスレッドをコピーし、そのスレッドは他のスレッドが存在すると信じて実行を続けますが、実際には他のスレッドは存在せず、正しく動作することができません。</p><p><code>fork</code> を実行した親は通常通り実行を続けます。また <code>fork</code> の直後に子プロセスが他のプログラムを起動する特殊ケースについては親プロセスに問題は起こりません。この方法で問題が起きないことはラッキーです。なぜならこれが他のプログラムを起動する唯一の方法だからです。</p><p>順番を逆にして、<code>fork</code> の後に親または子プロセスがスレッドを作成することは問題ありません。</p>
<!--TOC paragraph id="sec/thread-implementation"  OCaml におけるネイティブおよびシミュレート実装-->
<h5 class="paragraph" id="sec/thread-implementation"> OCaml におけるネイティブおよびシミュレート実装</h5><!--SEC END --><p>実行されているオペレーティングシステムがスレッドの機能を持つ場合には、OCamlはスレッドのネイティブ実装を使います。このとき OCamlはオペレーティングシステムにスレッドの管理をできるだけ任せます。スレッドは同じアドレス空間を共有する異なる Unix プロセスとなります。</p><p>システムがスレッドをサポートしない場合には、OCamlはスレッドをエミュレートすることができます。全てのスレッドは同じ Unix プロセスで実行されそのスケジューリングを含んだ管理はOCamlのランタイムシステムによって行われます。ただし、この実装はバイトコードにコンパイルするときにのみ利用可能です。</p><p>OCamlシステムはネイティブとシミュレートされたバージョンのスレッドに同じインターフェースを提供しています。そのためスレッドの実装は二つに分かれています。一つはエミュレートされたバージョンのためのもので、タスクコントローラを含みます。もう一つは <span class="c007">posix</span> (1003.1c) に基づくスレッドの実装で、他の言語で書かれたライブラリ関数を OCamlへとつなぐものです。OCamlは単純な管理タスクを行いインターフェースがエミュレートされたバージョンと同じことを確認します。これによってある Unix アーキテクチャでコンパイルできたプログラムがほかの Unix アーキテクチャでもコンパイルできることが保証されます。</p><p>ただしネイティブのスレッドとエミュレートされたスレッドでは同期のための C ライブラリへの呼び出しが異なるために、プログラムの意味全体が異なってしまいます。そのためプログラムが二つのバージョンで同じように動くと信じる前にいくつか対処をしなくてはいけません。この節では主に二つの実装の違いについて議論しますが、通常はネイティブ実装について語ることを覚えておいてください。</p><p>エミュレートされたスレッドを使うには <code>ocamlc</code> コンパイラに <code>-thread</code> ではなく <code>-vmthread</code> オプションを渡します。このオプションを <code>ocamlopt</code> コンパイラに渡すことはできません。</p>
<!--TOC paragraph id="sec173" OCaml コードの逐次化-->
<h5 class="paragraph" id="sec173">OCaml コードの逐次化</h5><!--SEC END --><p>OCamlによるスレッドの実装は自動メモリ管理やアロケートされたデータの頻繁な利用といった OCamlの特色を持っている必要があります。採用されている解法は一番シンプルで最も効率的なもので、OCamlの全てのスレッドの実行を逐次化するというものです。つまりランタイムシステムが持つロックによって二つ以上の OCamlコードを同時に実行できなくします。これはスレッドという考え方と矛盾するように聞こえますが、そうではありません。ロックはブロックするシステムコールの直前に開放され、システムコールから返るともう一度取得されるからです。この間に他のスレッドが実行されます。このようなシステムコールの特殊なケースは実行中のスレッドで定期的に実行され、他のスレッドに実行を受け渡す <a href="http://www.opengroup.org/onlinepubs/007908799/xsh/sched_yield.html"><span class="c003">sched_yield</span></a> の呼び出しです。</p><p>マルチプロセッサのマシンでは、本当の並列性は C のコードとシステムコールを実行することでしか得ることができません。プロセッサが一つしか無いマシンでは、 OCamlコードが逐次化されたということに気づくことはできません。</p><p>スレッドの実行はほぼ任意のタイミングで他のスレッドに移るので、プログラマはこの逐次化を頼ることはできません。ただし例外として、逐次化されたコードではメモリの一貫性が保証されます。つまり、C のコードを実行するときなどを除いて二つのスレッドは同じメモリを目にするということです。その結果として、ロックの受け渡しがメモリの同期を意味するようになります。あるスレッドが書き込んだアドレスを別のスレッドが読み込んだ場合常に新しい値が読み込まれ、同期処理は必要ありません。</p>
<!--TOC paragraph id="sec174" スレッドとシグナル-->
<h5 class="paragraph" id="sec174">スレッドとシグナル</h5><!--SEC END --><p>一般的に言って、非同期という特性を持つシグナルを使うことはシングルスレッドのプログラムでさえ注意を要する難しいものでした。シグナルはマルチスレッドのプログラムではさらに難しくなります。どのスレッドにシグナルが送られるべきでしょうか? 全てのスレッド、主スレッド、それとも現在実行しているスレッド? あるスレッドが別のスレッドにシグナルを送りたい場合どうすればいいでしょうか? 実際のところ、スレッドはこのような問題に答えることなく実装されました。そのため実装によってシグナルへの動作は異なります。</p><p><code>Thread.join</code> と <code>Mutex.lock</code> そして <code>Condition.wait</code> は遅いシステムコールにもかかわらずシグナルによって中断されることがありません (したがって <code>EINTR</code> エラーを出して失敗することもありません)。待っているときにシグナルが送られた場合、そのシグナルはシステムコールから返ってから受け取られて処理されます。</p><p><span class="c007">posix</span> 規格はシグナルハンドラがスレッド間で共有されることとシグナルマスクはスレッドの作成時にもとのスレッドから継承された後はスレッドにプライベートとなることを定めています。しかしシグナルに対するスレッドの動作は主に定められておらず、ポータブルにはなっていません。</p><p>したがってスレッドではできる限り非同期シグナル (<code>sigalrm</code> や <code>sigvtalrm</code>、 <code>sigchld</code> など) を避けることが望ましいです。シグナルは <code>Thread.</code><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALwait_signal"><span class="c003">wait_signal</span></a> によってブロックと調査をすることができます。シグナルの処理だけを行うスレッドを作ることもできます。このスレッドはシグナルを待ち、適切な処理を行い、他のスレッドにシグナルの情報を伝えます。</p><p>加えて、(バージョン 3.08 以降の) OCamlのスレッドはスレッドのプリエンプションに内部で <code>sigvtalarm</code> を使います。そのためこのシグナルを使うとシステムと干渉する可能性があるために、<code>sigvtalarm</code> シグナルはプログラムの中で使うことができません。</p><!--TOC chapter id="sec/more" さらに先へ-->
<h1 class="chapter" id="sec/more"><a id="htocmore">さらに先へ</a></h1><!--SEC END --><!--NAME more.html-->
<p>これまで見てきたのはオペレーティングシステムとやり取りをするアプリケーションを作るために OCamlの <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html"><span class="c003">Sys</span></a>、 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html"><span class="c003">Unix</span></a> そして <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Threads.html"><span class="c003">Threads</span></a> モジュールを使う方法です。</p><p>これらのモジュールを使うと 重要な Unix システムコールのほとんどを OCamlから直接呼び出すことができます。プログラミングを容易にするため、あるいは OCamlのランタイムシステムが必要とする不変量を保つために、いくつかのシステムコールは高レベルな関数に置き換えられています。いずれの場合でも、この Unix システムへの高レベルなアクセスはアプリケーションの開発を円滑にします。</p><p>全ての Unix の機能がこれらのモジュールから利用可能なわけではありません。しかし C のバインディングを書けば利用できない機能にアクセスすることが可能です。</p><p>別の便利なライブラリは OCamlから直接スクリプトを書くことを目的とした Cash [<a href="#Cash">3</a>] です。このライブラリは <code>Unix</code> を二つの方法で補完します。一つ目はスクリプトを書くためのヘルパー関数に加えて、<code>Unix</code> モジュールの上にプロセスとパイプの管理を助けるためのシステムコールの亜種を用意していることです。もう一つは Unix システムに追加のエントリーポイントを追加することです。
</p><!--TOC chapter id="sec176" 参考文献-->
<h1 class="chapter" id="sec176"><a id="htocrefs">参考文献</a></h1><!--SEC END --><dl class="thebibliography"><dt class="dt-thebibliography">

<!--NAME references.html-->

<dt class="bibsection">OCaml</dt><a id="Caml-Light">[1]</a></dt><dd class="dd-thebibliography">
Xavier Leroy, Michel Mauny. <em>The Caml Light system, release 0.5.
Documentation and user’s manual.</em> L-5 software, distributed by <span class="c007">inria</span>.</dd><dt class="dt-thebibliography"><a id="OCaml">[2]</a></dt><dd class="dd-thebibliography">
Xavier Leroy, Didier Rémy, Jacques Garrigue, Jérôme Vouillon and
Damien Doligez.
<em>The OCaml system,
documentation and user’s manual – release 3.06.</em>
Documentation distributed by <span class="c007">inria</span> with the OCaml
system, August 2002.
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/"><span class="c003">http://caml.inria.fr/pub/docs/manual-ocaml/</span></a>.</dd><dt class="dt-thebibliography"><a id="Cash">[3]</a></dt><dd class="dd-thebibliography">
Bruno Verlyck.
<em>Cash, the Caml Shell – release 0.20</em>.
Documentation distributed by <span class="c007">inria</span> with the Cash system, 2002.
<a href="http://pauillac.inria.fr/cash/"><span class="c003">http://pauillac.inria.fr/cash/</span></a>.<dt class="bibsection">Unix システムプログラミング</dt></dd><dt class="dt-thebibliography"><a id="man">[4]</a></dt><dd class="dd-thebibliography">
The Unix <span class="c003">man</span>ual, sections 2 and 3.</dd><dt class="dt-thebibliography"><a id="KP">[5]</a></dt><dd class="dd-thebibliography">
Brian Kernighan, Rob Pike. <em>The Unix programming
environment</em>, Addison-Wesley.</dd><dt class="dt-thebibliography"><a id="R1">[6]</a></dt><dd class="dd-thebibliography">
Jean-Marie Rifflet. <em>La programmation sous Unix</em>. McGraw-Hill.</dd><dt class="dt-thebibliography"><a id="R2">[7]</a></dt><dd class="dd-thebibliography">
Jean-Marie Rifflet. <em>La communication sous Unix</em>. McGraw-Hill.<dt class="bibsection">Unix カーネルのアーキテクチャ</dt></dd><dt class="dt-thebibliography"><a id="BSD">[8]</a></dt><dd class="dd-thebibliography">
Samuel Leffler, Marshall McKusick, Michael Karels, John Quarterman.
<em>The design and implementation of the 4.3 <span class="c007">bsd</span>
Unix operating system</em>,
Addison-Wesley.</dd><dt class="dt-thebibliography"><a id="Bach">[9]</a></dt><dd class="dd-thebibliography">
Maurice Bach. <em>The design and implementation of the Unix operating
system</em>, Prentice-Hall.</dd><dt class="dt-thebibliography"><a id="Stevens/advanced">[10]</a></dt><dd class="dd-thebibliography">
Richard W. Stevens.
<em>Advanced Programming in the Unix Environment</em>.
Addison-Wesley, 1992.</dd><dt class="dt-thebibliography"><a id="Kay-Stevens/Practical">[11]</a></dt><dd class="dd-thebibliography">
Kay A. Robbins and Steven Robbins.
<em>Practical Unix Programming.
A Guide to Concurrency, Communication, and Multithreading</em>.
Prentice Hall, 1996.<dt class="bibsection">オペレーティングシステムに関する一般的な知識</dt></dd><dt class="dt-thebibliography"><a id="T3">[12]</a></dt><dd class="dd-thebibliography">
Andrew Tanenbaum. <em>Modern Operating Systems</em>,
Second Edition, Prentice-Hall, 2001.</dd><dt class="dt-thebibliography"><a id="T1">[13]</a></dt><dd class="dd-thebibliography">
Andrew Tanenbaum. <em>Operating systems, design and implementation</em>,
Prentice-Hall.</dd><dt class="dt-thebibliography"><a id="T2">[14]</a></dt><dd class="dd-thebibliography">
Andrew Tanenbaum. <em>Computer Networks</em>, Prentice-Hall.<dt class="bibsection">構造化オブジェクトの型付き通信</dt></dd><dt class="dt-thebibliography"><a id="Dynamiques">[15]</a></dt><dd class="dd-thebibliography">
Xavier Leroy, Michel Mauny. <em>Dynamics in ML</em>. Actes de <span class="c007">fpca</span> 91,
<span class="c007">lncs</span> 523, Springer-Verlag.</dd><dt class="dt-thebibliography"><a id="CML">[16]</a></dt><dd class="dd-thebibliography">
John H. Reppy. <em>Concurrent Programming in ML</em>.
Cambridge University Press, 1999.<dt class="bibsection">スレッドプログラミング</dt></dd><dt class="dt-thebibliography"><a id="Butenhof/threads">[17]</a></dt><dd class="dd-thebibliography">
David R. Butenhof.
<em>Programming with <span class="c007">posix</span> Threads</em>.
Addison-Wesley, 1997.<dt class="bibsection">アプリケーション</dt></dd><dt class="dt-thebibliography"><a id="Unison">[18]</a></dt><dd class="dd-thebibliography">
Pierce et al.
<em>Unison File Synchronizer. Version 2.9.1.
User Manual and Reference</em>.
Free software available from
<a href="http://www.cis.upenn.edu/~bcpierce/unison/"><span class="c003">http://www.cis.upenn.edu/~bcpierce/unison/</span></a>.
</dd></dl><!--TOC chapter id="sec177" Index-->
<h1 class="chapter" id="sec177">Index</h1><!--SEC END --><p>
<a id="htocindex"></a> ボールド体のリンクは <span class="c007">posix</span> システムコールの説明へのリンクです。
</p><table class="c000 cellpading0"><tr><td class="c013"><ul class="indexenv"><li class="li-indexenv">
<span class="c003">accept</span>, <a href="#hevea_default121"><span class="c008">6.7</span></a>
</li><li class="li-indexenv"><span class="c003">access</span>, <a href="#hevea_default36"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">alarm</span>, <a href="#hevea_default79"><span class="c008">4.2</span></a>
</li><li class="li-indexenv"><span class="c003">argv</span>, <a href="#hevea_default0"><span class="c004">1.2</span></a>
</li><li class="li-indexenv"><span class="c003">at_exit</span>, <a href="#hevea_default4"><span class="c004">1.2</span></a>
</li><li class="li-indexenv"><span class="c003">bind</span>, <a href="#hevea_default119"><span class="c008">6.7</span></a>, <a href="#hevea_default125"><span class="c004">6.8</span></a>
</li><li class="li-indexenv"><span class="c003">broadcast</span>, <a href="#hevea_default156"><span class="c008">7.6</span></a>
</li><li class="li-indexenv"><span class="c003">chdir</span>, <a href="#hevea_default8"><span class="c004">2.1</span></a>
</li><li class="li-indexenv"><span class="c003">chmod</span>, <a href="#hevea_default34"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">choose</span>, <a href="#hevea_default162"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">chown</span>, <a href="#hevea_default26"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">chroot</span>, <a href="#hevea_default9"><span class="c004">2.1</span></a>
</li><li class="li-indexenv"><span class="c003">clear_nonblock</span>, <a href="#hevea_default102"><span class="c004">5.3</span></a>
</li><li class="li-indexenv"><span class="c003">close</span>, <a href="#hevea_default46"><span class="c008">2.8</span></a>, <a href="#hevea_default117"><span class="c004">6.5</span></a>, <a href="#hevea_default124"><span class="c004">6.8</span></a>
</li><li class="li-indexenv"><span class="c003">closedir</span>, <a href="#hevea_default41"><span class="c008">2.4</span></a>
</li><li class="li-indexenv"><span class="c003">connect</span>, <a href="#hevea_default114"><span class="c008">6.4</span></a>, <a href="#hevea_default129"><span class="c004">6.10</span></a>, <a href="#hevea_default130"><span class="c004">6.10</span></a>
</li><li class="li-indexenv"><span class="c003">create</span>, <a href="#hevea_default143"><span class="c008">7.2</span></a>
</li><li class="li-indexenv"><span class="c003">delay</span>, <a href="#hevea_default150"><span class="c004">7.3</span></a>
</li><li class="li-indexenv"><span class="c003">dup2</span>, <a href="#hevea_default104"><span class="c008">5.4</span></a>
</li><li class="li-indexenv"><span class="c003">dup</span>, <a href="#hevea_default105"><span class="c008">5.4</span></a>
</li><li class="li-indexenv"><span class="c003">environment</span>, <a href="#hevea_default1"><span class="c004">1.2</span></a>
</li><li class="li-indexenv"><span class="c003">error_message</span>, <a href="#hevea_default6"><span class="c004">1.3</span></a>
</li><li class="li-indexenv"><span class="c003">establish_server</span>, <a href="#hevea_default139"><span class="c004">6.12</span></a>
</li><li class="li-indexenv"><span class="c003">execv</span>, <a href="#hevea_default75"><span class="c008">3.4</span></a>
</li><li class="li-indexenv"><span class="c003">execve</span>, <a href="#hevea_default74"><span class="c008">3.4</span></a>, <a href="#hevea_default82"><span class="c004">4.3</span></a>
</li><li class="li-indexenv"><span class="c003">execvp</span>, <a href="#hevea_default76"><span class="c008">3.4</span></a>, <a href="#hevea_default83"><span class="c004">4.3</span></a>
</li><li class="li-indexenv"><span class="c003">exit</span>, <a href="#hevea_default3"><span class="c004">1.2</span></a>, <a href="#hevea_default144"><span class="c008">7.2</span></a>, <a href="#hevea_default145"><span class="c004">7.2</span></a>, <a href="#hevea_default146"><span class="c004">7.2</span></a>
</li><li class="li-indexenv"><span class="c003">fchmod</span>, <a href="#hevea_default35"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">fchown</span>, <a href="#hevea_default27"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">fork</span>, <a href="#hevea_default68"><span class="c008">3.1</span></a>, <a href="#hevea_default81"><span class="c004">4.3</span></a>, <a href="#hevea_default142"><span class="c004">7.1</span></a>, <a href="#hevea_default165"><span class="c004">7.8</span></a>
</li><li class="li-indexenv"><span class="c003">fstat</span>, <a href="#hevea_default19"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">ftruncate</span>, <a href="#hevea_default49"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">getcwd</span>, <a href="#hevea_default7"><span class="c004">2.1</span></a>
</li><li class="li-indexenv"><span class="c003">getegid</span>, <a href="#hevea_default31"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getenv</span>, <a href="#hevea_default2"><span class="c004">1.2</span></a>
</li><li class="li-indexenv"><span class="c003">geteuid</span>, <a href="#hevea_default30"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getgid</span>, <a href="#hevea_default29"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getgrgid</span>, <a href="#hevea_default23"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getgrnam</span>, <a href="#hevea_default21"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getgroups</span>, <a href="#hevea_default25"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">gethostbyname</span>, <a href="#hevea_default112"><span class="c008">6.3</span></a>
</li><li class="li-indexenv"><span class="c003">gethostname</span>, <a href="#hevea_default126"><span class="c004">6.9</span></a>
</li><li class="li-indexenv"><span class="c003">getitimer</span>, <a href="#hevea_default92"><span class="c004">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">getlogin</span>, <a href="#hevea_default24"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getpid</span>, <a href="#hevea_default69"><span class="c004">3.1</span></a>
</li><li class="li-indexenv"><span class="c003">getprotobyname</span>, <a href="#hevea_default109"><span class="c008">6.2</span></a>
</li><li class="li-indexenv"><span class="c003">getpwnam</span>, <a href="#hevea_default20"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getpwuid</span>, <a href="#hevea_default22"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">getservbyname</span>, <a href="#hevea_default113"><span class="c008">6.3</span></a>
</li><li class="li-indexenv"><span class="c003">getsockopt</span>, <a href="#hevea_default122"><span class="c008">6.8</span></a>
</li><li class="li-indexenv"><span class="c003">gettimeofday</span>, <a href="#hevea_default91"><span class="c008">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">getuid</span>, <a href="#hevea_default28"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">gmtime</span>, <a href="#hevea_default94"><span class="c004">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">handle_unix_error</span>, <a href="#hevea_default5"><span class="c004">1.3</span></a>
</li><li class="li-indexenv"><span class="c003">in_channel_of_descr</span>, <a href="#hevea_default99"><span class="c004">5.2</span></a>
</li><li class="li-indexenv"><span class="c003">inet_addr_of_string</span>, <a href="#hevea_default110"><span class="c004">6.3</span></a>
</li><li class="li-indexenv"><span class="c003">input_value</span>, <a href="#hevea_default141"><span class="c004">6.13</span></a>
</li><li class="li-indexenv"><span class="c003">ioctl</span>, <a href="#hevea_default57"><span class="c008">2.13</span></a>, <a href="#hevea_default58"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">join</span>, <a href="#hevea_default148"><span class="c008">7.3</span></a>
</li><li class="li-indexenv"><span class="c003">kill</span>, <a href="#hevea_default78"><span class="c008">4.2</span></a>
</li><li class="li-indexenv"><span class="c003">link</span>, <a href="#hevea_default11"><span class="c008">2.2</span></a>
</li><li class="li-indexenv"><span class="c003">listen</span>, <a href="#hevea_default120"><span class="c008">6.7</span></a>
</li><li class="li-indexenv"><span class="c003">localtime</span>, <a href="#hevea_default71"><span class="c004">3.2</span></a>, <a href="#hevea_default95"><span class="c004">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">lock</span>, <a href="#hevea_default152"><span class="c008">7.4</span></a>
</li></ul></td><td class="c013"><ul class="indexenv"><li class="li-indexenv"><span class="c003">lockf</span>, <a href="#hevea_default66"><span class="c008">2.14</span></a>
</li><li class="li-indexenv"><span class="c003">lseek</span>, <a href="#hevea_default56"><span class="c004">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">lstat</span>, <a href="#hevea_default18"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">mkdir</span>, <a href="#hevea_default42"><span class="c008">2.4</span></a>
</li><li class="li-indexenv"><span class="c003">mkfifo</span>, <a href="#hevea_default101"><span class="c008">5.3</span></a>
</li><li class="li-indexenv"><span class="c003">mktime</span>, <a href="#hevea_default96"><span class="c004">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">new_channel</span>, <a href="#hevea_default158"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">open_connection</span>, <a href="#hevea_default137"><span class="c004">6.12</span></a>
</li><li class="li-indexenv"><span class="c003">opendir</span>, <a href="#hevea_default38"><span class="c008">2.4</span></a>, <a href="#hevea_default53"><span class="c004">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">openfile</span>, <a href="#hevea_default50"><span class="c004">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">out_channel_of_descr</span>, <a href="#hevea_default100"><span class="c004">5.2</span></a>
</li><li class="li-indexenv"><span class="c003">output_value</span>, <a href="#hevea_default140"><span class="c004">6.13</span></a>
</li><li class="li-indexenv"><span class="c003">pipe</span>, <a href="#hevea_default98"><span class="c008">5.1</span></a>
</li><li class="li-indexenv"><span class="c003">poll</span>, <a href="#hevea_default164"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">read</span>, <a href="#hevea_default37"><span class="c004">2.4</span></a>, <a href="#hevea_default44"><span class="c008">2.7</span></a>, <a href="#hevea_default77"><span class="c004">4</span></a>, <a href="#hevea_default116"><span class="c004">6.4</span></a>, <a href="#hevea_default133"><span class="c004">6.11</span></a>
</li><li class="li-indexenv"><span class="c003">readdir</span>, <a href="#hevea_default39"><span class="c008">2.4</span></a>
</li><li class="li-indexenv"><span class="c003">readlink</span>, <a href="#hevea_default55"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">receive</span>, <a href="#hevea_default160"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">recv</span>, <a href="#hevea_default131"><span class="c008">6.11</span></a>, <a href="#hevea_default135"><span class="c008">6.11</span></a>
</li><li class="li-indexenv"><span class="c003">recvfrom</span>, <a href="#hevea_default127"><span class="c008">6.10</span></a>
</li><li class="li-indexenv"><span class="c003">rename</span>, <a href="#hevea_default13"><span class="c008">2.2</span></a>
</li><li class="li-indexenv"><span class="c003">rewinddir</span>, <a href="#hevea_default40"><span class="c008">2.4</span></a>
</li><li class="li-indexenv"><span class="c003">rmdir</span>, <a href="#hevea_default43"><span class="c008">2.4</span></a>
</li><li class="li-indexenv"><span class="c003">seek</span>, <a href="#hevea_default47"><span class="c008">2.12</span></a>
</li><li class="li-indexenv"><span class="c003">select</span>, <a href="#hevea_default85"><span class="c004">4.5</span></a>, <a href="#hevea_default97"><span class="c004">4.7</span></a>, <a href="#hevea_default106"><span class="c008">5.6</span></a>, <a href="#hevea_default151"><span class="c004">7.3</span></a>
</li><li class="li-indexenv"><span class="c003">self</span>, <a href="#hevea_default147"><span class="c008">7.2</span></a>
</li><li class="li-indexenv"><span class="c003">send</span>, <a href="#hevea_default132"><span class="c008">6.11</span></a>, <a href="#hevea_default136"><span class="c008">6.11</span></a>, <a href="#hevea_default159"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">sendto</span>, <a href="#hevea_default128"><span class="c008">6.10</span></a>
</li><li class="li-indexenv"><span class="c003">set_nonblock</span>, <a href="#hevea_default103"><span class="c004">5.3</span></a>
</li><li class="li-indexenv"><span class="c003">setitimer</span>, <a href="#hevea_default93"><span class="c004">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">setsid</span>, <a href="#hevea_default65"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">setsockopt</span>, <a href="#hevea_default123"><span class="c008">6.8</span></a>
</li><li class="li-indexenv"><span class="c003">shutdown_connection</span>, <a href="#hevea_default138"><span class="c004">6.12</span></a>
</li><li class="li-indexenv"><span class="c003">shutdown</span>, <a href="#hevea_default118"><span class="c008">6.5</span></a>
</li><li class="li-indexenv"><span class="c003">signal</span>, <a href="#hevea_default80"><span class="c008">4.3</span></a>, <a href="#hevea_default157"><span class="c008">7.6</span></a>
</li><li class="li-indexenv"><span class="c003">sigprocmask</span>, <a href="#hevea_default84"><span class="c008">4.4</span></a>
</li><li class="li-indexenv"><span class="c003">sleep</span>, <a href="#hevea_default89"><span class="c008">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">socket</span>, <a href="#hevea_default108"><span class="c008">6.2</span></a>
</li><li class="li-indexenv"><span class="c003">stat</span>, <a href="#hevea_default17"><span class="c008">2.3</span></a>, <a href="#hevea_default51"><span class="c004">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">stderr</span>, <a href="#hevea_default16"><span class="c004">2.2</span></a>
</li><li class="li-indexenv"><span class="c003">stdin</span>, <a href="#hevea_default14"><span class="c004">2.2</span></a>
</li><li class="li-indexenv"><span class="c003">stdout</span>, <a href="#hevea_default15"><span class="c004">2.2</span></a>
</li><li class="li-indexenv"><span class="c003">string_of_inet_addr</span>, <a href="#hevea_default111"><span class="c004">6.3</span></a>
</li><li class="li-indexenv"><span class="c003">symlink</span>, <a href="#hevea_default12"><span class="c008">2.2</span></a>, <a href="#hevea_default54"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">sync</span>, <a href="#hevea_default161"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">system</span>, <a href="#hevea_default86"><span class="c004">4.5</span></a>
</li><li class="li-indexenv"><span class="c003">tcdrain</span>, <a href="#hevea_default62"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">tcflow</span>, <a href="#hevea_default64"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">tcflush</span>, <a href="#hevea_default63"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">tcgetattr</span>, <a href="#hevea_default59"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">tcsendbreak</span>, <a href="#hevea_default61"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">tcsetattr</span>, <a href="#hevea_default60"><span class="c008">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">time</span>, <a href="#hevea_default70"><span class="c004">3.2</span></a>, <a href="#hevea_default88"><span class="c004">4.6</span></a>, <a href="#hevea_default90"><span class="c004">4.6</span></a>
</li><li class="li-indexenv"><span class="c003">truncate</span>, <a href="#hevea_default48"><span class="c008">2.13</span></a>, <a href="#hevea_default52"><span class="c004">2.13</span></a>
</li><li class="li-indexenv"><span class="c003">trylock</span>, <a href="#hevea_default154"><span class="c008">7.4</span></a>
</li><li class="li-indexenv"><span class="c003">umask</span>, <a href="#hevea_default32"><span class="c008">2.3</span></a>, <a href="#hevea_default33"><span class="c008">2.3</span></a>
</li><li class="li-indexenv"><span class="c003">unlink</span>, <a href="#hevea_default10"><span class="c008">2.2</span></a>
</li><li class="li-indexenv"><span class="c003">unlock</span>, <a href="#hevea_default153"><span class="c008">7.4</span></a>
</li><li class="li-indexenv"><span class="c003">utime</span>, <a href="#hevea_default67"><span class="c008">2.15</span></a>
</li><li class="li-indexenv"><span class="c003">wait</span>, <a href="#hevea_default72"><span class="c004">3.3</span></a>, <a href="#hevea_default155"><span class="c008">7.6</span></a>
</li><li class="li-indexenv"><span class="c003">waitpid</span>, <a href="#hevea_default73"><span class="c008">3.3</span></a>, <a href="#hevea_default87"><span class="c004">4.5</span></a>
</li><li class="li-indexenv"><span class="c003">wrap_abort</span>, <a href="#hevea_default163"><span class="c004">7.7</span></a>
</li><li class="li-indexenv"><span class="c003">write</span>, <a href="#hevea_default45"><span class="c008">2.7</span></a>, <a href="#hevea_default107"><span class="c008">5.7</span></a>, <a href="#hevea_default115"><span class="c004">6.4</span></a>, <a href="#hevea_default134"><span class="c004">6.11</span></a>
</li><li class="li-indexenv"><span class="c003">yield</span>, <a href="#hevea_default149"><span class="c004">7.3</span></a>
</li></ul></td></tr>
</table><!--NAME docindex.html-->
<!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</body>
</html>
