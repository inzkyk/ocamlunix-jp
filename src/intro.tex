%------------------------------------------------------------------------------
% Copyright (c) 1991-2014, Xavier Leroy and Didier Remy.  
%
% All rights reserved. Distributed under a creative commons
% attribution-non-commercial-share alike 2.0 France license.
% http://creativecommons.org/licenses/by-nc-sa/2.0/fr/
%
% Translation by Daniel C. Buenzli
%------------------------------------------------------------------------------

\chapter*{\label{sec/intro}\ifhtml{\aname{htocintro}}Introduction}
\addcontentsline{toc}{chapter}{\ifhtml{\ahrefloc{htocintro}}{Introduction}}
\cutname{intro.html}
\enlargethispage{2\baselineskip} %% To avoid a widow

These course notes originate from a system programming course Xavier
Leroy taught in 1994 to the first year students of the Master's program in
fundamental and applied mathematics and computer science at the École
Normale Supérieure. This earliest version used the
Caml-Light~\cite{Caml-Light} language.
%
For a Master's course in computer science at the École Polytechnique
taught from 2003 to 2006, Didier Rémy adapted the notes to use the
{\ocaml} language. During these years, Gilles Roussel, Fabrice Le
Fessant and Maxence Guesdon helped to teach the course and also
contributed to this document. The new version also brought
additions and updates. In ten years, some orders of magnitude have
shifted by a digit and the web has left its infancy. For instance, the
{\http} relay example, now commonplace, may have been a forerunner in
1994. But, most of all, the {\ocaml} language gained maturity and was
used to program real system applications like Unison~\cite{Unison}.

Tradition dictates that Unix system programming must be done in C. For
this course we found it more interesting to use a higher-level
language, namely {\ocaml}, to explain the fundamentals of Unix system
programming.

The {\ocaml} interface to Unix system calls is more abstract. Instead
of encoding everything in terms of integers and bit fields as in C,
{\ocaml} uses the whole power of the ML type system to clearly
represent the arguments and return values of system calls. Hence, it
becomes easier to explain the semantics of the calls instead of losing
oneself explaining how the arguments and the results have to be
en/decoded. (See, for example, the presentation of the system call
\ml+wait+, page~\pageref{wait}.)

Furthermore, due to the static type system and the clarity of its
primitives, it is safer to program in {\ocaml} than in C. The
experienced C programmer may see these benefits as useless luxury,
however they are crucial for the inexperienced audience of this course.

A second goal of this exposition of system programming is to show
{\ocaml} performing in a domain out of its usual applications in
theorem proving, compilation and symbolic computation. The outcome of
the experiment is rather positive, thanks to {\ocaml}'s solid
imperative kernel and its other novel aspects like parametric
polymorphism, higher-order functions and exceptions. It also shows
that instead of applicative and imperative programming being mutually
exclusive, their combination makes it possible to integrate in the
same program complex symbolic computations and a good interface with
the operating system.

These notes assume the reader is familiar with {\ocaml} and Unix shell
commands. For any question about the language, consult the OCaml
System documentation~\cite{OCaml} and for questions about Unix,
read section~1 of the Unix \texttt{man}ual or introductory books on Unix
like~\cite{KP,R1}.


This document describes only the programmatic interface to the Unix
system. It presents neither its implementation, neither its internal
architecture. The internal architecture of \textsc{bsd}~4.3 is
described in~\cite{BSD} and of System~\textsc{v}
in~\cite{Bach}. Tanenbaum's books~\cite{T1,T2} give an overall view of
network and operating system architecture.

The Unix interface presented in this document is part of the
OCaml System available as free software at
\url{http://caml.inria.fr/ocaml/}.
