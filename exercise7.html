<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.32">
<link rel="stylesheet" type="text/css" href="ocamlunix.css">
<title>Answer of exercise 7</title>
</head>
<body>
<div class="answer">
<h5 class="paragraph" id="sec61">練習問題 <a href="files.html#ex7">exercise 7</a> の解答</h5>
<p>
<a id="exans7"></a>
問題は一見単純なように見えますが、シンボリックリンクはハードリンクと違ってディレクトリを含んだ任意のパスを表すことができ、そのパスがアーカイブの中に存在するとは限らないことから、簡単ではありません。</p><p>シンプルな解決法はアーカイブに含まれるファイル階層をメモリ上に再構築することです。

</p><div class="mylisting"><span class="c001">type</span> info = File | Link <span class="c001">of</span> string list | Dir <span class="c001">of</span> (string * inode) list
<span class="c001">and</span> inode = { <span class="c001">mutable</span> record : record option; <span class="c001">mutable</span> info : info;}</div><p>メモリ上に構築されるファイルシステムのノードは <code>inode</code> 型で表されます。<code>info</code> フィールドが通常ファイルとシンボリックリンクとディレクトリに制限されたファイルの種類を表します。パスは文字列のリストとして、ディレクトリは含まれるファイルの名前とノードの組のリストとして表されます。<code>record</code> フィールドはノードに対応する <code>tar</code> レコードを保持します。中間のディレクトリはアーカイブ内にレコードを持たない場合があるので、このフィールドはオプショナルです。ファイルはアーカイブ内に複数回現れることがあり、最後に現れたものが優先されるので <code>info</code> フィールドは変更可能になっています。
</p><div class="mylisting"><span class="c001">let</span> root () =
  <span class="c001">let rec</span> i =
    { record = None; info = Dir [ Filename.current_dir_name, i ] }
  <span class="c001">in</span> i
<span class="c001">let</span> link inode name nod = <span class="c001">match</span> inode.info <span class="c001">with</span>
  | File | Link _ -&gt; error name <span class="c002">"Not a directory"</span>
  | Dir list -&gt;
      <span class="c001">try let</span> _ = List.assoc name list <span class="c001">in</span> error name <span class="c002">"Already exists"</span>
      <span class="c001">with</span> Not_found -&gt; inode.info &lt;- Dir ((name, nod) :: list)

<span class="c001">let</span> mkfile inode name r =
  <span class="c001">let</span> f =  { record = r; info = File } <span class="c001">in</span>
  link inode name f; f
<span class="c001">let</span> symlink inode name r path =
  <span class="c001">let</span> s =  { record = r; info = Link path } <span class="c001">in</span>
  link inode name s; s
<span class="c001">let</span> mkdir inode name r =
  <span class="c001">let</span> d = mkfile inode name r <span class="c001">in</span>
  d.info &lt;-
    Dir [ Filename.current_dir_name, d; Filename.parent_dir_name, inode ];
  d</div><p>Unix と同様に各ディレクトリは自分自身と親に対するリンクを持ちます。ただしルートディレクトリの親が自分自身となる Unix とは違い、いま考えているファイルシステムではルートディレクトリは親を持ちません。これによってアーカイブの外側のファイルに対するアクセスを検出しやめさせることができます。
</p><div class="mylisting"><span class="c001">let rec</span> find link inode path = <span class="c001">match</span> inode.info, path <span class="c001">with</span>
  | _, [] -&gt; inode
  | Dir list, name :: rest -&gt;
      <span class="c001">let</span> subnode = List.assoc name list <span class="c001">in
      let</span> subnode =
        <span class="c001">match</span> subnode.info <span class="c001">with</span>
          Link q -&gt;
            <span class="c001">if</span> link &amp;&amp; rest = [] <span class="c001">then</span> subnode <span class="c001">else</span> find <span class="c001">false</span> inode q
        | _ -&gt; subnode  <span class="c001">in</span>
      find link subnode rest
  | _, _ -&gt; raise Not_found;;</div><p><code>find</code> 関数はアーカイブから <code>path</code> に対応するノードを <code>inode</code> を始点として探索します。引数 <code>link</code> は探索がリンクを返した場合にリンクそのものを返すべきなのか (<code><span class="c001">true</span></code>) それともリンクが指すファイルを返すべきなのか (<code><span class="c001">false</span></code>) を決めます。
</p><div class="mylisting"><span class="c001">let rec</span> mkpath inode path =
  <span class="c001">match</span> inode.info, path <span class="c001">with</span>
  | _, [] -&gt; inode
  | Dir list, name :: rest -&gt;
      <span class="c001">let</span> subnode =
        <span class="c001">try</span> List.assoc name list
        <span class="c001">with</span> Not_found -&gt;  mkdir inode name None <span class="c001">in</span>
      mkpath subnode rest
  | _, _ -&gt; raise Not_found;;</div><p><code>mkpath</code> 関数はパス <code>path</code> をたどってパス上の存在しないノードを作成します。
</p><div class="mylisting"><span class="c001">let</span> explode f =
  <span class="c001">let rec</span> dec f p =
    <span class="c001">if</span> f = Filename.current_dir_name <span class="c001">then</span> p
    <span class="c001">else</span> dec (Filename.dirname f) (Filename.basename f :: p) <span class="c001">in</span>
  dec (<span class="c001">if</span> Filename.basename f = <span class="c002">""</span> <span class="c001">then</span> Filename.dirname f <span class="c001">else</span> f) [];;</div><p><code>ml</code> 関数は Unix のパスをパースして文字列のリストにします。このときアーカイブでは許されているディレクトリ末尾の “<code>/</code>” を削除します。

</p><div class="mylisting"><span class="c001">let</span> add archive r =
  <span class="c001">match</span> r.header.kind <span class="c001">with</span>
  | CHR (_,_) | BLK (_,_) | FIFO -&gt; ()
  | kind -&gt;
      <span class="c001">match</span> List.rev (explode r.header.name) <span class="c001">with</span>
      | []  -&gt; ()
      | name :: parent_rev -&gt;
          <span class="c001">let</span> inode = mkpath archive (List.rev parent_rev) <span class="c001">in
          match</span> kind <span class="c001">with</span>
          | DIR -&gt; ignore (mkdir inode name (Some r))
          | REG | CONT -&gt; ignore (mkfile inode name (Some r))
          | LNK f -&gt; ignore (symlink inode name (Some r) (explode f))
          | LINK f -&gt; link inode name (find <span class="c001">true</span> archive (explode f))
          | _ -&gt; <span class="c001">assert false</span>;;</div><p><code>add</code> 関数はレコード <code>r</code> をアーカイブに追加します。ルートノードで表されるアーカイブは副作用で変更されます。
</p><div class="mylisting"><span class="c001">let</span> find_and_copy tarfile filename =
  <span class="c001">let</span> fd = openfile tarfile [ O_RDONLY ] 0 <span class="c001">in
  let</span> records = List.rev (fold (<span class="c001">fun</span> x y -&gt; x :: y) [] fd) <span class="c001">in
  let</span> archive = root () <span class="c001">in</span>
  List.iter (add archive) records;
  <span class="c001">let</span> inode =
    <span class="c001">try</span> find <span class="c001">false</span> archive (explode filename)
    <span class="c001">with</span> Not_found -&gt; error filename <span class="c002">"File not found"</span> <span class="c001">in
  begin match</span> inode.record <span class="c001">with</span>
  | Some ({ header = { kind = (REG | CONT) }} <span class="c001">as</span> r) -&gt; copy_file r stdout
  | Some _ -&gt; error filename <span class="c002">"Not a regular file"</span>
  | None -&gt; error filename <span class="c002">"Not found"</span>
  <span class="c001">end</span>;
  close fd;;</div><p>最後はこれまでと同じです。
</p><div class="mylisting"><span class="c001">let</span> readtar () =
  <span class="c001">let</span> nargs = Array.length Sys.argv <span class="c001">in
  if</span> nargs = 2 <span class="c001">then</span> list Sys.argv.(1)
  <span class="c001">else if</span> nargs = 3 <span class="c001">then</span> find_and_copy Sys.argv.(1) Sys.argv.(2)
  <span class="c001">else</span> prerr_endline (<span class="c002">"Usage: "</span> ^Sys.argv.(0)^ <span class="c002">" &lt;tarfile&gt; [ &lt;source&gt; ]"</span>);;

Printexc.print (handle_unix_error (handle_error readtar)) ();;</div><div class="fancybreak">* * *</div></div></body>
</html>
